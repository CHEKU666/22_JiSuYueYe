<?xml version="1.0" encoding="GB2312"?>
<root cmdName="通讯工具命令表">
  <Command cmdname="超级终端模式" cmdType="P" cmd="[P]void main()
{
    SetLayoutMode(0);
    ClearOutputWin();   //清除输出窗口内容
    ClearCommWin();
    CloseInputWin();
    ShowTerminalWin();
    HideLeftTools();
    HideRightTools();
    ClearVclControls();
    HideVclWin();
}"/>
  <Command cmdname="编程布局" cmdType="P" cmd="[P]void main()
{
    SetLayoutMode(1);
    CloseOutputWin();
    HideLeftTools();
    HideRightTools();
    HideVclWin();
}"/>
  <Command cmdname="默认布局" cmdType="P" cmd="[P]void main()
{
   //ClearOutput();   //清除输出窗口内容  
   //ClearCommWin();
   SetLayoutMode(0);
   OpenInputWin();
   HideTerminalWin();
   ClearVclControls();
   HideVclWin();
   HideLeftTools();
   HideRightTools();
}"/>
  <Command cmdname="计算器" cmdType="P" cmd="[P]void main()
{
    WinExec(&quot;calc.exe&quot;);

}"/>
  <Command cmdname="Windows系统工具" cmdType="S" cmd="[S]new command">
    <Command cmdname="计算器" cmdType="P" cmd="[P]void main()
{
    WinExec(&quot;calc.exe&quot;);

}"/>
    <Command cmdname="记事本" cmdType="P" cmd="[P]void main()
{
    WinExec(&quot;notepad.exe&quot;);
}"/>
    <Command cmdname="命令行" cmdType="P" cmd="[P]void main()
{
    WinExec(&quot;cmd.exe&quot;);
}"/>
    <Command cmdname="画图" cmdType="P" cmd="[P]
void main()
{
    WinExec(&quot;mspaint.exe&quot;);
}"/>
    <Command cmdname="Windows 超级终端:COM]" cmdType="P" cmd="[P]
void main()
{
    WinExec(&quot;C:\\Program Files\\Windows NT\\hypertrm.exe C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\附件\\通讯\\超级终端\\com 1&quot;);

}
"/>
  </Command>
  <Command cmdname="实用工具" cmdType="S" cmd="[S]数据发送区
">
    <Command cmdname="超级终端" cmdType="P" cmd="[P]void main()
{
   ClearOutputWin();   //清除输出窗口内容
   ClearCommWin();
   CloseInputWin();
   ShowTerminalWin();
   HideLeftTools();
   HideRightTools();
   ClearVclControls();
   HideVclWin();
}"/>
    <Command cmdname="定时发送" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
int edt1;
int cbHex;
int cbx1;
int tmr1;
int btn0,btn1,btn2;
void OnClose(int *sender)
{
    HideVclWin();
    CloseVclWin();
    ////PrintToCommWin(&quot;over&quot;);

}
void OnStart(void *sender)
{
    char s[200];
    GetProperty(cbx1,&quot;text&quot;,s,20);
    int inv=atoi(s);
    printf(&quot;%d&quot;,inv);
    SetProperty(tmr1,&quot;interval&quot;,inv);
    SetProperty(tmr1,&quot;enabled&quot;,1);
    SetProperty(btn1,&quot;enabled&quot;,0);
    SetProperty(btn2,&quot;enabled&quot;,1);

    //myForm.btnStart.Enabled=false;
    //myForm.btnStop.Enabled=true;
}
void OnStop()
{
    SetProperty(tmr1,&quot;enabled&quot;,0);
    SetProperty(btn1,&quot;enabled&quot;,1);
    SetProperty(btn2,&quot;enabled&quot;,0);

}
void OnTimer()
{
    char s[200];
    int ck;
    //PrintToCommWin(&quot;abc&quot;);
    ck=GetProperty(cbHex,&quot;checked&quot;,s,4);
    //printf(&quot;checked:%s&quot;,s);
    GetProperty(edt1,&quot;text&quot;,s,200);
    if(ck==1)
        SendHexString(s);
    else
        SendString(s);
}


void main()
{
    ClearOutputWin();   //清除输出窗口内容
    ClearCommWin();
    //CloseInputWin();
    CloseCodeWin();//
    HideLeftTools();
    HideRightTools();
    HideOutputWin();
    ClearVclControls();
    int p=GetGuiWin(0);

    btn0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,     &quot;left&quot;,230,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnClose,NULL);//创建按钮
    btn1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;开始发送&quot;, &quot;left&quot;,10,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnStart,NULL);//创建按钮
    btn2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;停止发送&quot;, &quot;left&quot;,120,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnStop,NULL);//创建按钮
    int lbl1=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;发送内容:&quot;,&quot;left&quot;,10,&quot;top&quot;,8,&quot;width&quot;,90,&quot;height&quot;,20,NULL);//创建按钮
    edt1=CreateComponentEx(p,&quot;edit&quot;,  &quot;text&quot;,   &quot;123456&quot;,   &quot;left&quot;,70,&quot;top&quot;,5,&quot;width&quot;,260,&quot;height&quot;,20,NULL);//创建按钮
    cbHex=CreateComponentEx(p,&quot;checkbox&quot;,&quot;caption&quot;,&quot;十六进制发送&quot;,&quot;left&quot;,10,&quot;top&quot;,35,&quot;width&quot;,100,&quot;height&quot;,20,NULL);//创建按钮
    int lbl2=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;发送间隔:&quot;,&quot;left&quot;,145,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮
    cbx1=CreateComponentEx(p,&quot;combobox&quot;,&quot;text&quot;,&quot;200&quot;,&quot;left&quot;,203,&quot;top&quot;,35,&quot;width&quot;,60,&quot;height&quot;,20,NULL);//创建按钮
    int lbl3=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;毫秒&quot;,&quot;left&quot;,270,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮
    tmr1=CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,500,&quot;enabled&quot;,0,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    //int img=CreateComponentEx(p,&quot;image&quot;,&quot;left&quot;,20,&quot;top&quot;,170,&quot;width&quot;,100,&quot;height&quot;,130,NULL);//创建按钮
    //int canvas=GetProperty(img,&quot;canvas&quot;,0,0);
    //LineTo(canvas,100,100);
    StringsAdd(cbx1,&quot;1&quot;);    
    StringsAdd(cbx1,&quot;100&quot;);
    StringsAdd(cbx1,&quot;200&quot;);
    StringsAdd(cbx1,&quot;500&quot;);
    StringsAdd(cbx1,&quot;1000&quot;);
    //ShowVclWin(120);
    AutoSetVclWinSize();

}
"/>
    <Command cmdname="数据求和" cmdType="P" cmd="[P]
void OnGetSelDat();
void OnGetAllDat();
void OnSum();
void OnClose()
{
    HideVclWin();
    // printf(&quot;hided&quot;);
    CloseVclWin();
}

int edtSdTxt;
int edtSumTxt;
int edtSumTxt1;
int edtDatLen;
void main()
{
    ClearOutputWin(); //清除输出窗口内容
    ClearCommWin();
    CloseCodeWin();
    HideRightTools();
    Update();
    ClearVclControls();
    int p=GetGuiWin(0);
    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;十六进制求和数据:&quot;,&quot;left&quot;,10,&quot;top&quot;,8,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtSdTxt=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;12 D4 AA 8E&quot;,&quot;left&quot;,120,&quot;top&quot;,5,&quot;width&quot;,270,&quot;height&quot;,20,0);
    int button0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区反选数据&quot;,&quot;left&quot;,400,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetSelDat,0);
    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区所有数据&quot;,&quot;left&quot;,400,&quot;top&quot;,38,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetAllDat,0);
    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;十进制求和结果:&quot;,&quot;left&quot;,10,&quot;top&quot;,38,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtSumTxt=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,120,&quot;top&quot;,35,&quot;width&quot;,70,&quot;height&quot;,20,0);
    int lblDatLen=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;数据长度:&quot;,&quot;left&quot;,10,&quot;top&quot;,60,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtDatLen=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,120,&quot;top&quot;,60,&quot;width&quot;,70,&quot;height&quot;,20,0);
    int lblSumTxt1=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;16进制结果(8bit):&quot;,&quot;left&quot;,200,&quot;top&quot;,38,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtSumTxt1=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,300,&quot;top&quot;,35,&quot;width&quot;,70,&quot;height&quot;,20,0);
    int button2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;求和&quot;,&quot;left&quot;,10,&quot;top&quot;,85,&quot;width&quot;,240,&quot;height&quot;,30,&quot;onclick&quot;,OnSum,0);
    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,260,&quot;top&quot;,85,&quot;width&quot;,240,&quot;height&quot;,30,&quot;onclick&quot;,OnClose,0);
    //ShowVclWin(150);
    //ShowOutputWin(200);
    AutoSetVclWinSize();
}
void OnGetSelDat()
{
    char s[2000];
    GetInputWinSelText(s,2000);
    if(strlen(s)==0) return;
    SetProperty(edtSdTxt,&quot;text&quot;,s);
    OnSum();
}
void OnGetAllDat()
{
    char s[2000];
    GetInputWinText(s,2000);
    if(strlen(s)==0) return;
    SetProperty(edtSdTxt,&quot;text&quot;,s);
    OnSum();
}


int GetVal(int val)
{
    if((val&gt;=48)&amp;&amp;(val&lt;=57))
        return val-48;
    else if((val&gt;=97)&amp;&amp;(val&lt;=102))
        return val+10-97;
    else if((val&gt;=65)&amp;&amp;(val&lt;=70))
        return val+10-65;

    return 0;
}

void isDigit(int val)
{
    if((val&gt;=48)&amp;&amp;(val&lt;=57))
        return 1;
    else if((val&gt;=97)&amp;&amp;(val&lt;=102))
        return 1;
    else if((val&gt;=65)&amp;&amp;(val&lt;=70))
        return 1;
    return 0;
}

void OnSum()
{
    int val,val1,gotfirst;

    char s[2000];
    GetProperty(edtSdTxt,&quot;text&quot;,s,2000);

    //s=myForm.edtSdTxt.Text;
    int i=0;
    int sum=0;
    gotfirst=0;
    int len=0;
    int ls=strlen(s);
    while(i&lt;ls)
    {
        i=i+1;
        if(gotfirst==0)
        {
            val=s[i-1];
            if(isDigit(val))
                gotfirst=1;
        }
        else
        {
            val1=s[i-1];
            if(isDigit(val1))
            {
                sum=sum+GetVal(val)*16+GetVal(val1);
                len=len+1;
                gotfirst=0;
            }
            else
            {
                sum=sum+GetVal(val);
                len=len+1;
                gotfirst=0;
            }
        }
    }
    if(gotfirst==1)
    {
        sum=sum+GetVal(val);
        len=len+1;
    }
    sprintf(s,&quot;%d&quot;,sum);
    SetProperty(edtSumTxt,&quot;text&quot;,s);
    sprintf(s,&quot;%x&quot;,sum);
    SetProperty(edtSumTxt1,&quot;text&quot;,s);
    sprintf(s,&quot;%d&quot;,len);
    SetProperty(edtDatLen,&quot;text&quot;,s);

}
"/>
    <Command cmdname="数据异或" cmdType="P" cmd="[P]
void OnGetSelDat();
void OnGetAllDat();
void OnSum();
void OnClose()
{
    HideVclWin();
    // printf(&quot;hided&quot;);
    CloseVclWin();
}

int edtSdTxt;
int edtSumTxt;
int edtSumTxt1;
int edtDatLen;
void main()
{
    ClearOutputWin(); //清除输出窗口内容
    ClearCommWin();
    CloseCodeWin();
    HideRightTools();
    Update();
    ClearVclControls();
    int p=GetGuiWin();
    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;十六进制求和数据:&quot;,&quot;left&quot;,10,&quot;top&quot;,8,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtSdTxt=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;12 D4 AA 8E&quot;,&quot;left&quot;,120,&quot;top&quot;,5,&quot;width&quot;,270,&quot;height&quot;,20,0);
    int button0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区反选数据&quot;,&quot;left&quot;,400,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetSelDat,0);
    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区所有数据&quot;,&quot;left&quot;,400,&quot;top&quot;,38,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetAllDat,0);
    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;十进制求和结果:&quot;,&quot;left&quot;,10,&quot;top&quot;,38,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtSumTxt=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,120,&quot;top&quot;,35,&quot;width&quot;,70,&quot;height&quot;,20,0);
    int lblDatLen=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;数据长度:&quot;,&quot;left&quot;,10,&quot;top&quot;,60,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtDatLen=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,120,&quot;top&quot;,60,&quot;width&quot;,70,&quot;height&quot;,20,0);
    int lblSumTxt1=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;16进制结果(8bit):&quot;,&quot;left&quot;,200,&quot;top&quot;,38,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtSumTxt1=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,300,&quot;top&quot;,35,&quot;width&quot;,70,&quot;height&quot;,20,0);
    int button2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;求和&quot;,&quot;left&quot;,10,&quot;top&quot;,85,&quot;width&quot;,240,&quot;height&quot;,30,&quot;onclick&quot;,OnSum,0);
    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,260,&quot;top&quot;,85,&quot;width&quot;,240,&quot;height&quot;,30,&quot;onclick&quot;,OnClose,0);
    AutoSetVclWinSize();
}
char s[2000];
void OnGetSelDat()
{

    GetInputWinSelText(s,2000);
    if(strlen(s)==0) return;
    SetProperty(edtSdTxt,&quot;text&quot;,s);
    OnSum();
}
void OnGetAllDat()
{
    //char s[2000];
    GetInputWinText(s,2000);
    if(strlen(s)==0) return;
    SetProperty(edtSdTxt,&quot;text&quot;,s);
    OnSum();
}


int GetVal(int val)
{
    if((val&gt;=48)&amp;&amp;(val&lt;=57))
        return val-48;
    else if((val&gt;=97)&amp;&amp;(val&lt;=102))
        return val+10-97;
    else if((val&gt;=65)&amp;&amp;(val&lt;=70))
        return val+10-65;

    return 0;
}

void isDigit(int val)
{
    if((val&gt;=48)&amp;&amp;(val&lt;=57))
        return 1;
    else if((val&gt;=97)&amp;&amp;(val&lt;=102))
        return 1;
    else if((val&gt;=65)&amp;&amp;(val&lt;=70))
        return 1;
    return 0;
}

void OnSum()
{
    int val,val1,gotfirst;

    //char s[2000];
    GetProperty(edtSdTxt,&quot;text&quot;,s,2000);

    //   s=myForm.edtSdTxt.Text;
    int i=0;
    int sum=0;
    gotfirst=0;
    int len=0;
    int ls=strlen(s);
    while(i&lt;ls)
    {
        i=i+1;
        if(gotfirst==0)
        {
            val=s[i-1];
            if(isDigit(val))
                gotfirst=1;
        }
        else
        {
            val1=s[i-1];
            if(isDigit(val1))
            {
                sum=sum^(GetVal(val)*16)^GetVal(val1);
                len=len+1;
                gotfirst=0;
            }
            else
            {
                sum=sum^GetVal(val);
                len=len+1;
                gotfirst=0;
            }
        }
    }
    if(gotfirst==1)
    {
        sum=sum^GetVal(val);
        len=len+1;
    }
    sprintf(s,&quot;%d&quot;,sum);
    SetProperty(edtSumTxt,&quot;text&quot;,s);
    sprintf(s,&quot;%x&quot;,sum);
    SetProperty(edtSumTxt1,&quot;text&quot;,s);
    sprintf(s,&quot;%d&quot;,len);
    SetProperty(edtDatLen,&quot;text&quot;,s);

}
"/>
    <Command cmdname="Ctrl+C" cmdType="H" cmd="[H]03"/>
    <Command cmdname="ZModem发送文件" cmdType="P" cmd="[P]void main()
{
   PrintToCommWin(&quot;Start transmit...&quot;);
   ZModemSendFile(&quot;C:\\crash.txt&quot;,1);
   PrintToCommWin(&quot;Transmit over.&quot;);
}"/>
    <Command cmdname="Bin2Hex" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define BUF_LEN 1
#define LINE     31
int p;

int edt1,edt2,edt3;
void Trans();
long int filesize( FILE *fp )
{
    long int save_pos, size_of_file;

    save_pos = ftell( fp );
    fseek( fp, 0L, SEEK_END );
    size_of_file = ftell( fp );
    fseek( fp, save_pos, SEEK_SET );
    return( size_of_file );
}

void Upper_chars(char *buffer)
{
    unsigned int c;

    for (c=0; c &lt;= strlen(buffer)-1; c++) *(buffer+c)=toupper( *(buffer+c) );
}
void OpenFileClick(void *sender)
{
    char s[200];
    GetFileName(s,200,&quot;*.*&quot;);
    if(strlen(s)&gt;0)
    {
        SetProperty(edt1,&quot;text&quot;,s);
    }
}
void OpenFileClick1(void *sender)
{
    char s[200];
    GetFileName(s,200);
    if(strlen(s)&gt;0)
    {
        SetProperty(edt2,&quot;text&quot;,s);
    }
}
void CloseClick(void *Sender)
{

    ClearOutputWin();   //清除输出窗口内容
    HideVclWin();

    CloseVclWin();
    CloseForm(p);
}

void ViewC()
{
    char s[200],s1[200];
    GetProperty(edt2,&quot;text&quot;,s,200);
    sprintf(s1,&quot;notepad.exe %s&quot;,s);
    WinExec(s1);

}
void CreateGui()
{
    CloseCodeWin();
    ClearVclControls();

    int GuiMode=2;
    if((GuiMode==0)||(GuiMode==1))
        p=GetGuiWin(GuiMode);
    else
        p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;Bin2Hex工具&quot;,&quot;Width&quot;,570,&quot;height&quot;,150,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;, &quot;visible&quot;,1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]

    int pnl =p; //CreateComponentEx(p,&quot;panel&quot;,&quot;caption&quot;,&quot;&quot;,&quot;left&quot;,2,&quot;top&quot;,2,&quot;width&quot;,610,&quot;height&quot;,160,NULL);
    //int txt1= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;                                             Bin2Hex工具&quot;,&quot;left&quot;,30,&quot;top&quot;,10,&quot;width&quot;,350,&quot;color&quot;,0xff00ff,NULL);
    int txt2= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;二进制文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,40-20,&quot;width&quot;,90,NULL);
    edt1= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\boot.ini&quot;,&quot;left&quot;,105,&quot;top&quot;,38-20,&quot;width&quot;,345,NULL);
    int txt3= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;转换到文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,68-20,&quot;width&quot;,90,NULL);
    edt2= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\tmp.txt&quot;,&quot;left&quot;,105,&quot;top&quot;,65-20,&quot;width&quot;,345,NULL);

    int btn1= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,36-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick,NULL);
    int btn2= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,63-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick1,NULL);
    int btn3= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;转    换&quot; ,&quot;left&quot;,75,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,Trans,NULL);
    int btn4= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;查看转换文件&quot;,&quot;left&quot;,215,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,ViewC,NULL);
    int btn5= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;退    出&quot; ,&quot;left&quot;,375,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,CloseClick,NULL);
}
void main()
{

    CreateGui();
}
void Trans()
{
    char  argv[4][255];
    char s[100];
    FILE *source,*dest;
    unsigned char buffer[BUF_LEN], Dummy[20];
    int c;
    GetProperty(edt1,&quot;text&quot;,argv[1],200);
    GetProperty(edt2,&quot;text&quot;,argv[2],200);
    GetProperty(edt3,&quot;text&quot;,argv[3],200);
    //strcpy(argv[3],&quot;data&quot;);
    if( (source=fopen( argv[1], &quot;rb&quot; )) == NULL )
    {
        printf(&quot;ERROR : I can't find source file   %s\n&quot;,argv[1]);

        sprintf(s,&quot;二进制文件[%s]不存在!&quot;,argv[1]);
        ShowMessage(s);
        return;
    }
    strcpy(Dummy,argv[2]);

    if( (dest=fopen( Dummy, &quot;wb+&quot; )) == NULL )
    {
        sprintf(s,&quot;目标文件[%s]无法创建!&quot;,argv[1]);
        ShowMessage(s);
        printf(&quot;ERROR : I can't open destination file   %s\n&quot;,Dummy);
        return;
    }

    strcpy(Dummy,argv[3]);
    Upper_chars(Dummy);  /* lower to upper chars */
    strcat(Dummy,&quot;_LEN&quot;);  /* add the suffix _LEN to the struct name */
    //fprintf( dest, &quot;\r\n//--------通讯调试工具1.255---------\r\n\r\n&quot;, Dummy, filesize(source) );
    //fprintf( dest, &quot;#define %s %d\r\n&quot;, Dummy, filesize(source) );
    //fprintf( dest, &quot;static unsigned char %s[]=\r\n{\r\n&quot;, argv[3] );

    if( ferror( dest ) )
    {
        printf( &quot;ERROR writing on target file:  %s\n&quot;,argv[2] );
        return;
    }

    do
    {
        //fprintf(dest,&quot;&quot;);
        for ( c=0; ((c &lt;= LINE) &amp;&amp; (! feof( source ) )) ; c++)
        {
            fread(buffer,1,1,source);

            if (!feof( source ) &amp;&amp; c != 0)
            {
                //fprintf(dest,&quot;&quot;);
                //printf(&quot;,&quot;);
            }

            if (! feof( source ) )
            {
                fprintf(dest,&quot; %02x&quot;,*buffer);
                //printf(&quot;0x%02x&quot;,*buffer);
            }
        }
        fprintf(dest,&quot;\r\n&quot;);
    }
    while( ! feof( source ) );

    // fprintf(dest,&quot;};\r\n\r\n&quot;);

    fclose(dest);
    fclose(source);
    printf(&quot;OK!&quot;);
    ShowMessage(&quot;转换完成!        &quot;);
}





"/>
    <Command cmdname="HexDump" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define BUF_LEN 1
#define LINE 15
int p;

int edt1,edt2,edt3;
void Trans();
long int filesize( FILE *fp )
{
    long int save_pos, size_of_file;
    save_pos = ftell( fp );
    fseek( fp, 0L, SEEK_END );
    size_of_file = ftell( fp );
    fseek( fp, save_pos, SEEK_SET );
    return( size_of_file );
}

void Upper_chars(char *buffer)
{
    unsigned int c;
    for (c=0; c &lt;= strlen(buffer)-1; c++)
        *(buffer+c)=toupper( *(buffer+c) );
}
void OpenFileClick(void *sender)
{
    char s[200];
    GetFileName(s,200,&quot;*.*&quot;);
    if(strlen(s)&gt;0)
        SetProperty(edt1,&quot;text&quot;,s);
}
void OpenFileClick1(void *sender)
{
    char s[200];
    GetFileName(s,200,&quot;*.txt&quot;);
    if(strlen(s)&gt;0)
        SetProperty(edt2,&quot;text&quot;,s);
}
void CloseClick(void *Sender)
{
    ClearOutputWin();   //清除输出窗口内容
    HideVclWin();
    CloseVclWin();
    CloseForm(p);
}

void ViewC()
{
    char s[200],s1[200];
    GetProperty(edt2,&quot;text&quot;,s,200);
    sprintf(s1,&quot;notepad.exe %s&quot;,s);
    WinExec(s1);
}

void CreateGui()
{
    CloseCodeWin();
    ClearVclControls();

    int GuiMode=2;
    if((GuiMode==0)||(GuiMode==1))
        p=GetGuiWin(GuiMode);
    else
        p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;HexDump工具&quot;,&quot;Width&quot;,570,&quot;height&quot;,150,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;, &quot;visible&quot;,1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]

    int pnl =p;
    int txt2= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;二进制文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,40-20,&quot;width&quot;,90,NULL);
    edt1= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\boot.ini&quot;,&quot;left&quot;,105,&quot;top&quot;,38-20,&quot;width&quot;,345,NULL);
    int txt3= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;转换到文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,68-20,&quot;width&quot;,90,NULL);
    edt2= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\tmp.txt&quot;,&quot;left&quot;,105,&quot;top&quot;,65-20,&quot;width&quot;,345,NULL);

    int btn1= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,36-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick,NULL);
    int btn2= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,63-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick1,NULL);
    int btn3= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;转    换&quot; ,&quot;left&quot;,75,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,Trans,NULL);
    int btn4= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;查看转换文件&quot;,&quot;left&quot;,215,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,ViewC,NULL);
    int btn5= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;退    出&quot; ,&quot;left&quot;,375,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,CloseClick,NULL);
}
void main()
{
    CreateGui();
}
void Trans()
{
    char  argv[4][255];
    char s[100];
    FILE *source,*dest;
    unsigned char buffer[BUF_LEN], Dummy[20];
    int c,i;
    char fname[255];
    char ext[255];
    int count=0;
    unsigned char buf[20];

    GetProperty(edt1,&quot;text&quot;,argv[1],200);
    GetProperty(edt2,&quot;text&quot;,argv[2],200);

    if( (source=fopen( argv[1], &quot;rb&quot; )) == NULL )
    {
        sprintf(s,&quot;二进制文件[%s]不存在!&quot;,argv[1]);
        ShowMessage(s);
        return;
    }
    strcpy(Dummy,argv[2]);
    if( (dest=fopen( Dummy, &quot;wb+&quot; )) == NULL )
    {
        sprintf(s,&quot;目标文件[%s]无法创建!&quot;,argv[1]);
        ShowMessage(s);
        return;
    }
    _splitpath(argv[1], NULL,NULL,fname,ext);
    fprintf( dest, &quot;CommBox V1.26\r\nHEXDUMP 文件名称：%s%s,文件大小：%d Bytes\r\n&quot;, fname,ext, filesize(source) );
    fprintf( dest, &quot;------------------------------------------------------------------------------\r\n&quot;);

    fprintf( dest, &quot;地址(HEX) 00 01 02 03  04 05 06 07  08 09 0A 0B  0C 0D 0E 0F  0123456789ABCDEF\r\n&quot;);
    fprintf( dest, &quot;==============================================================================\r\n&quot;);
    if( ferror( dest ) )
    {
        printf( &quot;ERROR writing on target file:  %s\n&quot;,argv[2] );
        return;
    }

    do
    {
        fprintf( dest, &quot;%08X&quot;,count);
        count+=LINE;
        for ( c=0; ((c &lt;= LINE) &amp;&amp; (! feof( source ) )) ; c++)
        {
            fread(buffer,1,1,source);
            buf[c]=buffer[0];

            if (! feof( source ) )
            {
                if(c%4==0)fprintf(dest,&quot; &quot;);
                fprintf(dest,&quot; %02x&quot;,*buffer);
            }
            else
                break;
        }

        if ( feof( source ) )
            for(i=c; i&lt;=LINE; i++)
            {
                if(i%4==0)fprintf(dest,&quot; &quot;);
                fprintf(dest,&quot;   &quot;);
            }
        fprintf(dest,&quot;  &quot;);
        char xshz=1;

        i=0;
        while(i&lt;c)
        {
            if(!xshz)
            {
                if((buf[i]&gt;0x20)&amp;&amp;(buf[i]&lt;0x80))
                    fprintf( dest, &quot;%c&quot;,buf[i]);
                else
                    fprintf( dest, &quot;.&quot;);
            }
            else
            {
                unsigned char hz=0;
                if(i&lt;c-1)
                    if((buf[i]&gt;=0xa1)&amp;&amp;(buf[i]&lt;=0xfe))
                        if((buf[i+1]&gt;=0xa1)&amp;&amp;(buf[i+1]&lt;=0xfe))
                            hz=1;
                if(hz)
                {
                    char tmp[3];
                    tmp[0]=buf[i];
                    tmp[1]=buf[i+1];
                    tmp[2]=0;
                    fprintf( dest, &quot;%s&quot;,tmp);
                    i++;
                }
                else
                {
                    if((buf[i]&gt;0x20)&amp;&amp;(buf[i]&lt;0x80))
                        fprintf( dest, &quot;%c&quot;,buf[i]);
                    else
                        fprintf( dest, &quot;.&quot;);
                }
            }
            i++;
        }

        fprintf(dest,&quot;\r\n&quot;);
    }
    while( ! feof( source ) );

    fclose(dest);
    fclose(source);
    printf(&quot;OK!&quot;);
    ShowMessage(&quot;转换完成!        &quot;);
}




"/>
    <Command cmdname="二进制转C(bin2c)" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define BUF_LEN 1
#define LINE     15
int p;

int edt1,edt2,edt3;
void Trans();
long int filesize( FILE *fp )
{
    long int save_pos, size_of_file;

    save_pos = ftell( fp );
    fseek( fp, 0L, SEEK_END );
    size_of_file = ftell( fp );
    fseek( fp, save_pos, SEEK_SET );
    return( size_of_file );
}

void Upper_chars(char *buffer)
{
    unsigned int c;

    for (c=0; c &lt;= strlen(buffer)-1; c++) *(buffer+c)=toupper( *(buffer+c) );
}
void OpenFileClick(void *sender)
{
    char s[200];
    GetFileName(s,200,&quot;*.*&quot;);
    if(strlen(s)&gt;0)
    {
        SetProperty(edt1,&quot;text&quot;,s);
    }
}
void OpenFileClick1(void *sender)
{
    char s[200];
    GetFileName(s,200,&quot;*.*&quot;);
    if(strlen(s)&gt;0)
    {
        SetProperty(edt2,&quot;text&quot;,s);
    }
}
void CloseClick(void *Sender)
{

    ClearOutputWin();   //清除输出窗口内容
    HideVclWin();

    CloseVclWin();
    CloseForm(p);
}

void ViewC()
{
    char s[200],s1[200];
    GetProperty(edt2,&quot;text&quot;,s,200);
    sprintf(s1,&quot;notepad.exe %s&quot;,s);
    WinExec(s1);

}
void CreateGui()
{
    //ShowVclWin(170);
    //ShowOutputWin(310);
    CloseCodeWin();
    ClearVclControls();
    //HideLeftTools();
    //HideRightTools();

    int GuiMode=2;
    if((GuiMode==0)||(GuiMode==1))
        p=GetGuiWin(GuiMode);
    else
        p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;Bin2C工具&quot;,&quot;Width&quot;,560,&quot;height&quot;,170,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;, &quot;visible&quot;,1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]

    int pnl = p;
    int txt2= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;二进制文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,40-30,&quot;width&quot;,60,NULL);
    edt1= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\boot.ini&quot;,&quot;left&quot;,75,&quot;top&quot;,38-30,&quot;width&quot;,385,NULL);
    int txt3= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;C文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,68-30,&quot;width&quot;,60,NULL);
    edt2= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\tmp.c&quot;,&quot;left&quot;,75,&quot;top&quot;,65-30,&quot;width&quot;,385,NULL);

    int txt4= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;结构名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,96-30,&quot;width&quot;,60,NULL);
    edt3= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;data&quot;,&quot;left&quot;,75,&quot;top&quot;,92-30,&quot;width&quot;,385,NULL);

    int btn1= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,36-30,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick,NULL);
    int btn2= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,63-30,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick1,NULL);
    int btn3= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;转    换&quot; ,&quot;left&quot;,75,&quot;top&quot;,93+28-25,&quot;width&quot;,120,&quot;onclick&quot;,Trans,NULL);
    int btn4= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;查看C文件&quot;,&quot;left&quot;,215,&quot;top&quot;,93+28-25,&quot;width&quot;,120,&quot;onclick&quot;,ViewC,NULL);
    int btn5= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;退    出&quot; ,&quot;left&quot;,375,&quot;top&quot;,93+28-25,&quot;width&quot;,120,&quot;onclick&quot;,CloseClick,NULL);
}
void main()
{
    printf(&quot;BIN2C V1.0 by baohongjie\n&quot;);
    CreateGui();
}
void Trans()
{
    char  argv[4][255];
    char s[100];
    FILE *source,*dest;
    unsigned char buffer[BUF_LEN], Dummy[20];
    int c;
    GetProperty(edt1,&quot;text&quot;,argv[1],200);
    GetProperty(edt2,&quot;text&quot;,argv[2],200);
    GetProperty(edt3,&quot;text&quot;,argv[3],200);
    if( (source=fopen( argv[1], &quot;rb&quot; )) == NULL )
    {
        sprintf(s,&quot;二进制文件[%s]不存在!&quot;,argv[1]);
        ShowMessage(s);
        return;
    }
    strcpy(Dummy,argv[2]);

    if( (dest=fopen( Dummy, &quot;wb+&quot; )) == NULL )
    {
        sprintf(s,&quot;目标文件[%s]无法创建!&quot;,argv[1]);
        ShowMessage(s);
        return;
    }

    strcpy(Dummy,argv[3]);
    Upper_chars(Dummy);  /* lower to upper chars */
    strcat(Dummy,&quot;_LEN&quot;);  /* add the suffix _LEN to the struct name */
    fprintf( dest, &quot;\r\n//CommBox V1.256\r\n\r\n&quot;, Dummy, filesize(source) );
    fprintf( dest, &quot;#define %s %d\r\n&quot;, Dummy, filesize(source) );
    fprintf( dest, &quot;static unsigned char %s[]=\r\n{\r\n&quot;, argv[3] );

    if( ferror( dest ) )
    {
        printf( &quot;ERROR writing on target file:  %s\n&quot;,argv[2] );
        return;
    }

    do
    {
        fprintf(dest,&quot;    &quot;);
        for ( c=0; ((c &lt;= LINE) &amp;&amp; (! feof( source ) )) ; c++)
        {
            fread(buffer,1,1,source);

            if (!feof( source ) &amp;&amp; c != 0)
            {
                fprintf(dest,&quot;,&quot;);
            }

            if (! feof( source ) )
            {
                fprintf(dest,&quot;0x%02x&quot;,*buffer);
            }
        }
        fprintf(dest,&quot;,\r\n&quot;);
    }
    while( ! feof( source ) );

    fprintf(dest,&quot;};\r\n\r\n&quot;);

    fclose(dest);
    fclose(source);
    printf(&quot;OK!&quot;);
    ShowMessage(&quot;-------------转换完成!-----------------&quot;);
}





"/>
    <Command cmdname="对接收数据进行C格式化" cmdType="P" cmd="[P]void CFormat(unsigned char *buf,int count)//串口接收到数?
{
    int i;
    unsigned char sbuf[1024];

    unsigned char tmp[100];
    sbuf[0]=0;
    for(i=0; i&lt;count; i++)
    {
        if(i%16==15)
            sprintf(tmp,&quot;0x%02x,\r\n&quot;,buf[i]&amp;0xff);
        else
            sprintf(tmp,&quot;0x%02x,&quot;,buf[i]&amp;0xff);
        strcat(sbuf,tmp);
    }
    printf(sbuf);

}
void RecvSerialData(unsigned char *buf,int count) // 串口接收到数?
{
    CFormat(buf,count);
}


void main()
{
    ShowOutputWin(-1);
}"/>
    <Command cmdname="单片机Hex文件转Bin文件" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#define BUF_LEN 1
#define LINE 15
int p;
int edt1,edt2,edt3;
/* size in bytes */
#define MEMORY_SIZE 1024*1024
#define ADDRESS_MASK 0x000F0000

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

#define MAX_FILE_NAME_SIZE 255

/* The data records can contain 255 bytes: this means 512 characters. */
#define MAX_LINE_SIZE 1024

#define NO_ADDRESS_TYPE_SELECTED 0
#define LINEAR_ADDRESS 1
#define SEGMENTED_ADDRESS 2

typedef char filetype[MAX_FILE_NAME_SIZE];
typedef int boolean;
typedef unsigned char byte;

filetype    Filename;
FILE        *Filin,             /* input files */
            *Filout;            /* output files */

void *NoFailMalloc (size_t size);
int NoFailOpenInputFile (char *Flnm);
int NoFailOpenOutputFile (char *Flnm);

void *NoFailMalloc (size_t size)
{
    void *result;

    if ((result = malloc (size)) == NULL)
    {
        fprintf (stderr,&quot;Can't allocate memory.\n&quot;);
        exit(1);
    }
    return (result);
}


int NoFailOpenInputFile (char *Flnm)
{
    if ((Filin = fopen(Flnm,&quot;r&quot;)) == NULL)
    {
        printf (&quot;Input file %s cannot be opened. Enter new filename: &quot;,Flnm);
        return 0;
    }

    return 1;
}

/* Open the output file, with error checking */
int NoFailOpenOutputFile (char *Flnm)
{
    if ((Filout = fopen(Flnm,&quot;w&quot;)) == NULL)
    {
        fprintf(stderr,&quot;Output file %s cannot be opened. Enter new file name: &quot;, Flnm);
        return 0;
    }
    return 1;
}

int Trans()
{
    /* line inputted from file */
    char Line[MAX_LINE_SIZE];

    /* flag that a file was read */
    boolean Fileread;
    boolean Enable_Checksum_Error = FALSE;
    boolean Status_Checksum_Error = FALSE;

    /* cmd-line parameter # */
    char *c,*p;

    unsigned int Param;
    unsigned int i;

    /* Application specific */

    unsigned int     Nb_Bytes;
    unsigned int     First_Word, Address, Segment, Upper_Address;
    unsigned int     Lowest_Address, Highest_Address, Starting_Address;
    unsigned int     Phys_Addr, Type;
    unsigned int     temp;


    unsigned int    Seg_Lin_Select = NO_ADDRESS_TYPE_SELECTED;

    boolean Starting_Address_Setted = FALSE;

    int temp2;

    byte    Data_Str[MAX_LINE_SIZE];
    byte     Checksum;

    /* This will hold binary codes translated from hex file. */
    byte *Memory_Block;

    printf (&quot;hex2bin v1.0, commbox v1.260\n&quot;);
    Param = 1;
    GetProperty(edt1,&quot;text&quot;,Filename,200);

    /* Just a normal file name */
    if(NoFailOpenInputFile (Filename)==0)
    {
        ShowMessage(&quot;Hex文件打开错误！&quot;);
        return;
    }

    GetProperty(edt2,&quot;text&quot;,Filename,200);
    if(NoFailOpenOutputFile(Filename)==0)
    {
        ShowMessage(&quot;Bin文件打开错误！&quot;);
        return;
    }
    Fileread = TRUE;

    /* allocate a buffer */
    Memory_Block = (byte *) NoFailMalloc(MEMORY_SIZE);
    memset (Memory_Block,0xFF,MEMORY_SIZE);


    Segment = 0;
    Upper_Address = 0;
    Lowest_Address = MEMORY_SIZE - 1;
    Highest_Address = 0;

    /* Now read the file &amp; process the lines. */
    do /* repeat until EOF(Filin) */
    {
        /* Read a line from input file. */
        fgets(Line,MAX_LINE_SIZE,Filin);

        /* Remove carriage return/line feed at the end of line. */
        i = strlen(Line)-1;

        if (Line[i] == '\n') Line[i] = '\0';

        sscanf (Line, &quot;:%2x%4x%2x%s&quot;,&amp;Nb_Bytes,&amp;First_Word,&amp;Type,Data_Str);

        Checksum = Nb_Bytes + (First_Word &gt;&gt; 8) + (First_Word &amp; 0xFF) + Type;

        p = Data_Str;

        /* If we're reading the last record, ignore it. */
        switch (Type)
        {
            /* Data record */
        case 0:
            Address = First_Word;

            if (Seg_Lin_Select == SEGMENTED_ADDRESS)
                Phys_Addr = ((Segment &lt;&lt; 4) &amp; ADDRESS_MASK) + Address;
            else
                /* LINEAR_ADDRESS or NO_ADDRESS_TYPE_SELECTED
                Upper_Address = 0 as specified in the Intel spec. until an extended address
                record is read. */
                Phys_Addr = ((Upper_Address &lt;&lt; 16) &amp; ADDRESS_MASK) + Address;

            /* Check that the physical address stays in the buffer's range. */
            if ((Phys_Addr + Nb_Bytes) &lt;= MEMORY_SIZE -1)
            {
                /* Set the lowest address as base pointer. */
                if (Phys_Addr &lt; Lowest_Address)
                    Lowest_Address = Phys_Addr;

                /* Same for the top address. */
                temp = Phys_Addr + Nb_Bytes -1;

                if (temp &gt; Highest_Address)
                    Highest_Address = temp;

                /* Read the Data bytes. */
                /* Bytes are written in the Memory block even if checksum is wrong. */
                for (i= Nb_Bytes; i &gt; 0; i--)
                {
                    sscanf (p, &quot;%2x&quot;,&amp;temp2);
                    p += 2;
                    Memory_Block[Phys_Addr++] = temp2;
                    Checksum = (Checksum + temp2) &amp; 0xFF;
                };

                /* Read the Checksum value. */
                sscanf (p, &quot;%2x&quot;,&amp;temp2);

                /* Verify Checksum value. */
                Checksum = (Checksum + temp2) &amp; 0xFF;

                if ((Checksum != 0) &amp;&amp; Enable_Checksum_Error)
                {
                    Status_Checksum_Error = TRUE;
                }
            }
            else
            {
                if (Seg_Lin_Select == SEGMENTED_ADDRESS)
                    fprintf(stderr,&quot;Data record skipped at %4X:%4X\n&quot;,Segment,Address);
                else
                    fprintf(stderr,&quot;Data record skipped at %8X\n&quot;,Phys_Addr);
            }

            break;

            /* End of file record */
        case 1:
            /* Simply ignore checksum errors in this line. */
            break;

            /* Extended segment address record */
        case 2:
            /* First_Word contains the offset. It's supposed to be 0000 so
            we ignore it. */

            /* First extended segment address record ? */
            if (Seg_Lin_Select == NO_ADDRESS_TYPE_SELECTED)
                Seg_Lin_Select = SEGMENTED_ADDRESS;

            /* Then ignore subsequent extended linear address records */
            if (Seg_Lin_Select == SEGMENTED_ADDRESS)
            {
                sscanf (p, &quot;%4x%2x&quot;,&amp;Segment,&amp;temp2);

                /* Update the current address. */
                Phys_Addr = (Segment &lt;&lt; 4) &amp; ADDRESS_MASK;

                /* Verify Checksum value. */
                Checksum = (Checksum + (Segment &gt;&gt; 8) + (Segment &amp; 0xFF) + temp2) &amp; 0xFF;

                if ((Checksum != 0) &amp;&amp; Enable_Checksum_Error)
                    Status_Checksum_Error = TRUE;
            }
            break;

            /* Start segment address record */
        case 3:
            /* Nothing to be done since it's for specifying the starting address for
            execution of the binary code */
            break;

            /* Extended linear address record */
        case 4:
            /* First_Word contains the offset. It's supposed to be 0000 so
            we ignore it. */

            /* First extended linear address record ? */
            if (Seg_Lin_Select == NO_ADDRESS_TYPE_SELECTED)
                Seg_Lin_Select = LINEAR_ADDRESS;

            /* Then ignore subsequent extended segment address records */
            if (Seg_Lin_Select == LINEAR_ADDRESS)
            {
                sscanf (p, &quot;%4x%2x&quot;,&amp;Upper_Address,&amp;temp2);

                /* Update the current address. */
                Phys_Addr = (Upper_Address &lt;&lt; 16) &amp; ADDRESS_MASK;

                /* Verify Checksum value. */
                Checksum = (Checksum + (Upper_Address &gt;&gt; 8) + (Upper_Address &amp; 0xFF) + temp2)
                           &amp; 0xFF;

                if ((Checksum != 0) &amp;&amp; Enable_Checksum_Error)
                    Status_Checksum_Error = TRUE;
            }
            break;

            /* Start linear address record */
        case 5:
            /* Nothing to be done since it's for specifying the starting address for
            execution of the binary code */
            break;
        default:
        }
    }
    while (!feof (Filin));
    /*-----------------------------------------------------------------------------*/

    printf(&quot;Lowest address = %08X\n&quot;,Lowest_Address);
    printf(&quot;Highest address = %08X\n&quot;,Highest_Address);



    if(Starting_Address_Setted)
    {
        Lowest_Address = Starting_Address;
    }

    /* write binary file */
    fwrite (&amp;Memory_Block[Lowest_Address],
            1,
            Highest_Address - Lowest_Address +1,
            Filout);

    free (Memory_Block);
    fclose (Filin);
    if (Status_Checksum_Error &amp; Enable_Checksum_Error)
    {
        printf(&quot;Checksum error detected.\n&quot;);
        return 1;
    }
    fclose (Filout);
    ShowDispMode(2);
    HexEditorLoadFromFile(Filename);
    ShowMessage(&quot;转换完成!&quot;);
    return 0;
}

long int filesize( FILE *fp )
{
    long int save_pos, size_of_file;
    save_pos = ftell( fp );
    fseek( fp, 0L, SEEK_END );
    size_of_file = ftell( fp );
    fseek( fp, save_pos, SEEK_SET );
    return( size_of_file );
}

void Upper_chars(char *buffer)
{
    unsigned int c;
    for (c=0; c &lt;= strlen(buffer)-1; c++)
        *(buffer+c)=toupper( *(buffer+c) );
}
void OpenFileClick(void *sender)
{
    char s[200];
    GetFileName(s,200,&quot;*.hex|*.hex&quot;);
    if(strlen(s)&gt;0)
        SetProperty(edt1,&quot;text&quot;,s);
}
void OpenFileClick1(void *sender)
{
    char s[200];
    GetFileName(s,200,&quot;*.bin|*.bin&quot;);
    if(strlen(s)&gt;0)
        SetProperty(edt2,&quot;text&quot;,s);
}
void CloseClick(void *Sender)
{
    ClearOutputWin();   //清除输出窗口内容
    HideVclWin();
    CloseVclWin();
    CloseForm(p);
}

void ViewC()
{
    char s[200],s1[200];
    GetProperty(edt2,&quot;text&quot;,s,200);
    sprintf(s1,&quot;notepad.exe %s&quot;,s);
    WinExec(s1);
}

void CreateGui()
{
    CloseCodeWin();
    ClearVclControls();

    int GuiMode=2;
    if((GuiMode==0)||(GuiMode==1))
        p=GetGuiWin(GuiMode);
    else
        p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;Hex2Bin工具&quot;,&quot;Width&quot;,570,&quot;height&quot;,150,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;, &quot;visible&quot;,1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]

    int pnl =p;
    int txt2= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;Hex文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,40-20,&quot;width&quot;,90,NULL);
    edt1= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\1.hex&quot;,&quot;left&quot;,105,&quot;top&quot;,38-20,&quot;width&quot;,345,NULL);
    int txt3= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;转换到文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,68-20,&quot;width&quot;,90,NULL);
    edt2= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;c:\\tmp.bin&quot;,&quot;left&quot;,105,&quot;top&quot;,65-20,&quot;width&quot;,345,NULL);

    int btn1= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,36-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick,NULL);
    int btn2= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,63-20,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick1,NULL);
    int btn3= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;转    换&quot; ,&quot;left&quot;,75,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,Trans,NULL);
    int btn4= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;查看转换文件&quot;,&quot;left&quot;,215,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,ViewC,NULL);
    int btn5= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;退    出&quot; ,&quot;left&quot;,375,&quot;top&quot;,93+28-40,&quot;width&quot;,120,&quot;onclick&quot;,CloseClick,NULL);
}
void main()
{
    CreateGui();
}






"/>
    <Command cmdname="默认显示" cmdType="P" cmd="[P]void main()
{
   //ClearOutput();   //清除输出窗口内容  
   //ClearCommWin();
   SetLayoutMode(0);
   OpenInputWin();
   HideTerminalWin();
   ClearVclControls();
   HideVclWin();
   HideLeftTools();
   HideRightTools();
}"/>
    <Command cmdname="万年历" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
static unsigned char const sky[][3]=  {&quot;甲&quot;,&quot;乙&quot;,&quot;丙&quot;,&quot;丁&quot;,&quot;戊&quot;,&quot;己&quot;,&quot;庚&quot;,&quot;辛&quot;,&quot;壬&quot;,&quot;癸&quot;,};
static unsigned char const earth[][3]= {&quot;子&quot;,&quot;丑&quot;,&quot;寅&quot;,&quot;卯&quot;,&quot;辰&quot;,&quot;巳&quot;,&quot;午&quot;,&quot;未&quot;,&quot;申&quot;,&quot;酉&quot;,&quot;戌&quot;,&quot;亥&quot;,};
static unsigned char const monthcode[][3]= {&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;,&quot;七&quot;,&quot;八&quot;,&quot;九&quot;,&quot;十&quot;,&quot;冬&quot;,&quot;腊&quot;,};
static unsigned char const nongliday[][3]= {&quot;初&quot;,&quot;十&quot;,&quot;廿&quot;,&quot;三&quot;,};
static unsigned char const weekhz[][3]= {&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;,&quot;日&quot;};
static unsigned char const MonthDayMax[]= {31,28,31,30,31,30,31,31,30,31,30,31,};

/*********************************************************************************************************
** 函数名称:GetChinaCalendar
** 功能描述:公农历转换(只允许1901-2099年)
** 输　入:  year        公历年
**          month       公历月
**          day         公历日
**          p           储存农历日期地址
** 输　出:  1           成功
**          0           失败
*/

extern unsigned char GetChinaCalendar(
    unsigned int  year,
    unsigned char month,
    unsigned char day,
    unsigned char *p);
/*********************************************************************************************************
** 函数名称:GetWeek
** 功能描述:输入公历日期得到星期(只允许1901-2099年)
** 输　入:  year        公历年
**          month       公历月
**          day            公历日
**          p           储存星期地址
** 输　出:  无
*/
extern void GetWeek(
    unsigned int year,
    unsigned char month,
    unsigned char day,
    unsigned char *p);
/*********************************************************************************************************
** 函数名称:GetChinaCalendarStr
** 功能描述:输入公历日期得到农历字符串
**          如:GetChinaCalendarStr(2007,02,06,str) 返回str=&quot;丙戌年腊月十九&quot;
** 输　入:  year        公历年
**          month       公历月
**          day         公历日
**          str         储存农历日期字符串地址   15Byte
** 输　出:  无
*/
extern void GetChinaCalendarStr(
    unsigned int  year,
    unsigned char month,
    unsigned char day,
    char *str);

/*********************************************************************************************************
** 函数名称:GetJieQi
** 功能描述:输入公历日期得到本月24节气日期 day&lt;15返回上半月节气,反之返回下半月
**          如:GetJieQiStr(2007,02,08,str) 返回str[0]=4
** 输　入:  year        公历年
**          month       公历月
**          day         公历日
**          str         储存对应本月节气日期地址   1Byte
** 输　出:  1           成功
**          0           失败
*/
extern unsigned char GetJieQi(
    unsigned  int year,
    unsigned char month,
    unsigned char day,
    unsigned char *JQdate);
/*********************************************************************************************************
** 函数名称:GetJieQiStr
** 功能描述:输入公历日期得到24节气字符串
**          如:GetJieQiStr(2007,02,08,str) 返回str=&quot;离雨水还有11天&quot;
** 输　入:  year        公历年
**          month       公历月
**          day         公历日
**          str         储存24节气字符串地址   15Byte
** 输　出:  1           成功
**          0           失败
*/
extern unsigned char GetJieQiStr(
    unsigned int year,
    unsigned char month,
    unsigned char day,
    char *str);                
HANDLE dc;
int img,pfm;
int mx,my;
int GuiMode=2;//GUI窗口显示模式          
int imgLeft=10;
int imgTop=40;
int curYear,curMonth;
void OnClose()
{
    if((GuiMode==0)||(GuiMode==1))
    {
        ClearVclControls();
        HideVclWin(200);
    }
    else
    {
        CloseForm(pfm);
    }
}
void DrawMonth(int year,int month)
{
    int dc;
    int i,j,count;
    char s[20];
    char str[15];
    unsigned char NLyear[4];
    int wk;
    HPEN pen;
    HBRUSH brush; HFONT	fontChr,fontHz;
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);   
        										// Windows Font ID
    
    fontChr = CreateFont(	-22,							// Height Of Font
                        0,								// Width Of Font
                        0,								// Angle Of Escapement
                        0,								// Orientation Angle
                        FW_BOLD,						// Font Weight
                        TRUE,							// Italic
                        FALSE,							// Underline
                        FALSE,							// Strikeout
                        ANSI_CHARSET,					// Character Set Identifier
                        OUT_TT_PRECIS,					// Output Precision
                        CLIP_DEFAULT_PRECIS,			// Clipping Precision
                        ANTIALIASED_QUALITY,			// Output Quality
                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch

                        //&quot;Courier New&quot;);					// Font Name
                        &quot;Bodoni MT Black&quot;);
    fontHz = CreateFont(	-15,							// Height Of Font
                        0,								// Width Of Font
                        0,								// Angle Of Escapement
                        0,								// Orientation Angle
                        FW_BOLD,						// Font Weight
                        FALSE,							// Italic
                        FALSE,							// Underline
                        FALSE,							// Strikeout
                        ANSI_CHARSET,					// Character Set Identifier
                        OUT_TT_PRECIS,					// Output Precision
                        CLIP_DEFAULT_PRECIS,			// Clipping Precision
                        ANTIALIASED_QUALITY,			// Output Quality
                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch

                        //&quot;Courier New&quot;);					// Font Name
                        &quot;Bodoni MT Black&quot;);                        
                        
                        SelectObject(dc,fontHz);
                         
    RECT rect= {0,0,640,780};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0xffffff);
    SelectObject(dc,brush);
    FillRect(dc,&amp;rect,brush);
    DeleteObject(brush);

    for(i=0; i&lt;7; i++)
    {
        sprintf(s,&quot;星期%s&quot;,weekhz[i]);
        TextOutA(dc,12+i*70,10,s,strlen(s));
    }
    GetWeek(year,month,1,&amp;wk);
    wk=wk&amp;0xff;
    if(wk==0)wk=7;

    pen=CreatePen(PS_SOLID,1, 0x000000);
    SelectObject(dc,pen);
    DeleteObject(pen);
    SetTextColor(dc,0x000000);
    count=MonthDayMax[month-1];
    if(month==2)
        if((year%4==0)&amp;&amp;((year%100!=0)||(year%400==0)))
            count++;
    for(i=0; i&lt;count; i++)
    {
        SetTextColor(dc,0x000000);
        SetBkColor(dc, 0xffffff);
        sprintf(s,&quot; %d &quot;,i+1);
        SelectObject(dc,fontChr);
        if(i&lt;10)
        TextOutA(dc,22 +((wk+i-1)%7)*70,34+70*((wk+i-1)/7),s,strlen(s));
        else
        TextOutA(dc,16+((wk+i-1)%7)*70,34+70*((wk+i-1)/7),s,strlen(s));
        GetChinaCalendarStr(year,month,i+1,str);     //str   ={&quot;丙戌年腊月廿一&quot;}
        GetChinaCalendar   (year,month,i+1,NLyear);  //NLyear={20,06,12,21}
        SelectObject(dc,fontHz);
        if(NLyear[3]==1)
        {
            DeleteObject(brush);
            brush=CreateSolidBrush(0xafafaf);
            SelectObject(dc,brush);
            SetTextColor(dc,0x00ffff);
            SetBkColor(dc,0xff0000 );
            TextOutA(dc,20+((wk+i-1)%7)*70,60+70*((wk+i-1)/7),str+6,4);
        }
        else
        {
            DeleteObject(brush);
            brush=CreateSolidBrush(0xafafaf);
            SelectObject(dc,brush);
            SetTextColor(dc,0x000000);
            SetBkColor(dc, 0xffffff);
            TextOutA(dc,20+((wk+i-1)%7)*70,60+70*((wk+i-1)/7),str+10,strlen(str)-10);
        }

        GetJieQiStr(year,month,i+1,str);
        if(str[4]==0)
        {
            SetTextColor(dc,0x0000ff);
            SetBkColor(dc,0x00ffff );
            TextOutA(dc,20+((wk+i-1)%7)*70,80+70*((wk+i-1)/7),str ,strlen(str) );
        }
        //printf(&quot;day:%d %s&quot;,i+1,str);
    }            
    MoveToEx(dc,0, 0,0);
    LineTo(dc,600, 0);    
    for(i=0; i&lt;10; i++)
    {
        MoveToEx(dc,0,-40+i*70,0);
        LineTo(dc,600,-40+i*70);
    }
    for(i=0; i&lt;10; i++)
    {
        MoveToEx(dc, i*70,0,0);
        LineTo(dc, i*70,600);
    }

    sprintf(s,&quot;%d年%d月&quot;,curYear,curMonth);
    SetProperty(pfm,&quot;caption&quot;,s);
    printf(&quot;week:%d&quot;,wk );
    Invalidate(img);
    DeleteObject(fontChr);
    DeleteObject(fontHz);    
}

void OnLastMonth()
{
    if(curMonth==1)
    {
        curMonth=12;
        curYear--;
    }
    else  
        curMonth--;    
    DrawMonth(curYear,curMonth);  
}
void OnNextMonth()
{

    if(curMonth==12)
    {
        curMonth=1;
        curYear++;
    }
    else   
        curMonth++;   
    DrawMonth(curYear,curMonth);
}
void OnLastYear()
{
    curYear--;
    DrawMonth(curYear,curMonth);
}

void OnNextYear()
{
    curYear++;
    DrawMonth(curYear,curMonth);  
}
void main(void)
{
    unsigned char week;
    unsigned char NLyear[4];
    unsigned char JQdate;
    char str[15];
    int i,j;
    int mi,mi1;
    SYSTEMTIME st;
    GetLocalTime(&amp;st);  
    //HideLeftTools();
    ClearVclControls();
    if((GuiMode==0)||(GuiMode==1))
    {
        pfm=GetGuiWin(GuiMode);
    }
    else
        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;分站模拟&quot;,&quot;Width&quot;,520,&quot;height&quot;,480+50,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    //CreateComponentEx(pfm,&quot;timer&quot;,&quot;interval&quot;,100,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    CreateComponentEx(pfm,&quot;Button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,400,&quot;top&quot;,5,&quot;width&quot;,100,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(pfm,&quot;Button&quot;,&quot;caption&quot;,&quot;上月&quot;,&quot;left&quot;,20,&quot;top&quot;,5,&quot;width&quot;,70,&quot;height&quot;,20,&quot;OnClick&quot;,OnLastMonth,0);
    CreateComponentEx(pfm,&quot;Button&quot;,&quot;caption&quot;,&quot;下月&quot;,&quot;left&quot;,100,&quot;top&quot;,5,&quot;width&quot;,70,&quot;height&quot;,20,&quot;OnClick&quot;,OnNextMonth,0);
    CreateComponentEx(pfm,&quot;Button&quot;,&quot;caption&quot;,&quot;上年&quot;,&quot;left&quot;,220,&quot;top&quot;,5,&quot;width&quot;,70,&quot;height&quot;,20,&quot;OnClick&quot;,OnLastYear,0);
    CreateComponentEx(pfm,&quot;Button&quot;,&quot;caption&quot;,&quot;下年&quot;,&quot;left&quot;,300,&quot;top&quot;,5,&quot;width&quot;,70,&quot;height&quot;,20,&quot;OnClick&quot;,OnNextYear,0);

    img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,imgLeft,&quot;top&quot;,imgTop,&quot;width&quot;,491,&quot;height&quot;,381+70 ,0);  
    SetProperty(pfm,&quot;visible&quot;,1);
    //SetProperty(pfm,&quot;caption&quot;,&quot;20120531&quot;);    
    curYear=st.wYear;
    curMonth=st.wMonth;
    DrawMonth(curYear,curMonth);
}

static unsigned char const year_code[]=
{
    0x04,0xAe,0x53, //1901 0
    0x0A,0x57,0x48, //1902 3
    0x55,0x26,0xBd, //1903 6
    0x0d,0x26,0x50, //1904 9
    0x0d,0x95,0x44, //1905 12
    0x46,0xAA,0xB9, //1906 15
    0x05,0x6A,0x4d, //1907 18
    0x09,0xAd,0x42, //1908 21
    0x24,0xAe,0xB6, //1909
    0x04,0xAe,0x4A, //1910
    0x6A,0x4d,0xBe, //1911
    0x0A,0x4d,0x52, //1912
    0x0d,0x25,0x46, //1913
    0x5d,0x52,0xBA, //1914
    0x0B,0x54,0x4e, //1915
    0x0d,0x6A,0x43, //1916
    0x29,0x6d,0x37, //1917
    0x09,0x5B,0x4B, //1918
    0x74,0x9B,0xC1, //1919
    0x04,0x97,0x54, //1920
    0x0A,0x4B,0x48, //1921
    0x5B,0x25,0xBC, //1922
    0x06,0xA5,0x50, //1923
    0x06,0xd4,0x45, //1924
    0x4A,0xdA,0xB8, //1925
    0x02,0xB6,0x4d, //1926
    0x09,0x57,0x42, //1927
    0x24,0x97,0xB7, //1928
    0x04,0x97,0x4A, //1929
    0x66,0x4B,0x3e, //1930
    0x0d,0x4A,0x51, //1931
    0x0e,0xA5,0x46, //1932
    0x56,0xd4,0xBA, //1933
    0x05,0xAd,0x4e, //1934
    0x02,0xB6,0x44, //1935
    0x39,0x37,0x38, //1936
    0x09,0x2e,0x4B, //1937
    0x7C,0x96,0xBf, //1938
    0x0C,0x95,0x53, //1939
    0x0d,0x4A,0x48, //1940
    0x6d,0xA5,0x3B, //1941
    0x0B,0x55,0x4f, //1942
    0x05,0x6A,0x45, //1943
    0x4A,0xAd,0xB9, //1944
    0x02,0x5d,0x4d, //1945
    0x09,0x2d,0x42, //1946
    0x2C,0x95,0xB6, //1947
    0x0A,0x95,0x4A, //1948
    0x7B,0x4A,0xBd, //1949
    0x06,0xCA,0x51, //1950
    0x0B,0x55,0x46, //1951
    0x55,0x5A,0xBB, //1952
    0x04,0xdA,0x4e, //1953
    0x0A,0x5B,0x43, //1954
    0x35,0x2B,0xB8, //1955
    0x05,0x2B,0x4C, //1956
    0x8A,0x95,0x3f, //1957
    0x0e,0x95,0x52, //1958
    0x06,0xAA,0x48, //1959
    0x7A,0xd5,0x3C, //1960
    0x0A,0xB5,0x4f, //1961
    0x04,0xB6,0x45, //1962
    0x4A,0x57,0x39, //1963
    0x0A,0x57,0x4d, //1964
    0x05,0x26,0x42, //1965
    0x3e,0x93,0x35, //1966
    0x0d,0x95,0x49, //1967
    0x75,0xAA,0xBe, //1968
    0x05,0x6A,0x51, //1969
    0x09,0x6d,0x46, //1970
    0x54,0xAe,0xBB, //1971
    0x04,0xAd,0x4f, //1972
    0x0A,0x4d,0x43, //1973
    0x4d,0x26,0xB7, //1974
    0x0d,0x25,0x4B, //1975
    0x8d,0x52,0xBf, //1976
    0x0B,0x54,0x52, //1977
    0x0B,0x6A,0x47, //1978
    0x69,0x6d,0x3C, //1979
    0x09,0x5B,0x50, //1980
    0x04,0x9B,0x45, //1981
    0x4A,0x4B,0xB9, //1982
    0x0A,0x4B,0x4d, //1983
    0xAB,0x25,0xC2, //1984
    0x06,0xA5,0x54, //1985
    0x06,0xd4,0x49, //1986
    0x6A,0xdA,0x3d, //1987
    0x0A,0xB6,0x51, //1988
    0x09,0x37,0x46, //1989
    0x54,0x97,0xBB, //1990
    0x04,0x97,0x4f, //1991
    0x06,0x4B,0x44, //1992
    0x36,0xA5,0x37, //1993
    0x0e,0xA5,0x4A, //1994
    0x86,0xB2,0xBf, //1995
    0x05,0xAC,0x53, //1996
    0x0A,0xB6,0x47, //1997
    0x59,0x36,0xBC, //1998
    0x09,0x2e,0x50, //1999 294
    0x0C,0x96,0x45, //2000 297
    0x4d,0x4A,0xB8, //2001
    0x0d,0x4A,0x4C, //2002
    0x0d,0xA5,0x41, //2003
    0x25,0xAA,0xB6, //2004
    0x05,0x6A,0x49, //2005
    0x7A,0xAd,0xBd, //2006
    0x02,0x5d,0x52, //2007
    0x09,0x2d,0x47, //2008
    0x5C,0x95,0xBA, //2009
    0x0A,0x95,0x4e, //2010
    0x0B,0x4A,0x43, //2011
    0x4B,0x55,0x37, //2012
    0x0A,0xd5,0x4A, //2013
    0x95,0x5A,0xBf, //2014
    0x04,0xBA,0x53, //2015
    0x0A,0x5B,0x48, //2016
    0x65,0x2B,0xBC, //2017
    0x05,0x2B,0x50, //2018
    0x0A,0x93,0x45, //2019
    0x47,0x4A,0xB9, //2020
    0x06,0xAA,0x4C, //2021
    0x0A,0xd5,0x41, //2022
    0x24,0xdA,0xB6, //2023
    0x04,0xB6,0x4A, //2024
    0x69,0x57,0x3d, //2025
    0x0A,0x4e,0x51, //2026
    0x0d,0x26,0x46, //2027
    0x5e,0x93,0x3A, //2028
    0x0d,0x53,0x4d, //2029
    0x05,0xAA,0x43, //2030
    0x36,0xB5,0x37, //2031
    0x09,0x6d,0x4B, //2032
    0xB4,0xAe,0xBf, //2033
    0x04,0xAd,0x53, //2034
    0x0A,0x4d,0x48, //2035
    0x6d,0x25,0xBC, //2036
    0x0d,0x25,0x4f, //2037
    0x0d,0x52,0x44, //2038
    0x5d,0xAA,0x38, //2039
    0x0B,0x5A,0x4C, //2040
    0x05,0x6d,0x41, //2041
    0x24,0xAd,0xB6, //2042
    0x04,0x9B,0x4A, //2043
    0x7A,0x4B,0xBe, //2044
    0x0A,0x4B,0x51, //2045
    0x0A,0xA5,0x46, //2046
    0x5B,0x52,0xBA, //2047
    0x06,0xd2,0x4e, //2048
    0x0A,0xdA,0x42, //2049
    0x35,0x5B,0x37, //2050
    0x09,0x37,0x4B, //2051
    0x84,0x97,0xC1, //2052
    0x04,0x97,0x53, //2053
    0x06,0x4B,0x48, //2054
    0x66,0xA5,0x3C, //2055
    0x0e,0xA5,0x4f, //2056
    0x06,0xB2,0x44, //2057
    0x4A,0xB6,0x38, //2058
    0x0A,0xAe,0x4C, //2059
    0x09,0x2e,0x42, //2060
    0x3C,0x97,0x35, //2061
    0x0C,0x96,0x49, //2062
    0x7d,0x4A,0xBd, //2063
    0x0d,0x4A,0x51, //2064
    0x0d,0xA5,0x45, //2065
    0x55,0xAA,0xBA, //2066
    0x05,0x6A,0x4e, //2067
    0x0A,0x6d,0x43, //2068
    0x45,0x2e,0xB7, //2069
    0x05,0x2d,0x4B, //2070
    0x8A,0x95,0xBf, //2071
    0x0A,0x95,0x53, //2072
    0x0B,0x4A,0x47, //2073
    0x6B,0x55,0x3B, //2074
    0x0A,0xd5,0x4f, //2075
    0x05,0x5A,0x45, //2076
    0x4A,0x5d,0x38, //2077
    0x0A,0x5B,0x4C, //2078
    0x05,0x2B,0x42, //2079
    0x3A,0x93,0xB6, //2080
    0x06,0x93,0x49, //2081
    0x77,0x29,0xBd, //2082
    0x06,0xAA,0x51, //2083
    0x0A,0xd5,0x46, //2084
    0x54,0xdA,0xBA, //2085
    0x04,0xB6,0x4e, //2086
    0x0A,0x57,0x43, //2087
    0x45,0x27,0x38, //2088
    0x0d,0x26,0x4A, //2089
    0x8e,0x93,0x3e, //2090
    0x0d,0x52,0x52, //2091
    0x0d,0xAA,0x47, //2092
    0x66,0xB5,0x3B, //2093
    0x05,0x6d,0x4f, //2094
    0x04,0xAe,0x45, //2095
    0x4A,0x4e,0xB9, //2096
    0x0A,0x4d,0x4C, //2097
    0x0d,0x15,0x41, //2098
    0x2d,0x92,0xB5, //2099
};

/*月份数据表*/
static unsigned char  const day_code1[9]= {0x0,0x1f,0x3b,0x5a,0x78,0x97,0xb5,0xd4,0xf3};
static unsigned short const day_code2[3]= {0x111,0x130,0x14e};
/****************************************************************************
* 子函数,用于读取数据表中农历月的大月或小月,如果该月为大返回1,为小返回0
****************************************************************************/
static unsigned char GetMoonDay(unsigned char month_p,unsigned short table_addr)
{
    switch (month_p)
    {
    case 1:
        if((year_code[table_addr]&amp;0x08)==0)    return(0);
        else                                 return(1);
    case 2:
        if((year_code[table_addr]&amp;0x04)==0)    return(0);
        else                                 return(1);
    case 3:
        if((year_code[table_addr]&amp;0x02)==0)    return(0);
        else                                 return(1);
    case 4:
        if((year_code[table_addr]&amp;0x01)==0)    return(0);
        else                                 return(1);
    case 5:
        if((year_code[table_addr+1]&amp;0x80)==0)    return(0);
        else                                     return(1);
    case 6:
        if((year_code[table_addr+1]&amp;0x40)==0)    return(0);
        else                                     return(1);
    case 7:
        if((year_code[table_addr+1]&amp;0x20)==0)    return(0);
        else                                     return(1);
    case 8:
        if((year_code[table_addr+1]&amp;0x10)==0)    return(0);
        else                                     return(1);
    case 9:
        if((year_code[table_addr+1]&amp;0x08)==0)    return(0);
        else                                     return(1);
    case 10:
        if((year_code[table_addr+1]&amp;0x04)==0)    return(0);
        else                                     return(1);
    case 11:
        if((year_code[table_addr+1]&amp;0x02)==0)    return(0);
        else                                     return(1);
    case 12:
        if((year_code[table_addr+1]&amp;0x01)==0)    return(0);
        else                                     return(1);
    case 13:
        if((year_code[table_addr+2]&amp;0x80)==0)    return(0);
        else                                     return(1);
    }
    return(0);
}

/*********************************************************************************************************
** 函数名称:GetChinaCalendar
** 功能描述:公农历转换(只允许1901-2099年)
** 输　入:  year        公历年
**          month       公历月
**          day         公历日
**          p           储存农历日期地址
** 输　出:  1           成功
**          0           失败
*****/
unsigned char GetChinaCalendar(
    unsigned int  year,
    unsigned char month,
    unsigned char day,
    unsigned char *p)
{
    unsigned char temp1,temp2,temp3,month_p,yearH,yearL;
    unsigned char flag_y;
    unsigned short temp4,table_addr;

    yearH=year/100;
    yearL=year%100;
    if((yearH!=19)&amp;&amp;(yearH!=20))    return(0);

    /* 定位数据表地址 */
    if(yearH==20)    table_addr=(yearL+100-1)*3;
    else              table_addr=(yearL-1)*3;

    /* 取当年春节所在的公历月份 */
    temp1=year_code[table_addr+2]&amp;0x60;
    temp1&gt;&gt;=5;

    /* 取当年春节所在的公历日 */
    temp2=year_code[table_addr+2]&amp;31;

    /* 计算当年春年离当年元旦的天数,春节只会在公历1月或2月 */
    if(temp1==1)     temp3=temp2-1;
    else             temp3=temp2+31-1;

    /* 计算公历日离当年元旦的天数 */
    if (month&lt;10)     temp4=day_code1[month-1]+day-1;
    else              temp4=day_code2[month-10]+day-1;
    /* 如果公历月大于2月并且该年的2月为闰月,天数加1 */
    if ((month&gt;2)&amp;&amp;(yearL%4==0))     temp4++;

    /* 判断公历日在春节前还是春节后 */
    if (temp4&gt;=temp3)
    {
        temp4-=temp3;
        month=1;
        month_p=1;

        flag_y=0;
        if(GetMoonDay(month_p,table_addr)==0)    temp1=29; //小月29天
        else                                     temp1=30; //大小30天
        /* 从数据表中取该年的闰月月份,如为0则该年无闰月 */
        temp2=year_code[table_addr]/16;
        while(temp4&gt;=temp1)
        {
            temp4-=temp1;
            month_p++;
            if(month==temp2)
            {
                flag_y=~flag_y;
                if(flag_y==0)month++;
            }
            else month++;
            if(GetMoonDay(month_p,table_addr)==0)    temp1=29;
            else                                     temp1=30;
        }
        day=temp4+1;
    }
    /* 公历日在春节前使用下面代码进行运算 */
    else
    {
        temp3-=temp4;
        if (yearL==0)
        {
            yearL=100-1;
            yearH=19;
        }
        else yearL--;
        table_addr-=3;
        month=12;
        temp2=year_code[table_addr]/16;
        if (temp2==0)    month_p=12;
        else             month_p=13;

        flag_y=0;
        if(GetMoonDay(month_p,table_addr)==0)    temp1=29;
        else                                     temp1=30;
        while(temp3&gt;temp1)
        {
            temp3-=temp1;
            month_p--;
            if(flag_y==0)        month--;
            if(month==temp2)    flag_y=~flag_y;
            if(GetMoonDay(month_p,table_addr)==0)    temp1=29;
            else                                     temp1=30;
        }
        day=temp1-temp3+1;
    }

    *p++=yearH;
    *p++=yearL;
    *p++=month;
    *p=day;
    return(1);
}

static unsigned char const table_week[12]= {0,3,3,6,1,4,6,2,5,0,3,5}; //月修正数据表
/*********************************************************************************************************
** 函数名称:GetWeek
** 功能描述:输入公历日期得到星期(只允许1901-2099年)
** 输　入:  year        公历年
**          month       公历月
**          day            公历日
**          p           储存星期地址
** 输　出:  无
***********************/
void GetWeek(
    unsigned int year,
    unsigned char month,
    unsigned char day,
    unsigned char *p)
{
    unsigned int temp2;
    unsigned char yearH,yearL;

    yearH=year/100;
    yearL=year%100;

    /* 如果为21世纪,年份数加100 */
    if (yearH&gt;19)         yearL+=100;
    /* 所过闰年数只算1900年之后的 */
    temp2=yearL+yearL/4;
    temp2=temp2%7;
    temp2=temp2+day+table_week[month-1];
    if (yearL%4==0&amp;&amp;month&lt;3)    temp2--;
    *p=(temp2%7);
}

/*********************************************************************************************************
** 函数名称:GetSkyEarth
** 功能描述:输入公历日期得到一个甲子年(只允许1901-2099年)
** 输　入:  year        公历年
**          p           储存星期地址
** 输　出:  无
**********************************************************************************/
static void GetSkyEarth(unsigned int year,unsigned char *p)
{
    unsigned char x;

    if(year&gt;=1984)
    {
        year=year-1984;
        x=year%60;
    }
    else
    {
        year=1984-year;
        x=60-year%60;
    }
    *p=x;
}
static void StrCopy(char *target,unsigned char const *source,unsigned char no)
{
    unsigned int i;

    for(i=0; i&lt;no; i++)
    {
        *target++=*source++;
    }
}
/*********************************************************************************************************
** 函数名称:GetChinaCalendarStr
** 功能描述:输入公历日期得到农历字符串
**          如:GetChinaCalendarStr(2007,02,06,str) 返回str=&quot;丙戌年腊月十九&quot;
** 输　入:  year        公历年
**          month       公历月
**          day         公历日
**          str         储存农历日期字符串地址   15Byte
** 输　出:  无
*******************************************************************************/
void GetChinaCalendarStr(
    unsigned int  year,
    unsigned char month,
    unsigned char day,
    char *str)
{
    unsigned char NLyear[4];
    unsigned char SEyear;

    StrCopy(&amp;str[0],(unsigned char *)&quot;甲子年正月初一&quot;,15);
    if(GetChinaCalendar(year,month,day,(unsigned char *)NLyear)==0)	return;
    GetSkyEarth(NLyear[0]*100+NLyear[1],&amp;SEyear);
    StrCopy(&amp;str[0],(unsigned char *)  sky[SEyear%10],2);	//  甲
    StrCopy(&amp;str[2],(unsigned char *)earth[SEyear%12],2);	//  子

    if(NLyear[2]==1)	StrCopy(&amp;str[6],(unsigned char *)&quot;正&quot;,2);
    else				StrCopy(&amp;str[6],(unsigned char *)monthcode[NLyear[2]-1],2);

    if(NLyear[3]&gt;10) 	StrCopy(&amp;str[10],(unsigned char *)nongliday[NLyear[3]/10],2);
    else				StrCopy(&amp;str[10],(unsigned char *)&quot;初&quot;,2);
    StrCopy(&amp;str[12],(unsigned char *)monthcode[(NLyear[3]-1)%10],2);
}

/*********************************************************************************************************
**         以下为24节气计算相关程序
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/


/*
    每年24节气标志表
    有兴趣的朋友可按照上面给的原理添加其它年份的表格
    
*/
static unsigned char const YearMonthBit[]=
{
    0x4E,0xA6,0x99,		//2000
    0x9C,0xA2,0x98,		//2001
    0x80,0x00,0x18,		//2002
    0x00,0x10,0x24,		//2003
    0x4E,0xA6,0x99,		//2004
    0x9C,0xA2,0x98,		//2005
    0x80,0x82,0x18,		//2006
    0x00,0x10,0x24,		//2007
    0x4E,0xA6,0xD9,		//2008
    0x9E,0xA2,0x98,		//2009

    0x80,0x82,0x18,		//2010
    0x00,0x10,0x04,		//2011
    0x4E,0xE6,0xD9,		//2012
    0x9E,0xA6,0xA8,		//2013
    0x80,0x82,0x18,		//2014
    0x00,0x10,0x00,		//2015
    0x0F,0xE6,0xD9,		//2016
    0xBE,0xA6,0x98,		//2017
    0x88,0x82,0x18,		//2018
    0x80,0x00,0x00,		//2019

    0x0F,0xEF,0xD9,		//2020
    0xBE,0xA6,0x99,		//2021
    0x8C,0x82,0x98,		//2022
    0x80,0x00,0x00,		//2023
    0x0F,0xEF,0xDB,		//2024
    0xBE,0xA6,0x99,		//2025
    0x9C,0xA2,0x98,		//2026
    0x80,0x00,0x18,		//2027
    0x0F,0xEF,0xDB,		//2028
    0xBE,0xA6,0x99,		//2029

    0x9C,0xA2,0x98,		//2030
    0x80,0x00,0x18,		//2031
    0x0F,0xEF,0xDB,		//2032
    0xBE,0xA2,0x99,		//2033
    0x8C,0xA0,0x98,		//2034
    0x80,0x82,0x18,		//2035
    0x0B,0xEF,0xDB,		//2036
    0xBE,0xA6,0x99,		//2037
    0x8C,0xA2,0x98,		//2038
    0x80,0x82,0x18,		//2039

    0x0F,0xEF,0xDB,		//2040
    0xBE,0xE6,0xD9,		//2041
    0x9E,0xA2,0x98,		//2042
    0x80,0x82,0x18,		//2043
    0x0F,0xEF,0xFB,		//2044
    0xBF,0xE6,0xD9,		//2045
    0x9E,0xA6,0x98,		//2046
    0x80,0x82,0x18,		//2047
    0x0F,0xFF,0xFF,		//2048
    0xFC,0xEF,0xD9,		//2049
    0xBE,0xA6,0x18,		//2050
};
static unsigned char const days[]=
{
    6,20,4,19,6,21,         //一月到三月  的节气基本日期
    5,20,6,21,6,21,         //四月到六月  的节气基本日期
    7,23,8,23,8,23,         //七月到九月  的节气基本日期
    8,24,8,22,7,22,         //十月到十二月的节气基本日期
};
static char const JieQiStr[][5]=  //以公历日期先后排序
{
    /*  名称        角度    公历日期     周期 */
    &quot;小寒&quot;,     //285     1月 6日
    &quot;大寒&quot;,     //300     1月20日    29.5天
    &quot;立春&quot;,     //315     2月 4日
    &quot;雨水&quot;,     //330     2月19日    29.8天
    &quot;惊蛰&quot;,     //345     3月 6日
    &quot;春分&quot;,     //  0     3月21日    30.2天
    &quot;清明&quot;,     // 15     4月 5日
    &quot;谷雨&quot;,     // 30     4月20日    30.7天
    &quot;立夏&quot;,     // 45     5月 6日
    &quot;夏满&quot;,     // 60     5月21日    31.2天
    &quot;芒种&quot;,     // 75     6月 6日
    &quot;夏至&quot;,     // 90     6月21日    31.4天
    &quot;小暑&quot;,     //105     7月 7日
    &quot;大暑&quot;,     //120     7月23日    31.4天
    &quot;立秋&quot;,     //135     8月 8日
    &quot;处暑&quot;,     //150     8月23日    31.1天
    &quot;白露&quot;,     //165     9月 8日
    &quot;秋分&quot;,     //180     9月23日    30.7天
    &quot;寒露&quot;,     //195    10月 8日
    &quot;霜降&quot;,     //210    10月24日    30.1天
    &quot;立冬&quot;,     //225    11月 8日
    &quot;小雪&quot;,     //240    11月22日    29.7天
    &quot;大雪&quot;,     //255    12月 7日
    &quot;冬至&quot;,     //270    12月22日    29.5天
};
/*********************************************************************************************************
** 函数名称:GetJieQi
** 功能描述:输入公历日期得到本月24节气日期 day&lt;15返回上半月节气,反之返回下半月
**          如:GetJieQiStr(2007,02,08,str) 返回str[0]=4
** 输　入:  year        公历年
**          month       公历月
**          day         公历日
**          str         储存对应本月节气日期地址   1Byte
** 输　出:  1           成功
**          0           失败
************************************************************************************/
unsigned char GetJieQi(
    unsigned  int year,
    unsigned char month,
    unsigned char day,
    unsigned char *JQdate)
{
    unsigned char bak1,value,JQ;

    if((year&lt;2000)||(year&gt;2050))     return 0;
    if((month==0) ||(month&gt;12))      return 0;
    JQ = (month-1) *2 ;		                        //获得节气顺序标号(0～23
    if(day &gt;= 15) JQ++; 	                        //判断是否是上半月

    bak1=YearMonthBit[(year-2000)*3+JQ/8];          //获得节气日期相对值所在字节
    value =((bak1&lt;&lt;(JQ%8))&amp;0x80);                   //获得节气日期相对值状态

    *JQdate=days[JQ];
    if( value != 0 )
    {
        //判断年份,以决定节气相对值1代表1,还是－1。
        if( (JQ== 1||JQ== 11||JQ== 18||JQ== 21)&amp;&amp;year&lt; 2044)  (*JQdate)++;
        else                                                  (*JQdate)--;
    }
    return 1;
}
static unsigned char const MonthDayMax[]= {31,28,31,30,31,30,31,31,30,31,30,31,};
/*********************************************************************************************************
** 函数名称:GetJieQiStr
** 功能描述:输入公历日期得到24节气字符串
**          如:GetJieQiStr(2007,02,08,str) 返回str=&quot;离雨水还有11天&quot;
** 输　入:  year        公历年
**          month       公历月
**          day         公历日
**          str         储存24节气字符串地址   15Byte
** 输　出:  1           成功
**          0           失败
**********************************************************************************/
unsigned char GetJieQiStr(
    unsigned int year,
    unsigned char month,
    unsigned char day,
    char *str)
{
    unsigned char JQdate,JQ,MaxDay;

    if(GetJieQi(year,month,day,&amp;JQdate)==0)	return 0;

    JQ = (month-1) *2 ;                             //获得节气顺序标号(0～23
    if(day &gt;= 15) JQ++;                             //判断是否是上半月

    if(day==JQdate)                                 //今天正是一个节气日
    {
        StrCopy(str,(unsigned char *)JieQiStr[JQ],5);
        return 1;
    }
    //今天不是一个节气日
    StrCopy(str,(unsigned char *)&quot;离小寒还有??天&quot;,15);
    if(day&lt;JQdate)                                  //如果今天日期小于本月的节气日期
    {
        StrCopy(&amp;str[2],(unsigned char *)JieQiStr[JQ],4);
        day=JQdate-day;
    }
    else                                            //如果今天日期大于本月的节气日期
    {
        StrCopy(&amp;str[2],(unsigned char *)JieQiStr[JQ+1],4);
        if(day &lt; 15)
        {
            GetJieQi(year,month,15,&amp;JQdate);
            day=JQdate-day;
        }
        else                                        //翻月
        {
            MaxDay=MonthDayMax[month-1];
            if(month==2)                            //润月问题
            {
                if((year%4==0)&amp;&amp;((year%100!=0)||(year%400==0))) MaxDay++;
            }
            if(++month==13)	month=1;
            GetJieQi(year,month,1,&amp;JQdate);
            day=MaxDay-day+JQdate;
        }
    }
    str[10]=day/10+'0';
    str[11]=day%10+'0';
    return 1;
}"/>
    <Command cmdname="数据示波器-源程序" cmdType="P" cmd="[P]#include &quot;windows.h&quot;		// Header File For Windows
#include &lt;stdio.h&gt;			// Header File For Standard Input/Output
#include &lt;stdlib.h&gt;
#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library
#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library
#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library
//#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;
#pragma comment(lib,&quot;lib\\ftgl.def&quot;);                                              
#pragma comment(lib,&quot;lib\\shx.o&quot;);
#pragma comment(lib,&quot;lib\\glGraphLib.o&quot;);
#define bool unsigned char
int starttime;
unsigned int framecount=0;
GLuint	base;
int *ft;
bool closing=0;
#define	num 360 				// Number Of Stars To Draw
int mx=0,my=0;
int mdx=-1,mdy=-1;
int mux=-1,muy=-1;
int md=0;
int tbxscale,tbyscale;
int xscale=0,yscale=0;
int bkColor=0;
int tbbkclr;
int cbWave,cbHisto,cbClock,cbDigit,dispHisto=0,dispClock=0,dispDigit=0,dispWave=0;
unsigned char NeedRedraw=1;
GLuint	texture[1];			// Storage For One textures
double imgWidth;
HGLRC hglrc;
HDC hdc;
int cbDisp1=1,cbDisp2=1;
int cbSimDat,tmrSimDat;
unsigned char DispChannel[16]= {1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
float imgX0=-20,imgX1=20,imgY0=-8,imgY1=8;
int wd,ht;
double zoom=1,offsetx=0,offsety=0;
unsigned char waveData[16][1024];
int   waveDataCount[16]= {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
int GuiMode=2,pfm,pfm0;
int maxWaveCount;
typedef struct CharIndex
{
    int code;
    int shapePtr;
    int len;
} CharIndex;

int winwidth,winheight;

typedef struct _ShxFont_
{
    int openOK;
    int indexCount;
    unsigned char *buffer;
    CharIndex *indexBuffer;
    int type;
    int shxFontDownLine,shxFontUpLine;
    double scale;
} ShxFont;
ShxFont *sfChar=NULL,*sfHz=NULL;
double GetShxFontScale(ShxFont *sf);

typedef struct
{
    float x;
    float y;
    float z;
} POINT3D;
extern void Draw7Seg(int dig,float x0,float y0,float z0,float scale,float r,float g,float b,float alpha,float width,float thick,float italic);  //下
extern void DrawClock(float x,float y,float z,float r,float g,float b,float rad1,float rad2,unsigned char *name,unsigned char dat);

void SwapFolat(float *a,float *b)
{
    float tmp=*a;
    *a=*b;
    *b=tmp;
}

void FormCreate()
{
    hdc=GetDC(GetFormHandle(pfm));
    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);
    int nPixelFormat;
    static PIXELFORMATDESCRIPTOR pfd=
    {
        sizeof(PIXELFORMATDESCRIPTOR),
        1,
        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
        PFD_TYPE_RGBA,
        24,
        0,0,0,0,0,
        0,0,
        0,0,0,0,0,
        32,
        0,
        0,
        PFD_MAIN_PLANE,
        0,
        0,0,0
    };
    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);
    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);

    hglrc=wglCreateContext(hdc);
    wglMakeCurrent(hdc,hglrc);
}
//---------------------------------------------------------------------------
GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}

void OnClose()
{
    if((GuiMode==0)||(GuiMode==1))
    {
        ClearVclControls();
        HideVclWin(200);
    }
    else
    {
        //ClearVclControls();
        CloseForm(pfm0);
    }
    printf(&quot;close&quot;);
}

void  FormDestroy()
{
    closing=1;
    Wait(2);
    printf(&quot;destroy&quot;);
}

int AnsiToUnicode(unsigned char *pszA, unsigned char* ppszW)
{
    ULONG cCharacters;
    DWORD dwError;
    if (NULL == pszA)
    {
        *ppszW = NULL;
        printf(&quot;ERROR0&quot;);
        return NOERROR;
    }
    cCharacters =  strlen(pszA)+1;
    if (NULL == ppszW)
        return E_OUTOFMEMORY;
    // Covert to Unicode.
    if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, -1,
                                 ppszW, cCharacters))
    {
        dwError = GetLastError();
        free(ppszW);
        ppszW = NULL;
        printf(&quot;ERROR&quot;);
        return HRESULT_FROM_WIN32(dwError);
    }
    return NOERROR;
}
GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine
{
    char		text[256],text1[256];								// Holds Our String
    va_list		ap;										// Pointer To List Of Arguments
    if (fmt == NULL)									// If There's No Text
        return;											// Do Nothing
    va_start(ap, fmt);									// Parses The String For Variables
    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers
    va_end(ap);											// Results Are Stored In Text

    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits
    //glListBase(base - 32);								// Sets The Base Character to 32
    ////// glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text
    glScalef(0.006,0.006,0.006);
    glScalef(1.5,1.5,0.006);
    AnsiToUnicode(text,text1);
    ftglRenderFontW(ft, text1, 0xffff);
    //ftglRenderFont(ft, text, 0xffff);
    glPopAttrib();										// Pops The Display List Bits
}
void DrawLine(ShxFont *sf,double x0,double y0,double x1,double y1)
{
    double scale;
    scale=5.0/GetShxFontHeight(sf)*1.0* sf-&gt;scale;// 0.08;
    x0*=scale;
    y0*=scale;
    x1*=scale;
    y1*=scale;
    x0+=0;
    x1+=0;

    glBegin(GL_LINES);
    glVertex3f(x0+0.3*y0,y0, 0.0f);
    glVertex3f(x1+0.3*y1,y1, 0.0f);
    glEnd();
}


GLvoid glShxPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine
{
    unsigned char		text[256];								// Holds Our String
    va_list		ap;										// Pointer To List Of Arguments
    int i=0;
    if (fmt == NULL)									// If There's No Text
        return;											// Do Nothing
    //return;
    va_start(ap, fmt);									// Parses The String For Variables
    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers
    va_end(ap);											// Results Are Stored In Text
    //glLoadIdentity();//
    //glScalef(0.1,0.1,0); //
    while(text[i])
    {
        if(text[i]&lt;128)
        {
            ReadCharShape(sfChar,text[i],0);//
            glTranslatef(14,0.0f,0.0f);////
            i++;
        }
        else
        {
            glTranslatef(0.0,-3.5f,0.0f);
            ReadCharShape(sfHz,text[i]*256+text[i+1],0);
            glTranslatef(22.0,3.5f,0.0f);

            i++;
            i++;
        }

    }
}

AUX_RGBImageRec *LoadBMP(char *Filename)                // Loads A Bitmap Image
{
    FILE *File=NULL;                                // File Handle
    if (!Filename)                                  // Make Sure A Filename Was Given
        return NULL;                            // If Not Return NULL
    File=fopen(Filename,&quot;r&quot;);                       // Check To See If The File Exists
    if (File)                                       // Does The File Exist?
    {
        fclose(File);                           // Close The Handle
        return auxDIBImageLoad(Filename);       // Load The Bitmap And Return A Pointer
    }
    return NULL;                                    // If Load Failed Return NULL
}

int LoadGLTextures()                                    // Load Bitmaps And Convert To Textures
{
    int Status=FALSE;                               // Status Indicator
    AUX_RGBImageRec *TextureImage[1];               // Create Storage Space For The Texture
    memset(TextureImage,0,sizeof(void *)*1);        // Set The Pointer To NULL
    // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit
    if (TextureImage[0]=LoadBMP(&quot;dat/mf.bmp&quot;))
    {
        Status=TRUE;                            // Set The Status To TRUE
        glGenTextures(1, &amp;texture[0]);          // Create One Texture
        // Create Linear Filtered Texture
        glBindTexture(GL_TEXTURE_2D, texture[0]);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);
    }
    if (TextureImage[0])                            // If Texture Exists
    {
        if (TextureImage[0]-&gt;data)              // If Texture Image Exists
        {
            free(TextureImage[0]-&gt;data);    // Free The Texture Image Memory
        }
        free(TextureImage[0]);                  // Free The Image Structure
    }
    return Status;                                  // Return The Status
}

GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font
{
    HFONT	font;										// Windows Font ID
    HFONT	oldfont;									// Used For Good House Keeping
    base = glGenLists(96);								// Storage For 96 Characters
    font = CreateFont(	-11,							// Height Of Font
                        0,								// Width Of Font
                        0,								// Angle Of Escapement
                        0,								// Orientation Angle
                        FW_BOLD,						// Font Weight
                        TRUE,							// Italic
                        FALSE,							// Underline
                        FALSE,							// Strikeout
                        ANSI_CHARSET,					// Character Set Identifier
                        OUT_TT_PRECIS,					// Output Precision
                        CLIP_DEFAULT_PRECIS,			// Clipping Precision
                        ANTIALIASED_QUALITY,			// Output Quality
                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch

                        //&quot;Courier New&quot;);					// Font Name
                        &quot;Bodoni MT Black&quot;);


    //printf(&quot;font:%x&quot;,font);
    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want
    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32
    SelectObject(hdc, oldfont);							// Selects The Font We Want
    DeleteObject(font);									// Delete The Font
}

void ResizeGl()
{
    char s[100];
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    double ox=-(offsetx+mux-mdx)*792.0/winwidth;
    double oy=(offsety+muy-mdy);
    if (winwidth/1.8 &lt;= winheight)
    {
        glOrtho(-22.5*zoom, 22.5*zoom, -22.5 * (GLfloat)winheight*1.0/(GLfloat)winwidth*zoom, 22.5 * (GLfloat)winheight*1.0/(GLfloat)winwidth*zoom, -20.0, 20.0);
        imgWidth=-22.5*zoom;
        //printf(&quot;imgWidth000:%f&quot;,imgWidth);
        sprintf(s,&quot;1:%d,%d:%f,%f,%f,%f&quot;,winwidth,winheight,-10.5, 10.5, -10.5 * (GLfloat)winheight*1.0/(GLfloat)winwidth, 10.5 * (GLfloat)winheight*1.0/(GLfloat)winwidth);
    }
    else
    {
        glOrtho(-10.0*(GLfloat)winwidth/(GLfloat)winheight*zoom, 10.0*(GLfloat)winwidth/(GLfloat)winheight*zoom, -10.0*zoom, 10.0*zoom, -20.0, 20.0);
        imgWidth=-10.0*(GLfloat)winwidth/(GLfloat)winheight*zoom;
        //printf(&quot;imgWidth111:%f&quot;,imgWidth);
        sprintf(s,&quot;2:%d,%d:%f,%f,%f,%f&quot;,winwidth,winheight,-10.5*(GLfloat)winwidth/(GLfloat)winheight, 10.5*(GLfloat)winwidth/(GLfloat)winheight, -10.5, 10.5);
    }

    glTranslatef(-ox*0.066*zoom,-oy*0.066*zoom,0);
    //printf(s);

    //SetProperty(pfm,&quot;caption&quot;,s);
    glMatrixMode(GL_MODELVIEW);
}
GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window
{

    if (height==0)										// Prevent A Divide By Zero By
        height=1;										// Making Height Equal One

    winwidth=width;
    winheight=height;
    //glViewport(0, 0, (GLsizei)width*1.8, (GLsizei)height*1);
    glViewport(0 , 0 , (GLsizei)width , (GLsizei)height );
    ResizeGl();


    glLoadIdentity();
    glDrawBuffer(GL_BACK); // added code
    // Reset The Modelview Matrix
}

POINT3D pot3d;
POINT3D ScreenToGL(int x,int y)
{
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();

    GLint viewport[4];
    GLdouble modelview[16];
    GLdouble projection[16];
    GLfloat winX, winY, winZ;
    GLdouble posX, posY, posZ;

    glGetDoublev( GL_MODELVIEW_MATRIX, modelview );
    glGetDoublev( GL_PROJECTION_MATRIX, projection );
    glGetIntegerv( GL_VIEWPORT, viewport );

    winX =  x;
    winY =  viewport[3] -  y;
    glReadPixels(  x,  (winY), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &amp;winZ );
    gluUnProject( winX, winY, winZ, modelview, projection, viewport, &amp;posX, &amp;posY, &amp;posZ);

    pot3d.x = (float)posX;
    pot3d.y = (float)posY;
    pot3d.z = (float)posZ;
    return pot3d;
}
#define FT_ENC_TAG( value, a, b, c, d )         \
          unsigned int value = ( ( (int)(a) &lt;&lt; 24 ) |  \
                    ( (int)(b) &lt;&lt; 16 ) |  \
                    ( (int)(c) &lt;&lt;  8 ) |  \
                      (int)(d)         )


FT_ENC_TAG( FT_ENCODING_UNICODE,   'u', 'n', 'i', 'c' );

int InitGL(GLvoid)										// All Setup For OpenGL Goes Here
{
    unsigned short val;
    val=0x137f;



    if (!LoadGLTextures())								// Jump To Texture Loading Routine
    {
        printf(&quot;LoadGLTextures error!&quot;);
        return FALSE;									// If Texture Didn't Load Return FALSE
    }
    glEnable(GL_TEXTURE_2D);							// Enable Texture Mapping
    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading
    glClearColor(0.1f, 0.0f, 0.0f, 1.0f);				// Black Background
    glClearDepth(1.0f);									// Depth Buffer Setup
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations
    glBlendFunc(GL_SRC_ALPHA,GL_ONE);					// Set The Blending Function For Translucency
    glEnable(GL_BLEND);
    BuildFont();
    //ft=ftglCreateBufferFont(&quot;c:\\windows\\fonts\\BOD_BLAI.TTF&quot;);

    //__asm__(&quot;fldcw %0&quot;:&quot;m&quot;(val));
    ft=ftglCreateBufferFont(&quot;c:\\windows\\fonts\\simhei.TTf&quot;);
    //ft=ftglCreateBufferFont(&quot;ni7seg.TTf&quot;);
    //__asm__(&quot;fldcw %0&quot;:&quot;m&quot;(val));
    ftglSetFontFaceSize(ft, 80, 72);
    ftglSetFontDepth(ft, 10);
    ftglSetFontOutset(ft, 0, 3);
    ftglSetFontDisplayList(ft,0);
    ftglSetFontCharMap(ft, FT_ENCODING_UNICODE);
    //printf(&quot;glft:%x,set char map:%d&quot;,ft,r);

    return TRUE;										// Initialization Went OK
}
GLvoid glDrawCube()					// 绘制立方体
{
    glBegin(GL_QUADS);
    // 前面
    glNormal3f( 0.0f, 0.0f, 1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f,  1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f,  1.0f);
    // 后面
    glNormal3f( 0.0f, 0.0f,-1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f, -1.0f);
    // 上面
    glNormal3f( 0.0f, 1.0f, 0.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f,  1.0f,  1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f( 1.0f,  1.0f,  1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f, -1.0f);
    // 下面
    glNormal3f( 0.0f,-1.0f, 0.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f( 1.0f, -1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f,  1.0f);
    // 右面
    glNormal3f( 1.0f, 0.0f, 0.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f,  1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f,  1.0f);
    // 左面
    glNormal3f(-1.0f, 0.0f, 0.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f,  1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f, -1.0f);
    glEnd();
}

unsigned int Start=0;
void DrawSinWave()
{
    int i,loop;
    glEnable(GL_LINE_SMOOTH);
    glDisable(GL_TEXTURE_2D);

    for(i=1; i&lt;5; i++)
    {
        glLoadIdentity();	//
        glTranslatef(-12.5f,3.0f,-2.0f );
        glLineWidth(1.2f*(5-i));
        glColor4f(0.0f,1.0f,0.0f,0.10f*i);

        glBegin(GL_LINE_STRIP );
        for (loop=0; loop&lt;num; loop+=1) //非调制 sine wave
            glVertex3f((loop+0)*0.1-5,2.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))-5,0);
        glEnd();
    }
}

void DrawDataWave(int channel,float x,float y,float r,float g,float b)
{
    int i,j,loop;
    int mid;
    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_POLYGON_SMOOTH);
    glDisable(GL_TEXTURE_2D);
    glEnable(GL_BLEND);
    int w=4-wd/300;
    if(w&lt;0) w=0;
    if(waveDataCount[channel]+5&lt;maxWaveCount)
        mid=waveDataCount[channel]+5;
    else
        mid=maxWaveCount;
    for(i=w; i&lt;5; i++)
    {
        glLoadIdentity();
        glLineWidth(1.2f*(5-i));
        glColor4f(r,g,b,0.10f*i);
        glBegin(GL_LINE_STRIP );
        for(j=0; j&lt;=waveDataCount[channel]; j++)
        {
            glVertex3f(imgX0+x+j/(6.0-xscale/10.0),y+imgY0+0.035*waveData[channel][j]/(1.0-yscale/50.0),0);
        }
        glEnd();

        glBegin(GL_LINE_STRIP );
        glColor4f(r,g,b,0.02f*i);
        for(j=waveDataCount[channel]; j&lt;=mid; j++)
        {
            glVertex3f(imgX0+x+j/(6.0-xscale/10.0),y+imgY0+0.035*waveData[channel][j]/(1.0-yscale/50.0),0);
        }
        glEnd();


        glBegin(GL_LINE_STRIP );
        glColor4f(r,g,b,0.10f*i);
        for(j=waveDataCount[channel]+5; j&lt;maxWaveCount; j++)
        {
            glVertex3f(imgX0+x+j/(6.0-xscale/10.0),y+imgY0+0.035*waveData[channel][j]/(1.0-yscale/50.0),0);
        }
        glEnd();
    }

    glBegin(GL_QUADS);
    glColor4f(r ,g ,b,0.2f );
    glVertex3f(imgX0+x+waveDataCount[channel]/(6.0-xscale/10.0), imgY0, 0.0f);
    glVertex3f(imgX0+x+(waveDataCount[channel]+5)/(6.0-xscale/10.0), imgY0, 0.0f);
    glVertex3f(imgX0+x+(waveDataCount[channel]+5)/(6.0-xscale/10.0), imgY0+20, 0.0f);
    glVertex3f(imgX0+x+ waveDataCount[channel] /(6.0-xscale/10.0), imgY0+20, 0.0f);
    glEnd();



}
void DrawHistogram(int channel,float x,float y,float wd,float r,float g,float b)
{
    glLineWidth(1.0f);
    glLoadIdentity();
    glEnable(GL_BLEND);

    glBegin(GL_QUADS);
    glColor4f(r ,g ,b,0.8f );
    glVertex3f(x+imgX0,y+imgY0, 0.0f);
    glVertex3f(x+imgX0+wd,y+imgY0, 0.0f);
    glColor4f(r ,g ,b,0.2f );
    glVertex3f(x+imgX0+wd,y+imgY0+0.015*waveData[channel][waveDataCount[channel]]*(2+yscale/25.0), 0.0f);
    glVertex3f(x+imgX0,y+imgY0+0.015*waveData[channel][waveDataCount[channel]]*(2+yscale/25.0), 0.0f);
    glEnd();

    glDisable(GL_BLEND);
    glBegin(GL_LINE_LOOP);
    glColor4f(r ,g ,b,0.8f );
    glVertex3f(x+imgX0,y+imgY0, 0.0f);
    glVertex3f(x+imgX0+wd,y+imgY0, 0.0f);
    glColor4f(r ,g ,b,0.8f );
    glVertex3f(x+imgX0+wd,y+imgY0+0.015*waveData[channel][waveDataCount[channel]]*(2+yscale/25.0), 0.0f);
    glVertex3f(x+imgX0,y+imgY0+0.015*waveData[channel][waveDataCount[channel]]*(2+yscale/25.0), 0.0f);
    glEnd();
    glEnable(GL_BLEND);

}
void DrawGrid()
{
    int i,j;
    glDisable(GL_TEXTURE_2D);
    glDisable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA,GL_ONE);
    glLoadIdentity();
    glBegin(GL_QUADS);
    glColor4f(0.0f,0.1+bkColor/80.0,0.1+bkColor/80.0,1.0f);
    glVertex3f(imgX0,imgY1, -0.0f);
    glVertex3f(imgX1,imgY1,-0.0f);
    glColor4f(0.0f,0.1+bkColor/80.0,0.1+bkColor/80.0,1.0f);
    glVertex3f(imgX1,imgY0,-0.0f);
    glVertex3f(imgX0,imgY0, -0.0f);
    glEnd();
    /**/
    glEnable(GL_BLEND);

    glColor4f(0.0f ,0.3f ,0.0f,0.3f );

    for(j=0; j&lt;10; j++)
        for(i=0; i&lt;24; i+=2)
        {
            glBegin(GL_QUADS);
            glVertex3f(imgX0+(i+0+j%2)*(imgX1-imgX0)/24.0+0.04,imgY0+(j+0)*(imgY1-imgY0)/10.0+0.04, 0.0f);
            glVertex3f(imgX0+(i+1+j%2)*(imgX1-imgX0)/24.0-0.04,imgY0+(j+0)*(imgY1-imgY0)/10.0+0.04, 0.0f);
            glVertex3f(imgX0+(i+1+j%2)*(imgX1-imgX0)/24.0-0.04,imgY0+(j+1)*(imgY1-imgY0)/10.0-0.04, 0.0f);
            glVertex3f(imgX0+(i+0+j%2)*(imgX1-imgX0)/24.0+0.04,imgY0+(j+1)*(imgY1-imgY0)/10.0-0.04, 0.0f);
            glEnd();
        }

    for(j=1; j&lt;3; j++) //draw grid
    {
        glLoadIdentity();	//							// Reset The View Before We Draw Each Star
        //glTranslatef(-1.5f,0.0f,-0.0f);
        glLineWidth(1.2f*(3-j));							// 设置线宽为2.0f
        glColor4f(0.0f,1.0f,1.0f,0.06f*j);

        for(i=0; i&lt;=10; i++)
        {
            glBegin(GL_LINES);
            glVertex3f(imgX0,imgY0+i*(imgY1-imgY0)/10.0, 0.0f);
            glVertex3f(imgX1,imgY0+i*(imgY1-imgY0)/10.0, 0.0f);
            glEnd();
        }

        for(i=0; i&lt;=24; i++)
        {
            glBegin(GL_LINES);
            glVertex3f(imgX0+i*(imgX1-imgX0)/24.0,imgY0, 0.0f);
            glVertex3f(imgX0+i*(imgX1-imgX0)/24.0,imgY1, 0.0f);
            glEnd();
        }

    }
    glDisable(GL_BLEND);
    glLineWidth(2.2f);							// 设置线宽为2.0f
    glColor4f(0.0f,1.0f,1.0f,1.0f);
    /*glBegin(GL_LINE_STRIP);
    glVertex3f(imgX0,imgY0, 0.0f);
    glVertex3f(imgX1,imgY0, 0.0f);
    glVertex3f(imgX1,imgY1, 0.0f);
    glVertex3f(imgX0,imgY1, 0.0f);
    glVertex3f(imgX0,imgY0, 0.0f);

    glEnd();
    glEnable(GL_BLEND);
    glDisable(GL_BLEND);
    glLoadIdentity();
    glColor4f(0.0f ,1.0f ,1.0f,0.6f );
    for(i=0; i&lt;24; i++)
    {
        glRasterPos2f(imgX0+i*(imgX1-imgX0)/24.0-0.3f, imgY0-0.8);
        glPrint(&quot;%d&quot;,i);
    }
    for(i=0; i&lt;10; i++)
    {
        glRasterPos2f(imgX0-1.0f,imgY0+i*(imgY1-imgY0)/10.0-0.3f);
        glPrint(&quot;%d&quot;,i);
    }
    */
    glEnable(GL_BLEND);
}
void DrawFrame()
{
    int i,j;
    glDisable(GL_TEXTURE_2D);
    glDisable(GL_BLEND);
    glColor4f(0.0f,0.05f,0.05f,1.0f); //fill mouse
    glLoadIdentity();

    glBegin(GL_QUADS);      //left fill
    glVertex3f(imgX0,imgY0-10, -0.0f);
    glVertex3f(imgX0,imgY1+10, -0.0f);
    glVertex3f(imgX0-10,imgY1+10,-0.0f);
    glVertex3f(imgX0-10,imgY0-10,-0.0f);
    glEnd();

    glBegin(GL_QUADS);    //top fill
    glVertex3f(imgX0-10,imgY1, -0.0f);
    glVertex3f(imgX1+10,imgY1, -0.0f);
    glVertex3f(imgX1+10,imgY1+10,-0.0f);
    glVertex3f(imgX0-10,imgY1+10,-0.0f);
    glEnd();

    glBegin(GL_QUADS);    //right fill
    glVertex3f(imgX1,imgY1+10, -0.0f);
    glVertex3f(imgX1+10,imgY1+10, -0.0f);
    glVertex3f(imgX1+10,imgY0-10,-0.0f);
    glVertex3f(imgX1,imgY0-10,-0.0f);
    glEnd();

    glBegin(GL_QUADS);    //bottom fill
    glVertex3f(imgX0-10,imgY0, -0.0f);
    glVertex3f(imgX1+10,imgY0, -0.0f);
    glVertex3f(imgX1+10,imgY0-10,-0.0f);
    glVertex3f(imgX0-10,imgY0-10,-0.0f);
    glEnd();

    glColor4f(0.0f ,0.3f ,0.0f,0.3f );
    //glDisable(GL_BLEND);
    glLineWidth(1.0f);							// 设置线宽为2.0f
    glColor4f(0.0f,1.0f,1.0f,1.0f);
    glEnable(GL_BLEND);
    if((dispClock==1)||(dispDigit==1)) //
    {
        glLineWidth(2.0f);
        glColor4f(0.0f,1.0f,1.0f,0.5+1.0f*bkColor/80.0);
        glBegin(GL_LINE_STRIP);
        glVertex3f(imgX0,imgY0, 0.0f);
        glVertex3f(imgX1,imgY0, 0.0f);
        glVertex3f(imgX1,imgY1, 0.0f);
        glVertex3f(imgX0,imgY1, 0.0f);
        glVertex3f(imgX0,imgY0, 0.0f);
        glEnd();
    }
    glEnable(GL_BLEND);
    if(dispClock) return;
    if(dispDigit) return;
    glEnable(GL_BLEND);
    glDisable(GL_BLEND);
    glLoadIdentity();

    glEnable(GL_BLEND);
    glLineWidth(1.0f);
    glBegin(GL_LINES);
    glVertex3f(imgX0,imgY0-0.2, 0.0f);
    glVertex3f(imgX1,imgY0-0.2, 0.0f);

    glVertex3f(imgX0-0.2,imgY0, 0.0f);
    glVertex3f(imgX0-0.2,imgY1, 0.0f);
    glEnd();

    for(i=0; i&lt;=24*5; i++)
    {
        if(i%5==0)
            glLineWidth(2.0f);
        else
            glLineWidth(1.0f);
        glBegin(GL_LINES);
        glVertex3f(imgX0+i*(imgX1-imgX0)/(24.0*5) ,imgY0-0.2, 0.0f);
        if(i%5==0)
            glVertex3f(imgX0+i*(imgX1-imgX0)/(24.0*5) ,imgY0-0.8, 0.0f);
        else
            glVertex3f(imgX0+i*(imgX1-imgX0)/(24.0*5) ,imgY0-0.6, 0.0f);
        glEnd();
    }

    for(i=0; i&lt;=10*5; i++)
    {
        if(i%5==0)
            glLineWidth(2.0f);
        else
            glLineWidth(1.0f);
        glBegin(GL_LINES);
        glVertex3f(imgX0-0.2,imgY0+i*(imgY1-imgY0)/(10.0*5), 0.0f);
        if(i%5==0)
            glVertex3f(imgX0-0.8,imgY0+i*(imgY1-imgY0)/(10.0*5), 0.0f);
        else
            glVertex3f(imgX0-0.6,imgY0+i*(imgY1-imgY0)/(10.0*5), 0.0f);
        glEnd();
    }
    glLineWidth(1.0f);
    glColor4f(0.0f ,1.0f ,1.0f,1.0f );
    for(i=0; i&lt;=24; i+=2)
    {
        glLoadIdentity();
        glTranslatef(imgX0+i*(imgX1-imgX0)/24.0-0.8f, imgY0-1.6,0);
        //glRasterPos2f(imgX0+i*(imgX1-imgX0)/24.0-0.3f, imgY0-0.8);
        //glPrint(&quot;%d&quot;,i);
        glScalef(0.04,0.04,1);
        glShxPrint(&quot;%2d&quot;,i);
    }

    for(i=0; i&lt;=10; i+=2)
    {
        glLoadIdentity();
        glTranslatef(imgX0-2.0f,imgY0+i*(imgY1-imgY0)/10.0-0.3f,0);
        //glRasterPos2f(imgX0-1.0f,imgY0+i*(imgY1-imgY0)/10.0-0.3f);
        //glPrint(&quot;%d&quot;,i);
        if(i==10)   glTranslatef(-0.5,0,0);
        glScalef(0.04,0.04,1);

        glShxPrint(&quot;%2d&quot;,i*10);
    }
    glEnable(GL_BLEND);
}

void DrawCube(float x,float y,float z,float scale)
{
    glEnable(GL_TEXTURE_2D);
    //glDisable(GL_BLEND);
    glColor4f(0.3f,0.3f,1.0f,0.6f);
    glLoadIdentity();	//							// Reset The View Before We Draw Each Star
    glTranslatef(x,y,z);
    glScalef(scale,scale,scale);
    glRotatef(framecount*1,framecount*1,framecount*2,1.0f);
    glDrawCube(x,y,z);
    // glEnable(GL_BLEND);
}
void RoundRect1(
    float divide,  //圆角细分数量
    float cirr,    //内圆角半径
    float cirR,    //外圆角半径
    float w,       //内矩形宽度
    float h,       //内矩形高度
    float W,       //外矩形宽度
    float H)       //外矩形高度
{

}

void DrawMouseCursor()
{
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glLoadIdentity();
    POINT3D p3=ScreenToGL(mx,my);
    POINT3D pd3=ScreenToGL(mdx,mdy);
    POINT3D pu3=ScreenToGL(mux,muy);
    glDisable(GL_TEXTURE_2D);
    glTranslatef(p3.x,p3.y,0.0f);
    if(md)
        glRotatef(framecount*3,0,0,1.0f);
    glColor4f(1.0f,0.0f,0.0f,0.6f); //fill mouse

    glBegin(GL_QUADS);
    glVertex3f(0.3f,-0.3f, -20.0f);
    glVertex3f(-0.3f,-0.3f, -20.0f);
    glVertex3f(-0.3f,0.3f,-20.0f);
    glVertex3f(0.3f,0.3f,-20.0f);
    glEnd();

    glColor4f(1.0f,0.0f,0.0f,1.0f); //frame mouse
    glLineWidth(1.5f);
    glBegin(GL_LINE_LOOP);
    glVertex3f(-0.45f,-0.45f, 0.0f);
    glVertex3f(0.45f,-0.45f, 0.0f);
    glVertex3f(0.45f,0.45f,0.0f);
    glVertex3f(-0.45f,0.45f,0.0f);
    glEnd();

    glLineWidth(1.0f);
    glBegin(GL_LINES);  //mouse cross line
    glVertex3f(-1.9f,0, 0.0f);
    glVertex3f(1.9f,0, 0.0f);
    glVertex3f(0,-1.9f,0.0f);
    glVertex3f(0,1.9f,0.0f);

    glVertex3f(-1.9f,0, 0.0f);
    glVertex3f(0+1.9f,0, 0.0f);
    glVertex3f(0,-1.9f,0.0f);
    glVertex3f(0,1.9f,0.0f);
    glEnd();
    glLoadIdentity();
    return;
    if(mdx!=-1)
    {
        glColor4f(0.0f,1.0f,0.0f,0.3f);
        glBegin(GL_QUADS);
        glVertex3f(pu3.x,pu3.y, -10.0f);
        glVertex3f(pd3.x,pu3.y, -10.0f);
        glVertex3f(pd3.x,pd3.y, -10.0f);
        glVertex3f(pu3.x,pd3.y, -10.0f);
        glEnd();

        glLineWidth(1.5f);
        glColor4f(1.0f,0.0f,0.0f,1.0f);

        if(pu3.x&lt;pd3.x)SwapFolat(&amp;(pu3.x),&amp;(pd3.x));
        if(pu3.y&gt;pd3.y)SwapFolat(&amp;pu3.y,&amp;pd3.y);

        if((pu3.x-pd3.x&lt;2.0f)||(pd3.y-pu3.y&lt;2.0f))
        {
            glBegin(GL_LINE_LOOP);
            glVertex3f(pu3.x,pu3.y, -10.0f);
            glVertex3f(pd3.x,pu3.y, -10.0f);
            glVertex3f(pd3.x,pd3.y, -10.0f);
            glVertex3f(pu3.x,pd3.y, -10.0f);
            glEnd();
        }
        else
        {
            glBegin(GL_LINES);
            glVertex3f(pd3.x,pd3.y, -10.0f);
            glVertex3f(pd3.x+1,pd3.y, -10.0f);
            glVertex3f(pd3.x,pd3.y, -10.0f);
            glVertex3f(pd3.x,pd3.y-1, -10.0f);

            glVertex3f(pu3.x,pd3.y, -10.0f);
            glVertex3f(pu3.x-1,pd3.y, -10.0f);
            glVertex3f(pu3.x,pd3.y, -10.0f);
            glVertex3f(pu3.x,pd3.y-1, -10.0f);

            glVertex3f(pu3.x,pu3.y, -10.0f);
            glVertex3f(pu3.x-1,pu3.y, -10.0f);
            glVertex3f(pu3.x,pu3.y, -10.0f);
            glVertex3f(pu3.x,pu3.y+1, -10.0f);

            glVertex3f(pd3.x,pu3.y, -10.0f);
            glVertex3f(pd3.x+1,pu3.y, -10.0f);
            glVertex3f(pd3.x,pu3.y, -10.0f);
            glVertex3f(pd3.x,pu3.y+1, -10.0f);
            glEnd();

        }
    }
}

void DrawRectangSinWave()
{
    int i;
    glLoadIdentity();
    // Reset The Current Modelview Matrix
    glTranslatef(-1.5f+1.40*sin(3.14*3.0*Start/360.0),-1.6f,-4.0f);						// Move One Unit Into The Screen
    glColor4f(0.0f ,1.0f ,0.0f,0.3f );
    for(i=0; i&lt;8; i++)
    {
        glBegin(GL_QUADS);
        glVertex3f(-6.0+0.0f+i*2,-7.0f, 0.0f);
        glVertex3f(-6.0+1.2f+i*2,-7.0f, 0.0f);
        glVertex3f(-6.0+1.2f+i*2,8.5f+2*sin(i)*sin(3.14*3.0*Start/360.0),0.0f);
        glVertex3f(-6.0+0.0f+i*2,8.5f+2*sin(i)*sin(3.14*3.0*Start/360.0),0.0f);
        glEnd();
    }
}
void DrawFpsInfo()
{
    int i=0;
    //for(i=0; i&lt;15; i++)
    {
        glLoadIdentity();
        glColor4f(0.0f ,1.0f ,0.0f,1.0f );
        glTranslatef(imgX0+5,imgY1+0.5-i*1.2,0);
        glLineWidth(0.8f );
        //glRasterPos2f(imgX0+8,imgY1+1);
        int sec=(GetTickCount()-starttime)/1000;
        if(sec==0)sec=1;
        //glPrint(&quot; 示波器软件 OSCILLOSCOPE %03d [%03d,%03d]  fps:%03d&quot;,Start,mx,my,framecount/sec);	// Print GL Text To The Screen
        glScalef(0.04,0.04,1);
        glShxPrint(&quot;示波器软件  -- OSCILLOSCOPE %03d [%03d,%03d]  FPS:%03d&quot;,Start,mx,my,framecount/sec);	// Print GL Text To The Screen
    }


}


int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing
{
    int i,j;
    char s[40];
    if(closing) return 0;
    unsigned char dat;
    double ox=(offsetx+mux-mdx);
    double oy=(offsety+muy-mdy);

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer


    glBindTexture(GL_TEXTURE_2D, texture[0]);			// Select Our Texture
    Start+=1;
    Start%=720;

    DrawGrid();

    //DrawSinWave();
    if(dispWave)
    {
        for(i=0; i&lt;16; i++)
            if(DispChannel[i]==1)
                DrawDataWave(i,0,3+i*6,0,1,i);
    }
    if(dispHisto==1)
    {
        DrawHistogram(0,6,0,8,0,1,0);
        DrawHistogram(1,20,0,8,1,0,0);
        // DrawRectangDataWave(2,10,0,2,1,0,1);
    }

    DrawFrame();
    //DrawCube(-20.0f, 9.0f,0.0f,0.5f);
    //DrawCube(-18.0f, 9.0f,0.0f,0.5f);
    //RoundRect1(40.0, 10.0, 20.0, 25.0,25.0, 26.0,26.0);
    //DrawRectangSinWave();
    DrawFpsInfo();
    ////////glDisable(GL_BLEND);
    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_POLYGON_SMOOTH);
    //glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
    glLineWidth(1.0f);

    if(dispClock)
    {
        DrawClock(-8,0.01,0,   0.5,0.5,1.0,6.7,7.85,&quot; CH01&quot;,waveData[0][waveDataCount[0]]);
        DrawClock(10 ,0.01  ,0,1,1,1,6.7,7.85,&quot; CH02&quot;,waveData[1][waveDataCount[1]]);

        //DrawClock(-2,-1,0, 1.0,0,0,4.11,4.61);
        //DrawClock(7.0,3,0, 0.0,1,0,4.11,4.61);
    }
    if(dispDigit)
    {
        dat=waveData[0][waveDataCount[0]];
        Draw7Seg((dat%1000)/100,-19+0*6.0  ,-6.8, 0, 1.35, 0,1,0,0.3,4.0,0.6,0.1);
        Draw7Seg((dat%100)/10,  -19+1*6.0  ,-6.8, 0, 1.35, 0,1,0,0.3,4.0,0.6,0.1);
        Draw7Seg((dat%10)/1,    -19+2*6.0  ,-6.8, 0, 1.35, 0,1,0,0.3,4.0,0.6,0.1);

        dat=waveData[1][waveDataCount[0]];
        Draw7Seg((dat%1000)/100, 1+0*6.0  ,-6.8, 0, 1.35, 1,0,0,0.5,4.0,0.6,0.1);
        Draw7Seg((dat%100)/10,   1+1*6.0  ,-6.8, 0, 1.35, 1,0,0,0.5,4.0,0.6,0.1);
        Draw7Seg((dat%10)/1,     1+2*6.0  ,-6.8, 0, 1.35, 1,0,0,0.5,4.0,0.6,0.1);
    }

    DrawMouseCursor();
    framecount++;


    SwapBuffers(hdc);



    return TRUE;//										// Everything Went OK
}




void OnTest()
{

    DispChannel[0]= GetProperty(cbDisp1,&quot;checked&quot;,0,0);

    DispChannel[1]= GetProperty(cbDisp2,&quot;checked&quot;,0,0);
    NeedRedraw=1;

}
void OnResize()
{
    int x,y;
    x=GetProperty(pfm,&quot;width&quot;,0,0);
    y=GetProperty(pfm,&quot;height&quot;,0,0);
    ReSizeGLScene(x,y);
    wd=x;
    ht=y;
    //printf(&quot;%d&quot;,wd);
    NeedRedraw=1;
}

void OnMouseWheel(int id, int state,int wheelDelta,int pos,int handled)
{


    zoom+= -wheelDelta/12000.0*4.0;

    if(zoom&lt;0.1)zoom=0.1;
    //glViewport(0-winwidth*(zoom-1.0)*0.5, 0-winheight*(zoom-1.0)*0.5, (GLsizei)winwidth*zoom, (GLsizei)winheight*zoom);
    //printf(&quot;mouse wheel:%d,%f&quot;,wheelDelta,zoom);
    ResizeGl();   NeedRedraw=1;
    //glMatrixMode(GL_PROJECTION);
    //glLoadIdentity();

    //glScalef(0.045*zoom,0.1*zoom,0.1);
    //glTranslatef(0.06*(offsetx+mux-mdx)/zoom ,0.06*(offsety+mdy-muy)/zoom,0.1);


    //SetProperty(pfm,&quot;caption&quot;,s);
    //glMatrixMode(GL_MODELVIEW);

}
void OnMouseMove(int id,int state,int x,int y)
{
    int h=0;
    int h1=0;
    if(GuiMode==2)
    {
        //h=GetSystemMetrics(SM_CYCAPTION);
        //h1=GetSystemMetrics(SM_CXFRAME);
    }
    mx=x;
    my=y;
    if(md)
    {
        mux=mx;
        muy=my;
        OnMouseWheel(0,0,0,0,0);
    }
    NeedRedraw=1;
}
void OnMouseDown(int id,int btn,int state,int x,int y)
{
    mdx=x;
    mdy=y;
    if(GuiMode!=2) mdy+=30;
    mux=x;
    muy=y;
    if(GuiMode!=2) muy+=30;
    md=1;
    NeedRedraw=1;
    mx=x;
    my=y;
}
void OnMouseUp(int id,int btn,int state,int x,int y)
{

    mux=x;
    muy=y ;
    if(GuiMode!=2) muy+=30;
    md=0;
    NeedRedraw=1;
    offsetx+=mux-mdx;
    offsety-=mdy-muy;
    mx=x;
    my=y;
    mdx=mux;
    mdy=muy;
}



void AddWaveDataByte(int channel,unsigned char dat)
{
    waveDataCount[channel]++;
    waveDataCount[channel]%=maxWaveCount;
    waveData[channel][waveDataCount[channel]]=dat;//*0.015f;

    NeedRedraw=1;
}

void AddWaveDataBuf(int channel,unsigned char *buf,int count)
{
    int i;
    for(i=0; i&lt;count; i++)
    {
        waveDataCount[channel]++;
        waveDataCount[channel]%=maxWaveCount;
        waveData[channel][waveDataCount[channel]]=buf[i];//*0.015f;

    }
    NeedRedraw=1;
}
void OnPaint()
{
    NeedRedraw=1;
}
int RandVal(int max)
{
    return 1+(int)(max*1.0*rand()/(RAND_MAX+1.0));
}
void OnTimer()
{
    int i;
    double si;
    unsigned char dat;
    if(closing) return;
    //for(i=0; i&lt;2; i++)
    //   AddWaveDataByte(0,RandVal(255));

    for(i=0; i&lt;2; i++)
    {
        si= 127+127.0*sin(3.1415*(framecount%201)/100);
        AddWaveDataByte(1,si);
        AddWaveDataByte(0,255-si);
        //printf(&quot;%f&quot;,200.0*sin(3.1415*(framecount%41)/20));
    }

    for(i=0; i&lt;2; i++)
        AddWaveDataByte(2,RandVal(255));
    //printf(&quot;a&quot;);
}
void OnSimDat()
{
    int i;
    if(GetProperty(cbSimDat,&quot;checked&quot;,0,0)==1)
        SetProperty(tmrSimDat,&quot;enabled&quot;,1);
    else
    {
        SetProperty(tmrSimDat,&quot;enabled&quot;,0);
        for(i=0; i&lt;1024; i++)
        {
            AddWaveDataByte(0,0);
            AddWaveDataByte(1,0);
        }
    }


}
void OnXScaleClick(int sender)
{
    xscale=GetProperty(tbxscale,&quot;Position&quot;,0,0);
    maxWaveCount=(imgX1-imgX0) *(6.0-xscale/10.0);

    yscale=GetProperty(tbyscale,&quot;Position&quot;,0,0);
    bkColor=GetProperty(tbbkclr,&quot;Position&quot;,0,0);
    dispHisto=GetProperty(cbHisto,&quot;checked&quot;,0,0);
    dispClock=GetProperty(cbClock,&quot;checked&quot;,0,0);
    dispDigit=GetProperty(cbDigit,&quot;checked&quot;,0,0);
    dispWave=GetProperty(cbWave,&quot;checked&quot;,0,0);
    //printf(&quot;maxWaveCount:%d&quot;,maxWaveCount);

    if(sender==cbClock)
    {
        if(dispClock==1)
            SetProperty(tbbkclr,&quot;Position&quot;,30,0);
    }
    else
    {
        if((sender==cbHisto)||(sender==cbDigit)||(sender==cbWave))
            SetProperty(tbbkclr,&quot;Position&quot;,1,0);
    }

    DrawGLScene();
}
void main()
{

    int i,j;
    int mi,mi1;
    double tmp;
    //HideLeftTools();
    ClearVclControls();
    GuiMode=2;
    //HideVclWin(-1);
    if((GuiMode==0)||(GuiMode==1))
    {
        pfm=GetGuiWin(GuiMode);
        pfm=CreateComponentEx(pfm,&quot;panel&quot;,&quot;caption&quot;,&quot;示波器&quot;,&quot;Width&quot;,900,&quot;height&quot;,400,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;cursor&quot;,-1,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,&quot;OnMouseDown&quot;,OnMouseDown,&quot;OnMouseUp&quot;,OnMouseUp,&quot;OnMouseMove&quot;,OnMouseMove,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
        pfm0=pfm;
    }
    else
    {
        pfm0=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;示波器&quot;,&quot;Width&quot;,900,&quot;height&quot;,400,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnPaint&quot;,OnPaint,&quot;OnMouseWheel&quot;,OnMouseWheel,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
        pfm=CreateComponentEx(pfm0,&quot;panel&quot;,&quot;caption&quot;,&quot;示波器&quot;,&quot;Left&quot;,10,&quot;top&quot;,10,&quot;Width&quot;,800,&quot;height&quot;,380,&quot;Anchors&quot;,&quot;[akLeft,akTop,akRight,akBottom]&quot;,&quot;cursor&quot;,-1, &quot;OnMouseDown&quot;,OnMouseDown,&quot;OnMouseUp&quot;,OnMouseUp,&quot;OnMouseMove&quot;,OnMouseMove,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
        //pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;示波器&quot;,&quot;Width&quot;,900,&quot;height&quot;,400,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;cursor&quot;,-1,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,&quot;OnMouseDown&quot;,OnMouseDown,&quot;OnMouseUp&quot;,OnMouseUp,&quot;OnMouseMove&quot;,OnMouseMove,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
        //pfm0=pfm;
    }
    //int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    tmrSimDat=CreateComponentEx(pfm0,&quot;timer&quot;,&quot;interval&quot;,25,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    cbDisp1=CreateComponentEx(pfm0,&quot;CheckBox&quot;,&quot;caption&quot;,&quot;通道1&quot;,&quot;left&quot;,820,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;checked&quot;,1,&quot;OnClick&quot;,OnTest,0);
    cbDisp2=CreateComponentEx(pfm0,&quot;CheckBox&quot;,&quot;caption&quot;,&quot;通道2&quot;,&quot;left&quot;,820,&quot;top&quot;,25,&quot;width&quot;,60,&quot;height&quot;,20,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;checked&quot;,0,&quot;OnClick&quot;,OnTest,0);
    cbSimDat=CreateComponentEx(pfm0,&quot;CheckBox&quot;,&quot;caption&quot;,&quot;模拟数据&quot;,&quot;left&quot;,820,&quot;top&quot;,45,&quot;width&quot;,60,&quot;height&quot;,20,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;checked&quot;,1,&quot;OnClick&quot;,OnSimDat,0);

    CreateComponentEx(pfm0,&quot;label&quot;,&quot;left&quot;,820,&quot;top&quot;,80,&quot;width&quot;,80,&quot;height&quot;,20,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;caption&quot;,&quot;X轴比例：&quot;,0);
    tbxscale=CreateComponentEx(pfm0,&quot;TrackBar&quot;,&quot;left&quot;,810,&quot;top&quot;,95,&quot;width&quot;,80,&quot;height&quot;,20,&quot;max&quot;,50,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;OnChange&quot;,OnXScaleClick,0);

    CreateComponentEx(pfm0,&quot;label&quot;,&quot;left&quot;,820,&quot;top&quot;,125,&quot;width&quot;,80,&quot;height&quot;,20,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;caption&quot;,&quot;Y轴比例：&quot;,0);
    tbyscale=CreateComponentEx(pfm0,&quot;TrackBar&quot;,&quot;left&quot;,810,&quot;top&quot;,140,&quot;width&quot;,80,&quot;height&quot;,20,&quot;max&quot;,50,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;OnChange&quot;,OnXScaleClick,0);

    CreateComponentEx(pfm0,&quot;label&quot;,&quot;left&quot;,820,&quot;top&quot;,170,&quot;width&quot;,80,&quot;height&quot;,20,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;caption&quot;,&quot;背景亮度：&quot;,0);
    tbbkclr=CreateComponentEx(pfm0,&quot;TrackBar&quot;,&quot;left&quot;,810,&quot;top&quot;,185,&quot;width&quot;,80,&quot;height&quot;,20,&quot;max&quot;,50,&quot;position&quot;,0,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;OnChange&quot;,OnXScaleClick,0);

    cbWave=CreateComponentEx(pfm0,&quot;radiobutton&quot;,&quot;caption&quot;,&quot;波形图&quot;,&quot;left&quot;,820,&quot;top&quot;,215,&quot;width&quot;,60,&quot;height&quot;,20,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;checked&quot;,1,&quot;OnClick&quot;,OnXScaleClick,0);

    cbHisto=CreateComponentEx(pfm0,&quot;radiobutton&quot;,&quot;caption&quot;,&quot;柱状图&quot;,&quot;left&quot;,820,&quot;top&quot;,235,&quot;width&quot;,60,&quot;height&quot;,20,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;checked&quot;,0,&quot;OnClick&quot;,OnXScaleClick,0);
    cbClock=CreateComponentEx(pfm0,&quot;radiobutton&quot;,&quot;caption&quot;,&quot;仪表盘&quot;,&quot;left&quot;,820,&quot;top&quot;,255,&quot;width&quot;,60,&quot;height&quot;,20,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;checked&quot;,0,&quot;OnClick&quot;,OnXScaleClick,0);
    cbDigit=CreateComponentEx(pfm0,&quot;radiobutton&quot;,&quot;caption&quot;,&quot;数值显示&quot;,&quot;left&quot;,820,&quot;top&quot;,275,&quot;width&quot;,80,&quot;height&quot;,20,&quot;Anchors&quot;,&quot;[akTop,akRight]&quot;,&quot;checked&quot;,0,&quot;OnClick&quot;,OnXScaleClick,0);

    maxWaveCount=(imgX1-imgX0)*6;
    FormCreate();
    OnResize();
    InitGL();
    sfHz=CreateShxFont(&quot;dat\\HZTXT.SHX&quot;);
    sfHz-&gt;scale=1.50;//

    //printf(&quot;hz scale:%f&quot;,GetShxFontScale(sfHz));
    //sfChar=CreateShxFont(&quot;dat\\IC-italicc.shx&quot;);
    //sfChar=CreateShxFont(&quot;dat\\HAND1.SHX&quot;);
    //sfChar=CreateShxFont(&quot;dat\\gdt.SHX&quot;);
    sfChar=CreateShxFont(&quot;dat\\txt.SHX&quot;);
    DrawGLScene();
    starttime=GetTickCount();
    SetProperty(pfm0,&quot;visible&quot;,1);
    SetProperty(pfm,&quot;OnMouseMove&quot;,OnMouseMove);
    OnXScaleClick(0);
    OnTest();
    //ClearOutputWin();
    int count=0;
    while(!closing)
    {
        if(NeedRedraw)
        {
            NeedRedraw=0;
            DrawGLScene();
        }
        //sleep(1);
        count++;
        if(count%2==1)
        {
            Wait(1);
        }
    }
    SetProperty(tmrSimDat,&quot;enabled&quot;,0);
    OnClose();
    KillFont();
    wglMakeCurrent(NULL,NULL);
    wglDeleteContext(hglrc);
    DeleteObject(hdc);
    FreeShxFont(sfChar);
    FreeShxFont(sfHz);
    printf(&quot;exit&quot;);
}

void MainFormClose()
{

    closing=1;
    Wait(2);
}
void OnTerminate()
{
    closing=1;
    printf(&quot;terminate&quot;);
    Wait(2);
}

"/>
    <Command cmdname="数据示波器" cmdType="P" cmd="[P]#pragma comment(lib,&quot;lib\\oscilloscope.o&quot;)
#pragma comment(lib,&quot;lib\\ftgl.def&quot;);
void RecvSerialData(unsigned char *buf,int count)//串口接收到数?
{
    int i;
    //for(i=0; i&lt;count; i++)
    //    AddWaveDataByte(0,buf[i]);
    AddWaveDataBuf(0,buf,count);
}
void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    AddWaveDataBuf(0,buf,count);
}

void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    AddWaveDataBuf(0,buf,count);
}













"/>
  </Command>
  <Command cmdname="嵌入式开发" cmdType="S" cmd="[S]=====数据发送区/C语言脚本编辑区=====
1.[F5]键发送/执行、[F4]键终止脚本运行。
2.[F8]键显示、隐藏输出栏。
3.[Ctrl+.]调出脚本接口函数列表、[Ctrl+/]提示函数参数信息、[Ctrl+P]列出代码模板。
4.[Ctrl+Enter]发送数据。
5.支持&quot;预处理&quot;功能，采用C语言脚本回调函数，对发送的数据进行预处理后发送。">
    <Command cmdname="2410/2440 DNW" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
void OpenFileClick(void *sender);
void DownLoadClick(void *sender);
void CancelClick(void *sender);
void AddFileToLv(unsigned char* s,unsigned char *time,int save);
void UpdateLv();
int edt1;
int cancel;
int pgb1;
int txt6;
int edt2;
int tmr1;
int txt2,btn2,btn3,lv;
int cb1;

char *sIID=&quot;{8e120c45-4968-4188-ba19-9a82361c8fa8}&quot;;//usb 驱动程序 IID
#include &quot;windows.h&quot;
void DropFileFromTFtpServer(char* filename)
{
    char s[200];
    printf(&quot;get tftp file:%s&quot;,filename);
    sprintf(s,&quot;tftp -g -r %s 192.168.11.2&quot;,filename);
#if 0
    if(MessageBox(GetAppHandle(),s,&quot;是否执行命令？&quot;,4)==6)
#endif
        SendString(s);
}
void DropFileToTFtpServer(char* filename)
{
    char s[200];
    printf(&quot;Send tftp file:%s&quot;,filename);
    sprintf(s,&quot;tftp -p -l %s 192.168.11.2&quot;,filename);
#if 0
    if(MessageBox(GetAppHandle(),s,&quot;是否执行命令？&quot;,4)==6)
#endif
        SendString(s);
}
void CommWinDbClick()
{
    char s[100];
    char s1[20];
    int len1=-1;
    int i;

    int len=GetCommWinSelText(s,100);

    int ck= GetProperty(cb1,&quot;checked&quot;,NULL,0);
    //printf(&quot;checked:%d&quot;,ck);
    if(ck==0)return;
    for(i=0; i&lt;len; i++)
    {
        if(len1==-1)
        {
            if((s[i]&gt;='0')&amp;&amp;(s[i]&lt;='9'))
            {
                len1=0;
                s1[len1++]=s[i];
            }
        }
        else
        {
            if((s[i]&gt;='0')&amp;&amp;(s[i]&lt;='9'))
            {
                s1[len1++]=s[i];
                if(len1&gt;10)break;
            }
            else break;
        }
    }

    printf(&quot;len:%d-[%s]&quot;,len,s);
    if(len1&gt;0)
    {
        s1[len1]=0;
        len1=atoi(s1);
        printf(s1);
        printf(&quot;%d&quot;,len1);
        sprintf(s,&quot;数据内容:[%s]&quot;,s1);
#if 0
        int opt=MessageBox(GetAppHandle(),s,&quot;是否发送数据？&quot;,4);
        printf(&quot;opt:%d&quot;,opt);
        if(opt==6)
#endif
            SendString(s1);

    }
}
void DownLoad()
{
    char s[200];
    CHAR *pBuffer;
    DWORD RSize;
    int fileSize = 0;
    int i;
    cancel=0;
    SetProperty(btn2,&quot;enabled&quot;,0);
    SetProperty(btn3,&quot;enabled&quot;,1);
    SetProperty(pgb1,&quot;position&quot;,0);
    SetProperty(txt6,&quot;caption&quot;,&quot;0%&quot;);

    int iTmp=GetPathName(sIID,s,200);

    if(iTmp&gt;0)  //devName~=&quot;&quot; then
        printf(&quot;Usb device PathName:%s&quot;,s);
    else
    {
        ShowMessage(&quot;Usb host not connected!&quot;);
        return ;
    }
    sprintf(s,&quot;%s\\\\PIPE01&quot;,s);
    printf(&quot;usb name:%s&quot;,s);

    HANDLE Handle=CreateFile(s, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    if (Handle&lt;=0)
    {
        printf(&quot;打开文件%s错误！&quot;,s);
        return;
    }
    GetProperty(edt1,&quot;text&quot;,s,200);
    SaveIniString(&quot;DNW&quot;,&quot;FileName&quot;,s);
    AddFileToLv(s,0,1);
    GetProperty(edt2,&quot;text&quot;,s,200);
    SaveIniString(&quot;DNW&quot;,&quot;Address&quot;,s);
    GetProperty(edt1,&quot;text&quot;,s,200);

    HANDLE Handle1=CreateFile(s, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);

    printf(&quot;发送文件名称：%s&quot;,s);

    if(Handle1&lt;=0)
    {
        sprintf(s,&quot;打开文件【%s】错误！&quot;,s);
        ShowMessage(s);//&quot;打开文件【&quot;..pb.edit1.text..&quot;】错误！&quot;);
        return  ;
    }

    int Length =SetFilePointer(Handle1,0,NULL,FILE_END);
    SetFilePointer(Handle1,0,NULL,FILE_BEGIN);
    char *Buffer = malloc(Length + 10);  //   --addr(4bytes)+length(4bytes)+filedata(length bytes)+checksum(2bytes)
    int BytesRead ;
    ReadFile(Handle1, Buffer+8, Length,&amp;BytesRead,NULL);
    CloseHandle(Handle1);
    GetProperty(edt2,&quot;text&quot;,s,200);
    int downloadAddress=StrToInt(s); //0x32000000;

    printf(&quot;Address:0x%x&quot;,downloadAddress);
    Buffer[0]=(downloadAddress&gt;&gt;0)&amp;0xff;
    Buffer[1]=(downloadAddress&gt;&gt;8)&amp;0xff;
    Buffer[2]=(downloadAddress&gt;&gt;16)&amp;0xff;
    Buffer[3]=(downloadAddress&gt;&gt;24)&amp;0xff;
    int len1=Length+10;
    Buffer[4]=(len1&gt;&gt;0)&amp;0xff;
    Buffer[5]=(len1&gt;&gt;8)&amp;0xff;
    Buffer[6]=(len1&gt;&gt;16)&amp;0xff;
    Buffer[7]=(len1&gt;&gt;24)&amp;0xff;

    unsigned short cs=0;
    for(i=0; i&lt;Length; i++)
    {
        cs+=Buffer[8+i];      //  计算校验和
    }
    cs&amp;=0xffff; //                               --取16bits
    printf(&quot;check sum is :%x&quot;,cs);
    Buffer[Length+8]=(cs&gt;&gt;0)&amp;0xff;
    Buffer[Length+9]=(cs&gt;&gt;8)&amp;0xff;
    Length=Length+10;//addr(4bytes)+length(4bytes)+filedata(length bytes)+checksum(2bytes)
    int TxBufCount=0;
    int txBlkSize=0;
    int TX_SIZE=4096*4;
    int BytesWrite ;
    printf(&quot;Download to device ...&quot;);
    Update();
    while(1)
    {
        if (cancel==1)break;
        if((Length-TxBufCount) &gt; TX_SIZE)
            txBlkSize =TX_SIZE;
        else
            txBlkSize = Length-TxBufCount;

        //printf(&quot;filewrite:%d...&quot;, txBlkSize);
        int wlen=WriteFile( Handle, Buffer+TxBufCount, txBlkSize, &amp;BytesWrite,NULL);
        //printf(&quot;wrote %d&quot;,BytesWrite);
        if(BytesWrite&lt;=0)
        {
            printf(&quot;下载失败，请重新启动开发板！&quot;);
            CloseHandle(Handle);
            free(Buffer);
            return;
        };

        TxBufCount =TxBufCount+txBlkSize;
        float fPer=1.0f;
        //fPer=
        int per=((TxBufCount+1)*100)/Length;
        SetProperty(pgb1,&quot;position&quot;,per);
        sprintf(s,&quot;%d%s&quot;,per,&quot;%&quot;);
        SetProperty(txt6,&quot;caption&quot;,s);
        Update();
        //printf(&quot;write %d of %d:%d%&quot;,TxBufCount,Length,per);
        if (TxBufCount&gt;=  Length) break;
        Wait(0);
    };
    printf(&quot;close file ...&quot;);
    CloseHandle(Handle);
    printf(&quot;free mem ...&quot;);
    free(Buffer);
    printf(&quot;Download end&quot;);
    SetProperty(btn2,&quot;enabled&quot;,1);
    SetProperty(btn3,&quot;enabled&quot;,0);
}



void OnTimer()
{
    char s[200];
    //printf(&quot;aaa&quot;);
    int iTmp=GetPathName(sIID,s,200);
    //printf(&quot;bbb&quot;);
    if(iTmp&gt;0)  //devName~=&quot;&quot; then
    {
        //printf(&quot;Usb device PathName:%s&quot;,s);
        SetProperty(txt2,&quot;caption&quot;,&quot;   USB:OK&quot;);
        SetProperty(txt2,&quot;color&quot;,0x00ff00);
        SetProperty(btn2,&quot;enabled&quot;,1);
    }
    else
    {
        //printf(&quot;Usb device PathName:%s&quot;,s);
        SetProperty(txt2,&quot;caption&quot;,&quot;   USB:x&quot;);
        SetProperty(txt2,&quot;color&quot;,0x0000ff);
        SetProperty(btn2,&quot;enabled&quot;,0);
    }
    //printf(&quot;ccc&quot;);
    UpdateLv();
    //printf(&quot;ddd&quot;);
}

void Save()
{
    int i;
    char s1[200],s2[200];
    int count=GetListViewItemCount(lv);
    sprintf(s1,&quot;%d&quot;,count);
    SaveIniString(&quot;DNW&quot;,&quot;FileCount&quot;,s1);
    for(i=0; i&lt;count; i++)
    {
        GetListViewItem(lv,i,2,s1,200);
        sprintf(s2,&quot;FileName%d&quot;,i);
        SaveIniString(&quot;DNW&quot;,s2,s1);

        GetListViewItem(lv,i,0,s1,200);
        sprintf(s2,&quot;FileDt%d&quot;,i);
        SaveIniString(&quot;DNW&quot;,s2,s1);
    }
}

void KeyBtnClick(void *Sender)
{
    int tag,t;
    t=GetProperty(Sender,&quot;tag&quot;,&amp;tag,4);
    printf(&quot;tag:%d&quot;,t);
    SendByte(t);
}
void DelClick(void *Sender)
{
    int idx;
    idx=GetListViewItemIndex(lv);
    DelListViewItem(lv,idx);
    Save();
}
void ClearClick(void *Sender)
{
    while(GetListViewItemCount(lv)&gt;0)
        DelListViewItem(lv,0);
    Save();
}
void lvDbClick(void *Sender)
{
    int idx;
    char s1[200];
    idx=GetListViewItemIndex(lv);

    GetListViewItem(lv,idx,2,s1,200);
    SetProperty(edt1,&quot;text&quot;,s1);

}
void CloseClick(void *Sender)
{
    //UpdateLv();
    //return;
    ClearOutputWin();   //清除输出窗口内容

    HideVclWin();
    // printf(&quot;hided&quot;);
    CloseVclWin();
}

void main()
{
    ClearOutputWin();   //清除输出窗口内容
    //ClearCommWin();

    CloseInputWin();
    ClearVclControls();
    printf(&quot;=============SAMSUNG S3C2410/2440 USB 下载工具(DNW)==============&quot;);
    int p=GetGuiWin();
    int pnl = CreateComponentEx(p,&quot;panel&quot;,&quot;caption&quot;,&quot;&quot;,&quot;left&quot;,2,&quot;top&quot;,2,&quot;width&quot;,650,&quot;height&quot;,230,NULL);
    int txt1= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;                  SAMSUNG S3C2410/2440 USB 下载工具(DNW)&quot;,&quot;left&quot;,30,&quot;top&quot;,10,&quot;width&quot;,350,&quot;color&quot;,0xff00ff,NULL);
    txt2= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;   USB:x&quot;,&quot;left&quot;,385,&quot;top&quot;,10,&quot;width&quot;,60,&quot;autosize&quot;,0,&quot;color&quot;,0x0000ff,NULL);
    int txt3= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;文件名称：&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,60,NULL);
    edt1= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;请输入文件名...&quot;,&quot;left&quot;,75,&quot;top&quot;,38,&quot;width&quot;,385,NULL);

    int txt4= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;下载地址：&quot;,&quot;left&quot;,10,&quot;top&quot;,68,&quot;width&quot;,60,NULL);
    edt2= CreateComponentEx(pnl,&quot;edit&quot;, &quot;text&quot;,&quot;0x32000000&quot;,&quot;left&quot;,75,&quot;top&quot;,65,&quot;width&quot;,90,NULL);

    int txt5= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;下载进度：&quot;,&quot;left&quot;,170,&quot;top&quot;,68,&quot;width&quot;,60,NULL);
    txt6= CreateComponentEx(pnl,&quot;label&quot;,&quot;caption&quot;,&quot;0%&quot;,&quot;left&quot;,228,&quot;top&quot;,68,&quot;width&quot;,40,NULL);
    pgb1= CreateComponentEx(pnl,&quot;progressbar&quot;,&quot;left&quot;,258,&quot;top&quot;,65,&quot;width&quot;,200,&quot;height&quot;,20,&quot;position&quot;,0,NULL);
    cb1= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;left&quot;,460,&quot;top&quot;,65,&quot;width&quot;,90,&quot;height&quot;,20,&quot;caption&quot;,&quot;双击直接操作&quot;,NULL);



    int btn1= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,&quot;left&quot;,465,&quot;top&quot;,36,&quot;width&quot;,65,&quot;onclick&quot;,OpenFileClick,NULL);
    btn2= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;通过USB下载&quot;,&quot;left&quot;,535,&quot;top&quot;,10,&quot;width&quot;,105,&quot;height&quot;,50,&quot;onclick&quot;,DownLoadClick,NULL);
    btn3= CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;取  消&quot;,&quot;left&quot;,555,&quot;top&quot;,65,&quot;width&quot;,85,&quot;onclick&quot;,CancelClick,NULL);

    CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;删  除&quot;,&quot;left&quot;,555,&quot;top&quot;,110,&quot;width&quot;,85,&quot;onclick&quot;,DelClick,NULL);
    CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;清  空&quot;,&quot;left&quot;,555,&quot;top&quot;,140,&quot;width&quot;,85,&quot;onclick&quot;,ClearClick,NULL);
    CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;关  闭&quot;,&quot;left&quot;,555,&quot;top&quot;,190,&quot;width&quot;,85,&quot;onclick&quot;,CloseClick,NULL);
    int key_left=370;
    int key_top=10;


    lv=CreateComponentEx(pnl,&quot;listview&quot;,&quot;left&quot;,12,&quot;top&quot;,95,&quot;width&quot;,540,&quot;height&quot;,125,&quot;ondblclick&quot;,lvDbClick,NULL);
    AddListViewColumn(lv,&quot;更新&quot;,40);
    AddListViewColumn(lv,&quot;下载时间&quot;,115);
    AddListViewColumn(lv,&quot;更新时间&quot;,115);
    AddListViewColumn(lv,&quot;文件名称&quot;,880);


    tmr1=CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,1000,&quot;enabled&quot;,0,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    //ShowVclWin(230+8);
    //ShowOutputWin(330);
    CloseCodeWin();
    HideLeftTools();
    HideRightTools();
    ShowTerminalWin();
    PrintToCommWin(&quot; &quot;);
    PrintToCommWin(&quot; &quot;);
    //PrintToCommWin(&quot;                                                 &quot;);
    //PrintToCommWin(&quot;                                                   &quot;);
    //PrintToCommWin(&quot;                                                 &quot;);
    //PrintToCommWin(&quot;                                               &quot;);
    //PrintToCommWin(&quot;                                                     &quot;);
    //PrintToCommWin(&quot;                                           &quot;);
    /**/
    char s[200],s1[200],s2[200];
    GetIniString(&quot;DNW&quot;,&quot;FileName&quot;,s,200);
    SetProperty(edt1,&quot;text&quot;,s);
    GetIniString(&quot;DNW&quot;,&quot;Address&quot;,s,200);
    SetProperty(edt2,&quot;text&quot;,s);
    AutoSetVclWinSize();
    //printf(&quot;1...&quot;);
    GetIniString(&quot;DNW&quot;,&quot;FileCount&quot;,s,200);

    //printf(&quot;2...&quot;);
    //printf(&quot;s:%s&quot;,s);
    if(strlen(s)&gt;0)
    {
        int count=StrToInt(s);
        //printf(&quot;2.1&quot;);
        int i;
        for(i=0; i&lt;count; i++)
        {
            //printf(&quot;2.i:%d&quot;,i);
            sprintf(s2,&quot;FileName%d&quot;,i);
            GetIniString(&quot;DNW&quot;,s2,s,200);
            sprintf(s2,&quot;FileDt%d&quot;,i);
            GetIniString(&quot;DNW&quot;,s2,s1,200);
            AddFileToLv(s,s1,0);
        }
    }

    //printf(&quot;3...&quot;);
    UpdateLv();

    char *IID=&quot;{8e120c45-4968-4188-ba19-9a82361c8fa8}&quot;;//usb 驱动程序 IID
    SetProperty(btn2,&quot;enabled&quot;,0);
    int addCount=0;
    SetProperty(tmr1,&quot;enabled&quot;,1);

    DragAcceptFiles(GetWinHandle(lv),1);
    DragAcceptFiles(GetWinHandle(edt1),1);

    SetMenuItemText(0,&quot;tftp 快速传输&quot;);

    printf(&quot;inited&quot;);
}


void MenuItemClick(int idx)
{
    printf(&quot;MenuItem %d clicked!&quot;,idx);
    if(idx==0)
    {
        char s[100];
        int len=GetCommWinSelText(s,100);
        char buf[100];
        sprintf(buf,&quot;tftp -s -l ./%s 192.168.11.2\n&quot;,s);
        SendString(buf);
    }
}
void DropFile(int handle,unsigned char *filename)
{
    if(handle==GetWinHandle(edt1))
    {
        SetProperty(edt1,&quot;text&quot;,filename);
        SaveIniString(&quot;DNW&quot;,&quot;FileName&quot;,filename);
    }
    else if(handle==GetWinHandle(lv))
    {
        AddFileToLv(filename,0,1);
    }
    //printf(&quot;handle:%x,filename:%s&quot;,hd,filename);
}

void AddFileToLv(unsigned char* s,unsigned char *time,int save)
{
    char s1[200],s2[200];
    int i,idx;
    idx=-1;

    int count=GetListViewItemCount(lv);
    for(i=0; i&lt;count; i++)
    {
        GetListViewItem(lv,i,2,s1,200);
        if(strcmp(s,s1)==0)
        {
            idx=i;
            break;
        }
    }
    if(idx==-1)
    {
        StringsAdd(lv,&quot;&quot;);
        idx=GetListViewItemCount(lv)-1;
    }
    if(time!=0)
    {
        SetListViewItem(lv,idx,0,time);
    }
    else
    {
        GetDateTimeStr(s1,50);
        SetListViewItem(lv,idx,0,s1);
    }
    GetFileWriteTime(s,s1,200);


    SetListViewItem(lv,idx,1,s1);//&quot;2011-05-12 16:23:56&quot;);
    SetListViewItem(lv,idx,2,s);

    if(save)
        Save();
}
void UpdateLv()
{
    char s1[200],s2[200];
    char fn[200];
    int i,idx;
    idx=-1;

    int count=GetListViewItemCount(lv);
    for(i=0; i&lt;count; i++)
    {

        GetListViewItem(lv,i,0,s1,200);
        GetListViewItem(lv,i,2,fn,200);
        GetFileWriteTime(fn,s2,200);
        SetListViewItem(lv,i,1,s2);
        //printf(&quot;%s ,%s&quot;,s1,s2);
        if(strcmp(s1,s2)&lt;0)
        {
            SetListViewItem(lv,i,-1,&quot; Y&quot;);
        }
        else
            SetListViewItem(lv,i,-1,&quot; &quot;);
    }
}


void OpenFileClick(void *sender)
{
    char s[200];
    GetFileName(s,200,&quot;*.*&quot;);
    if(strlen(s)&gt;0)
    {
        SetProperty(edt1,&quot;text&quot;,s);
        SaveIniString(&quot;DNW&quot;,&quot;FileName&quot;,s);
    }
    SetFocusToCommWin();
}
void DownLoadClick(void *sender)
{
    DownLoad();
    SetFocusToCommWin();
}
void CancelClick(void *sender)
{
    //char s[100];
    cancel=1;
    //GetProperty(edt1,&quot;text&quot;,s,100);
    //AddFileToLv(s,0,1);
}

"/>
    <Command cmdname="GPRS的AT命令应用" cmdType="S" cmd="[S]new command">
      <Command cmdname="MC55 GPRS" cmdType="S" cmd="[S]none">
        <Command cmdname="TEXT方式发短信" cmdType="S" cmd="[S][E][E][E][E]none">
          <Command cmdname="取消指令回显" cmdType="S" cmd="[S]ATE0"/>
          <Command cmdname="打开指令回显" cmdType="S" cmd="[S]ATE1"/>
          <Command cmdname="设置TEXT方式发送短消息" cmdType="S" cmd="[S]AT+CMGF=1"/>
          <Command cmdname="设置端消息中心" cmdType="S" cmd="[S]AT+CSCA=&quot;+8613800551500&quot;"/>
          <Command cmdname="发出短消息(ctrl^Z) " cmdType="H" cmd="[H]1a"/>
        </Command>
        <Command cmdname="读出所有短信" cmdType="S" cmd="[S]AT+CMGL=&quot;ALL&quot;"/>
        <Command cmdname="打电话" cmdType="S" cmd="[S]ATD13905699792"/>
        <Command cmdname="Socket通讯" cmdType="S" cmd="[S][E][E][E][E]none">
          <Command cmdname="AT测试" cmdType="S" cmd="[S]AT"/>
          <Command cmdname="获取本机号码" cmdType="S" cmd="[S]AT+CNUM"/>
          <Command cmdname="查看信号强度" cmdType="S" cmd="[S]at+csq"/>
          <Command cmdname="设置连接方式" cmdType="S" cmd="[S]at^sics=0,conType,GPRS0"/>
          <Command cmdname="设置用户名" cmdType="S" cmd="[S]at^sics=0,user,gprs"/>
          <Command cmdname="设置口令" cmdType="S" cmd="[S]at^sics=0,passwd,gprs"/>
          <Command cmdname="设置连接方式1" cmdType="S" cmd="[S]at^sics=0,apn,cmnet"/>
          <Command cmdname="设置Socket" cmdType="S" cmd="[S]at^siss=1,srvType,socket"/>
          <Command cmdname="设置Socket1" cmdType="S" cmd="[S]at^siss=1,conId,0"/>
          <Command cmdname="设置目标IP地址、端口" cmdType="S" cmd="[S]at^siss=1,address,&quot;socktcp://220.248.243.211:6666&quot;"/>
          <Command cmdname="设置目标IP地址、端口google" cmdType="S" cmd="[S]at^siss=1,address,&quot;socktcp://210.45.246.4:80&quot;"/>
          <Command cmdname="打开socket连接" cmdType="S" cmd="[S]AT^SISO=1"/>
          <Command cmdname="发出10个字节内容" cmdType="S" cmd="[S]AT^SISW=1,10"/>
          <Command cmdname="具体内容" cmdType="S" cmd="[S]123456789s"/>
          <Command cmdname="具体内容1A [^Z]" cmdType="H" cmd="[H]1A"/>
          <Command cmdname="读出收到的内容" cmdType="S" cmd="[S]AT^SISR=1,10"/>
          <Command cmdname="关闭socket连接" cmdType="S" cmd="[S]AT^SISC=1  "/>
        </Command>
      </Command>
      <Command cmdname="SIM300 GPRS" cmdType="S" cmd="[S]none">
        <Command cmdname="基本AT指令" cmdType="S" cmd="[S]new command">
          <Command cmdname="AT测试" cmdType="S" cmd="[S]AT"/>
          <Command cmdname="AT测试" cmdType="P" cmd="[P]SendByte(0x41);
Wait(2);
SendByte(0x54);
Wait(2);
SendByte(0x0D);
Wait(2);
"/>
          <Command cmdname="取消指令回显" cmdType="S" cmd="[S]ATE0"/>
          <Command cmdname="打开指令回显" cmdType="S" cmd="[S]ATE1"/>
          <Command cmdname="查询设备厂商" cmdType="T" cmd="[T]AT+CGMI\rAT+CGMM\r "/>
          <Command cmdname="查询可用网络" cmdType="S" cmd="[S]at+cops=?"/>
        </Command>
        <Command cmdname="GPRS Socket" cmdType="S" cmd="[S]new command">
          <Command cmdname="查看信号强度" cmdType="S" cmd="[S]at+csq"/>
          <Command cmdname="设置连接方式0" cmdType="S" cmd="[S]AT+CIPMODE=0"/>
          <Command cmdname="设置连接方式1" cmdType="S" cmd="[S]AT+CIPMODE=1"/>
          <Command cmdname="设置目标IP地址、端口0" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;220.248.243.211&quot;,&quot;6666&quot;"/>
          <Command cmdname="设置目标IP地址、端口1" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;210.145.246.47&quot;,&quot;80&quot;"/>
          <Command cmdname="设置目标IP地址、端口2" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;210.145.246.4&quot;,&quot;6666&quot;"/>
          <Command cmdname="设置目标IP地址、端口1-google" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;203.208.137.104&quot;,&quot;80&quot;"/>
          <Command cmdname="设置目标IP地址、端口1-ustc telnet" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;202.38.164.9&quot;,&quot;23&quot;"/>
          <Command cmdname="发送5个字节" cmdType="S" cmd="[S]AT+CIPSEND=5"/>
          <Command cmdname="发送http请求" cmdType="T" cmd="[T]GET   /cgi-bin/qaweb.forte?inputXML=test.xml \r\n\r\n"/>
          <Command cmdname="5个字节内容" cmdType="S" cmd="[S]12345"/>
          <Command cmdname="发送数据，以1A结束" cmdType="S" cmd="[S]AT+CIPSEND"/>
          <Command cmdname="发送数据" cmdType="P" cmd="[P]SendString(GetString('请输入发送内容','abcd'));SendByte(0x1a);"/>
          <Command cmdname="结束符1a" cmdType="H" cmd="[H]1A"/>
          <Command cmdname="关闭socket连接" cmdType="S" cmd="[S]AT+CIPSHUT "/>
        </Command>
        <Command cmdname="GPRS连接到-Google网站" cmdType="S" cmd="[S]new command">
          <Command cmdname="1、查看信号强度" cmdType="S" cmd="[S]at+csq"/>
          <Command cmdname="2、设置连接方式0" cmdType="S" cmd="[S]AT+CIPMODE=0"/>
          <Command cmdname="3、显示接收数据的数据头" cmdType="S" cmd="[S]AT+CIPHEAD=1"/>
          <Command cmdname="4、设置目标IP地址、端口:谷歌" cmdType="S" cmd="[S]AT+CIPSTART=&quot;TCP&quot;,&quot;203.208.37.104&quot;,&quot;80&quot;"/>
          <Command cmdname="5、发送数据，以1A结束" cmdType="S" cmd="[S]AT+CIPSEND"/>
          <Command cmdname="6、发送http请求" cmdType="T" cmd="[T]GET   /index.html \r\n\r\n\x1a"/>
          <Command cmdname="6、发送http请求" cmdType="T" cmd="[T]GET   /cgi-bin/qaweb.forte?inputXML=test.xml \r\n\r\n\x1a"/>
          <Command cmdname="7、关闭socket连接" cmdType="S" cmd="[S]AT+CIPSHUT "/>
        </Command>
        <Command cmdname="打电话" cmdType="S" cmd="[S]new command">
          <Command cmdname="call" cmdType="S" cmd="[S]ATD13305223456"/>
        </Command>
        <Command cmdname="短信" cmdType="S" cmd="[S]new command">
          <Command cmdname="设置端消息中心" cmdType="S" cmd="[S]AT+CSCA=&quot;+8613800551500&quot;"/>
          <Command cmdname="设置文本短信方式" cmdType="S" cmd="[S]at+cmgf=1"/>
          <Command cmdname="发短信" cmdType="S" cmd="[S]AT+CMGS=&quot;+8613901233442&quot;"/>
          <Command cmdname="所发短信内容" cmdType="T" cmd="[T]12345\x1a "/>
          <Command cmdname="读出短信" cmdType="S" cmd="[S]at+cmgl=&quot;all&quot;"/>
          <Command cmdname="发送数据,以0x1A结尾" cmdType="P" cmd="[P]SendString(GetString('请输入发送内容','Hello!'));SendByte(0x1a);"/>
        </Command>
        <Command cmdname="测试数据" cmdType="H" cmd="[H]3f 00 06 99 99 31 69"/>
        <Command cmdname="setIP" cmdType="P" cmd="[P]    local s;
    s=GetParam(&quot;ABC&quot;,&quot;IP&quot;);
    --PrintToCommWin(&quot;config ip is:&quot;..s);
    if s==&quot;&quot; then s=&quot;114.96.16.4&quot;;  end;
   --
   s=GetString(&quot;设置IP地址:&quot;, s);
   SaveParam(&quot;ABC&quot;,&quot;IP&quot;,s);
   --     s=&quot;10.20.30.40&quot;;
   val=inet_addr(s);
   data1= bit_shr(val,24);   data2= bit_shr(val,16);    data3= bit_shr(val,8);   data4= bit_shr(val,0);

   s4=IntToStr(bit_and(data4,255)); len=#s4;  for i=1,3-len do s4=&quot;0&quot;..s4; end;
   s3=IntToStr(bit_and(data3,255)); len=#s3;  for i=1,3-len do s3=&quot;0&quot;..s3; end;
   s2=IntToStr(bit_and(data2,255)); len=#s2;  for i=1,3-len do s2=&quot;0&quot;..s2; end;
   s1=IntToStr(bit_and(data1,255)); len=#s1;  for i=1,3-len do s1=&quot;0&quot;..s1; end;
   s=&quot;IP&quot;..s4..s3..s2..s1;

   PrintToCommWin(&quot;Input ip is:&quot;..s);
   SendString(s);"/>
        <Command cmdname="connect" cmdType="H" cmd="[H]01"/>
        <Command cmdname="setIP" cmdType="S" cmd="[S]IP114096022016"/>
        <Command cmdname="senddata" cmdType="H" cmd="[H]02"/>
        <Command cmdname="close socket" cmdType="H" cmd="[H]04"/>
      </Command>
      <Command cmdname="EM310" cmdType="P" cmd="[P]
void click(int node)
{
   char buf[20],buf1[20];
   PrintToCommWin(&quot;aaaaaaaaabc&quot;);
   GetTreeNodeValue(node,buf,20);
   GetTreeNodeCaption(node,buf1,20);
   printf(&quot;%s:%s&quot;,buf1,buf);
}

void main()
{
   ClearTreeNode();
   int a=AddButtonTreeNode(0,&quot;串口命令&quot; ,0);
   int b=AddButtonTreeNode(0,&quot;网络命令&quot; ,0);

   AddSpinTreeNode(a,&quot;1. 设串口号&quot; ,click,5,1,10); //name,event,value,min,max
   AddTextTreeNode(a,&quot;2. IP地址&quot; ,click,&quot;192.168.1.1&quot;);
   AddPickTreeNode(a,&quot;3. 设波特率&quot; ,click,&quot;9600&quot;,&quot;1200&quot;,&quot;2400&quot;,&quot;4800&quot;,&quot;9600&quot;,&quot;19200&quot;,0);
   AddCheckTreeNode(a,&quot;4. 设串口号&quot; ,click,1); //name,event,value,min,max
   AddButtonTreeNode(a,&quot;5. 发送地址&quot; ,click);
   AddButtonTreeNode(b,&quot;1. ping&quot; ,click);
}
">
        <Command cmdname="初始化" cmdType="S" cmd="[S]数据发送区">
          <Command cmdname="AT" cmdType="S" cmd="[S]AT"/>
          <Command cmdname="测试SIM 卡是否存在" cmdType="S" cmd="[S]AT%TSIM"/>
          <Command cmdname="SIM 卡在位和PIN1 码状态查询" cmdType="S" cmd="[S]AT+CPIN?"/>
          <Command cmdname="检查当地的网络信号强度，31最大，0最小" cmdType="S" cmd="[S]AT+CSQ"/>
          <Command cmdname="启用网络注册非请求结果码" cmdType="S" cmd="[S]AT+CREG=1"/>
          <Command cmdname="网络运营商注册查询" cmdType="S" cmd="[S]AT+COPS?"/>
          <Command cmdname="启用GPRS网络注册非请求结果码" cmdType="S" cmd="[S]AT+CGATT=1"/>
          <Command cmdname="设备厂商" cmdType="S" cmd="[S]AT+GMI"/>
          <Command cmdname="版本号查询" cmdType="S" cmd="[S]AT+CGMR"/>
          <Command cmdname="GSN" cmdType="S" cmd="[S]AT+GSN"/>
          <Command cmdname="查询模块当前的IMSI号" cmdType="S" cmd="[S]AT+CIMI"/>
        </Command>
        <Command cmdname="TCP/IP" cmdType="S" cmd="[S]new command">
          <Command cmdname="初始化_不缓冲" cmdType="S" cmd="[S]AT%IOMODE=1,1,1"/>
          <Command cmdname="注册移动的CMNET网关" cmdType="S" cmd="[S]AT+CGDCONT=1,&quot;IP&quot;,&quot;CMNET&quot;"/>
          <Command cmdname="注册用户名密码，并等分配IP" cmdType="S" cmd="[S]AT%ETCPIP=&quot;user&quot;,&quot;gprs&quot;"/>
          <Command cmdname="查询GPRS 初始化是否成功" cmdType="S" cmd="[S]AT%ETCPIP?"/>
          <Command cmdname="设置TCP、ip、port" cmdType="S" cmd="[S]AT%IPOPEN=&quot;TCP&quot;,&quot;61.144.176.175&quot;,3000"/>
          <Command cmdname="设置TCP、ip、port[1]" cmdType="S" cmd="[S]AT%IPOPEN=&quot;TCP&quot;,&quot;220.248.243.211&quot;,6666"/>
          <Command cmdname="发送数据12345AB" cmdType="S" cmd="[S]AT%IPSEND=&quot;31323334354142&quot;"/>
          <Command cmdname="读取数据" cmdType="S" cmd="[S]AT%IPDR"/>
          <Command cmdname="关闭" cmdType="S" cmd="[S]AT%IPCLOSE=1"/>
          <Command cmdname="模块从GPRS 网络注销" cmdType="S" cmd="[S]AT%IPCLOSE=5"/>
        </Command>
      </Command>
    </Command>
    <Command cmdname="ARM开发板命令" cmdType="S" cmd="[S]new command">
      <Command cmdname="Mini2440" cmdType="S" cmd="[S]ERROR">
        <Command cmdname="Set parameter " cmdType="S" cmd="[S]new command">
          <Command cmdname="mach_type" cmdType="S" cmd="[S]mach_type"/>
          <Command cmdname="media_type" cmdType="S" cmd="[S]media_type"/>
          <Command cmdname="boot_mem_base" cmdType="S" cmd="[S]boot_mem_base"/>
          <Command cmdname="baudrate" cmdType="S" cmd="[S]baudrate"/>
          <Command cmdname="xmodem" cmdType="S" cmd="[S]xmodem"/>
          <Command cmdname="xmodem_one_nak" cmdType="S" cmd="[S]xmodem_one_nak"/>
          <Command cmdname="xmodem_initial_timeout" cmdType="S" cmd="[S]xmodem_initial_timeout"/>
          <Command cmdname="xmodem_timeout " cmdType="S" cmd="[S]xmodem_timeout "/>
          <Command cmdname="boot_delay " cmdType="S" cmd="[S]boot_delay"/>
          <Command cmdname="Linux command line" cmdType="S" cmd="[S]Linux command line"/>
        </Command>
        <Command cmdname="parameter value" cmdType="S" cmd="[S]new command">
          <Command cmdname="MACH_TYPE [782]" cmdType="S" cmd="[S]782"/>
          <Command cmdname="Linux command line" cmdType="S" cmd="[S]&quot;noinitrd root=/dev/mtdblock2 init=/linuxrc console=ttySAC1,115200&quot;"/>
        </Command>
        <Command cmdname="通过串口终端操作开发板" cmdType="S" cmd="[S]new command">
          <Command cmdname="2.5.1 播放mp3" cmdType="S" cmd="[S]madplay your.mp3"/>
          <Command cmdname="2.5.2 如何中止程序的运行" cmdType="H" cmd="[H]03"/>
          <Command cmdname="2.5.5 如何通过串口与PC 互相传送文件" cmdType="P" cmd="[P]void main()
{
  //char ss[]=&quot;请使用本工具右侧工具栏的【ZModem接收】与【ZModem发送】来测试本命令&quot;;
  //ShowMessage(ss);
  ShowMessage(&quot;请使用本工具右侧工具栏的【ZModem接收】与【ZModem发送】来测试本命令&quot;);
}
"/>
          <Command cmdname="2.5.6 控制板上的LED" cmdType="S" cmd="[S]new command">
            <Command cmdname="4 个用户led 将会以每个间隔0.2 秒的时间运行跑马灯" cmdType="S" cmd="[S]echo 0 0.2 &gt; /tmp/led-control"/>
            <Command cmdname="4 个用户led 将会以间隔0.2 秒的时间运行累加器" cmdType="S" cmd="[S]echo 1 0.2 &gt;/tmp/led-control"/>
            <Command cmdname="4 个用户led 将会停止闪动" cmdType="S" cmd="[S]etc/rc.d/init.d/leds stop"/>
            <Command cmdname="4 个用户led 将会重新开始闪动" cmdType="S" cmd="[S]etc/rc.d/init.d/leds start"/>
          </Command>
          <Command cmdname="2.5.7 测试板上的按键" cmdType="S" cmd="[S]buttons"/>
          <Command cmdname="2.5.8 串口2 和3 的测试" cmdType="S" cmd="[S]armcomtest Cd /dev/ttySAC0 -o"/>
          <Command cmdname="2.5.9 测试蜂鸣器" cmdType="S" cmd="[S]pwm_test"/>
          <Command cmdname="2.5.10 控制LCD 的背光" cmdType="S" cmd="[S]new command">
            <Command cmdname="关闭LCD 背光" cmdType="S" cmd="[S]echo 0 &gt; /dev/backlight"/>
            <Command cmdname="打开LCD 背光" cmdType="S" cmd="[S]echo 1 &gt; /dev/backlight"/>
          </Command>
          <Command cmdname="2.5.11 测试I2C－EEPROM" cmdType="S" cmd="[S]i2c Cw"/>
          <Command cmdname="2.5.13 如何设置网络以访问互联网网址" cmdType="S" cmd="[S]route add default gw 192.168.1.1"/>
          <Command cmdname="2.5.14 如何设置MAC 地址" cmdType="S" cmd="[S]ifconfig
ifconfig eth0 down
ifconfig eth0 hw ether 00:11:AA:BB:CC:DD
ifconfig eth0 up
ifconfig
ping 192.168.1.1"/>
          <Command cmdname="2.5.15 如何使用Telnet 远程登录开发板" cmdType="P" cmd="[P]main()
{
   char s[200]=&quot;请先使用本工具的【控制菜单】-&gt;【新建窗口】命令来新建一个窗口，\r\n&quot;;
   char *s1=&quot;然后使用本工具的【控制菜单】-&gt;【通讯类型】-&gt;【Telnet客户端】 命令进行Telnet测试！&quot;;
   strcat(s,s1);
   ShowMessage(s);
}"/>
          <Command cmdname="2.5.17 通过网页控制板上的LED" cmdType="S" cmd="[S]new command">
            <Command cmdname="要停止 web 服务器" cmdType="S" cmd="[S]etc/rc.d/init.d/httpd stop"/>
            <Command cmdname="重新启动" cmdType="S" cmd="[S]etc/rc.d/init.d/httpd start"/>
          </Command>
          <Command cmdname="2.5.18 如何挂接使用网络文件系统NFS" cmdType="S" cmd="[S]new command">
            <Command cmdname="挂接" cmdType="S" cmd="[S]mount Ct nfs Co nolock 192.168.1.111:/opt/FriendlyARM/mini2440/root_nfs /mnt"/>
            <Command cmdname="取消挂接" cmdType="S" cmd="[S]umount /mnt"/>
          </Command>
          <Command cmdname="2.5.19 设置并保存系统实时时钟" cmdType="S" cmd="[S]new command">
            <Command cmdname="设置时间为 2007-04-29 16:34" cmdType="S" cmd="[S]date -s 042916352007"/>
            <Command cmdname="把刚刚设置的时间存入S3C2440 内部的RTC" cmdType="S" cmd="[S]hwclock -w"/>
            <Command cmdname="恢复 linux 系统时钟为RTC" cmdType="S" cmd="[S]hwclock -s"/>
          </Command>
        </Command>
        <Command cmdname="5.5.3 通过NFS 启动系统" cmdType="S" cmd="[S]param set linux_cmd_line &quot;console=ttySAC0 root=/dev/nfs nfsroot=192.168.1.111:/opt/FriendlyARM/mini2440/root_qtopia ip=192.168.1.70:192.168.1.111:192.168.1.111:255.255.255.0:sbc2440.arm9.net:eth0:off&quot;"/>
      </Command>
      <Command cmdname="VIVI-TE2410" cmdType="S" cmd="[S]none">
        <Command cmdname="分区操作" cmdType="S" cmd="[S]none">
          <Command cmdname="显示分区" cmdType="S" cmd="[S]part show"/>
          <Command cmdname="添加jffs2分区" cmdType="S" cmd="[S]part add mypart 0x500000 0x100000 JFFS2"/>
          <Command cmdname="添加分区" cmdType="P" cmd="[P]name=GetString(&quot;分区名称&quot;,&quot;usr&quot;);
offset=GetString(&quot;起始地址&quot;,&quot;0x00600000&quot;);
size=GetString(&quot;分区大小&quot;,&quot;0x03a00000&quot;);
flag=GetString(&quot;分区类型&quot;,&quot;0&quot;);
cmd=&quot;part add &quot;..name..&quot; &quot;..offset..&quot; &quot;..size..&quot; &quot;..flag; 
SendString(cmd);                                                    "/>
          <Command cmdname="删除分区" cmdType="P" cmd="[P]name=GetString('分区名称','usr');
cmd='part del '..name;
SendString(cmd);                                                  "/>
          <Command cmdname="擦除分区" cmdType="P" cmd="[P]name=GetString('分区名称','usr');
cmd='part erase '..name;
SendString(cmd);
"/>
          <Command cmdname="恢复分区表" cmdType="P" cmd="[P]SendString('part reset');   "/>
          <Command cmdname="保存分区" cmdType="P" cmd="[P]SendString('part save');   "/>
        </Command>
        <Command cmdname="文件操作" cmdType="S" cmd="[S]none">
          <Command cmdname="load flash" cmdType="S" cmd="[S]load flash kernel t"/>
          <Command cmdname="load flash" cmdType="S" cmd="[S]load ram 0X30008000 t"/>
          <Command cmdname="boot" cmdType="S" cmd="[S]boot ram"/>
        </Command>
        <Command cmdname="参数操作" cmdType="S" cmd="[S]none">
          <Command cmdname="help" cmdType="S" cmd="[S]param help"/>
          <Command cmdname="show" cmdType="S" cmd="[S]param show"/>
          <Command cmdname="reset" cmdType="S" cmd="[S]param reset"/>
          <Command cmdname="save" cmdType="S" cmd="[S]param save"/>
          <Command cmdname="设置参数" cmdType="P" cmd="[P]name=GetString('参数名称','ip');
val=GetString('值','192.168.0.253');
cmd='param set '..name..' '..val;
SendString(cmd);  "/>
          <Command cmdname="set ip" cmdType="S" cmd="[S]param set ip 192.168.0.253"/>
          <Command cmdname="set mac" cmdType="S" cmd="[S]param set mac 00:01:02:03:04:05"/>
          <Command cmdname="linux_cmd_line" cmdType="S" cmd="[S]param set linux_cmd_line noinitrd root=/dev/mtdblock/3 init=/linuxrc console=ttyS0"/>
          <Command cmdname="wince_part_name" cmdType="S" cmd="[S]param set wince_part_name wince"/>
        </Command>
      </Command>
      <Command cmdname="DevKit8000 OMAP3530" cmdType="S" cmd="[S]none">
        <Command cmdname="4.3&quot;LCD" cmdType="S" cmd="[S]none">
          <Command cmdname="NandFlash" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 ubi.mtd=4 root=ubi0:rootfs rootfstype=ubifs video=omapfb:mode:4.3inch_LCD"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd nand read.i 80300000 280000 200000\;bootm 80300000"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv"/>
          </Command>
          <Command cmdname="SD Card" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 root=/dev/ram initrd=0x81600000,40M video=omapfb:mode:4.3inch_LCD"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd 'mmcinit;fatload mmc 0 80300000 uImage;fatload mmc 0 81600000 ramdisk.gz;bootm 80300000'"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv "/>
          </Command>
        </Command>
        <Command cmdname="7&quot;LCD" cmdType="S" cmd="[S]none
">
          <Command cmdname="NandFlash" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 ubi.mtd=4 root=ubi0:rootfs rootfstype=ubifs video=omapfb:mode:7inch_LCD"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd nand read.i 80300000 280000 200000\;bootm 80300000"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv"/>
          </Command>
          <Command cmdname="SD Card" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 root=/dev/ram initrd=0x81600000,40M video=omapfb:mode:7inch_LCD"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd 'mmcinit;fatload mmc 0 80300000 uImage;fatload mmc 0 81600000 ramdisk.gz;bootm 80300000'"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv "/>
          </Command>
        </Command>
        <Command cmdname="DVI" cmdType="S" cmd="[S]none
">
          <Command cmdname="NandFlash" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 ubi.mtd=4 root=ubi0:rootfs rootfstype=ubifs video=omapfb:mode:720p60"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd nand read.i 80300000 280000 200000\;bootm 80300000"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv"/>
          </Command>
          <Command cmdname="SD Card" cmdType="S" cmd="[S]none">
            <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 root=/dev/ram initrd=0x81600000,40M video=omapfb:mode:720p60"/>
            <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd 'mmcinit;fatload mmc 0 80300000 uImage;fatload mmc 0 81600000 ramdisk.gz;bootm 80300000'"/>
            <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv "/>
          </Command>
        </Command>
        <Command cmdname="测试程序" cmdType="S" cmd="[S]none">
          <Command cmdname="点亮led3" cmdType="S" cmd="[S]echo -n 1 &gt;/sys/class/leds/led3/brightness"/>
          <Command cmdname="熄灭led3" cmdType="S" cmd="[S]echo -n 0 &gt;/sys/class/leds/led3/brightness"/>
          <Command cmdname="KEYPAD 测试" cmdType="S" cmd="[S]evtest /dev/input/event0"/>
          <Command cmdname="触摸屏校正" cmdType="S" cmd="[S]ts_calibrate"/>
          <Command cmdname="触摸屏测试" cmdType="S" cmd="[S]ts_test"/>
          <Command cmdname="RTC 测试" cmdType="S" cmd="[S] date 080820002008"/>
          <Command cmdname="系统时钟写入RTC" cmdType="S" cmd="[S] hwclock Cw"/>
          <Command cmdname="读取RTC" cmdType="S" cmd="[S]  hwclock"/>
        </Command>
        <Command cmdname="Angstrom(GPE)桌面发布版本演示" cmdType="S" cmd="[S]none">
          <Command cmdname="make sd card" cmdType="S" cmd="[S]none">
            <Command cmdname="cp" cmdType="S" cmd="[S]cp /media/cdrom/linux/demo/angstrom/MLO /media/LABEL1"/>
            <Command cmdname="cp" cmdType="S" cmd="[S]cp /media/cdrom/linux/demo/angstrom/u-boot.bin /media/LABEL1"/>
            <Command cmdname="cp" cmdType="S" cmd="[S]cp /media/cdrom/linux/demo/angstrom/uImage /media/LABEL1"/>
            <Command cmdname="rm" cmdType="S" cmd="[S]rm Crf /media/LABEL2/*"/>
            <Command cmdname="tar" cmdType="S" cmd="[S]sudo tar jxvf linux/demo/angstrom/Angstrom-DevKit8000-demo-image-glibc-ipk-2008.1-test-2 0080111-DevKit8000.rootfs.tar.bz2 CC /media/LABEL2"/>
            <Command cmdname="sync" cmdType="S" cmd="[S]sync"/>
            <Command cmdname="umount" cmdType="S" cmd="[S]umount /media/LABEL1"/>
            <Command cmdname="umount" cmdType="S" cmd="[S]umount /media/LABEL2"/>
          </Command>
          <Command cmdname="4.3&quot;lcd" cmdType="S" cmd="[S]none">
            <Command cmdname="set bootargs" cmdType="S" cmd="[S]set bootargs mem=128M console=ttyS2,115200n8 root=/dev/mmcblk0p2 rw noinitrd rootdelay=1"/>
            <Command cmdname="mmcinit" cmdType="S" cmd="[S] mmcinit"/>
            <Command cmdname="fatload" cmdType="S" cmd="[S] fatload mmc 0 80300000 uimage"/>
            <Command cmdname="bootm" cmdType="S" cmd="[S] bootm 80300000"/>
          </Command>
          <Command cmdname="7&quot;lcd" cmdType="S" cmd="[S]none">
            <Command cmdname="set bootargs" cmdType="S" cmd="[S]  set bootargs mem=128M console=ttyS2,115200n8 root=/dev/mmcblk0p2 rw noinitrd rootdelay=1 video=omapfb:mode:7inch_LCD"/>
            <Command cmdname="mmcinit" cmdType="S" cmd="[S] mmcinit"/>
            <Command cmdname="fatload" cmdType="S" cmd="[S] fatload mmc 0 80300000 uimage"/>
            <Command cmdname="bootm" cmdType="S" cmd="[S] bootm 80300000"/>
          </Command>
          <Command cmdname="DVI" cmdType="S" cmd="[S]none">
            <Command cmdname="set bootargs" cmdType="S" cmd="[S]set bootargs mem=128M console=ttyS2,115200n8 root=/dev/mmcblk0p2 rw noinitrd rootdelay=1 video=omapfb:mode:720p60"/>
            <Command cmdname="mmcinit" cmdType="S" cmd="[S] mmcinit"/>
            <Command cmdname="fatload" cmdType="S" cmd="[S] fatload mmc 0 80300000 uimage"/>
            <Command cmdname="bootm" cmdType="S" cmd="[S] bootm 80300000"/>
          </Command>
        </Command>
      </Command>
      <Command cmdname="UBOOT" cmdType="S" cmd="[S]none">
        <Command cmdname="打印环境变量" cmdType="S" cmd="[S]printenv"/>
        <Command cmdname="设置新的变量" cmdType="S" cmd="[S]setenv myboard AT91RM9200DK"/>
        <Command cmdname="设置MAC地址" cmdType="S" cmd="[S]setenv ethaddr 12:34:56:78:9A:BC"/>
        <Command cmdname="设置IP地址" cmdType="S" cmd="[S]setenv serverip 192.168.1.254"/>
        <Command cmdname="设置服务器IP地址" cmdType="S" cmd="[S]setenv ipaddr 192.168.1.1"/>
        <Command cmdname="设置服务器IP地址" cmdType="S" cmd="[S]tftp 20000000 application.bin"/>
      </Command>
    </Command>
    <Command cmdname="UsbGadget_udisk" cmdType="S" cmd="[S]new command">
      <Command cmdname="insmod s3c2410_udc.ko" cmdType="S" cmd="[S]insmod s3c2410_udc.ko"/>
      <Command cmdname="insmod g_file_storage.ko" cmdType="S" cmd="[S]insmod g_file_storage.ko file=/dev/mmcblk0p1 stall=0 removable=1"/>
      <Command cmdname="insmod g_file_storage.ko1" cmdType="S" cmd="[S]insmod g_file_storage.ko file=/dev/sdcard stall=0 removable=1"/>
      <Command cmdname="mount sd" cmdType="S" cmd="[S]cd /
umount sd
mount /dev/mmcblk0p1 /sd
cd /sd"/>
      <Command cmdname="umount sd" cmdType="S" cmd="[S]cd /
umount /sd"/>
      <Command cmdname="./testapp" cmdType="S" cmd="[S]./testapp"/>
      <Command cmdname="re mount &amp; run" cmdType="S" cmd="[S]cd /
umount /sd
mount /dev/mmcblk0p1 /sd
cd /sd
./testapp"/>
      <Command cmdname="test data" cmdType="H" cmd="[H]F1  F2  06  F9  00  00  30  00  AA  BB  95"/>
      <Command cmdname="remount &amp; Run1" cmdType="S" cmd="[S]umount /sdcard
mount /dev/sdcard /sdcard
/sdcard/testapp"/>
      <Command cmdname="==========" cmdType="S" cmd="[S]数据发送区"/>
      <Command cmdname="umount" cmdType="S" cmd="[S]umount /sdcard"/>
      <Command cmdname="mount" cmdType="S" cmd="[S] mount /dev/sdcard /sdcard"/>
      <Command cmdname="run" cmdType="S" cmd="[S]/sdcard/testapp"/>
      <Command cmdname="Auto" cmdType="P" cmd="[P]void main()
{
    SendByte(0x03); // --Ctrl+C
    Wait(20);
    SendString(&quot;umount /sdcard\r\n&quot;);
    Wait(1000);
    SendString(&quot;mount /dev/sdcard /sdcard\r\n&quot;);
    Wait(1000);
    SendString(&quot;/sdcard/testapp\r\n&quot;);
}"/>
      <Command cmdname="^C" cmdType="H" cmd="[H]03"/>
    </Command>
  </Command>
  <Command cmdname="例子命令" cmdType="S" cmd="[S]none">
    <Command cmdname="基本命令" cmdType="S" cmd="[S]new command">
      <Command cmdname="字符串命令" cmdType="S" cmd="[S]12345 -&quot;abcd&quot;
56789\
llll"/>
      <Command cmdname="十六进制命令" cmdType="H" cmd="[H]0001020304aabbccdd"/>
      <Command cmdname="转义命令" cmdType="T" cmd="[T]abc\x34\123\r\xyzabcdef"/>
      <Command cmdname="脚本命令0" cmdType="P" cmd="[P]main()
{
   PrintfToCommWin(&quot;12345:%08d,%02x&quot;,666,0x83);
}"/>
      <Command cmdname="脚本命令2" cmdType="P" cmd="[P]void main()
{
    int i;
    PrintToCommWin(&quot;下面发送100个字节:&quot;);
    for(i=1; i&lt;=100; i++)
        SendByte(i);
}"/>
    </Command>
    <Command cmdname="控件示例" cmdType="S" cmd="[S]new command">
      <Command cmdname="扩展树节点" cmdType="P" cmd="[P]int c;
void NodeClick(int node)
{
    char buf[20],buf1[20],buf2[40];
    GetTreeNodeValue(node,buf,20);
    GetTreeNodeCaption(node,buf1,20);
    sprintf(buf2,&quot;%s:%s&quot;,buf1,buf);
    printf(&quot;%s&quot;,buf2);
    PrintToCommWin(buf2);
}
void NodeClick1(int node)
{
    char buf[20],buf1[20],buf2[40];
    GetTreeNodeValue(node,buf,20);
    sprintf(buf2,&quot;设置的串口波特率为:%s&quot;,buf);
    printf(&quot;%s&quot;,buf2);
    PrintToCommWin(buf2);
    ShowMessage(buf2);
}

void TreeNodeDbClick(int node)
{
    if(node==c)
        NodeClick1(node);
    else
        NodeClick(node);
}

void main()
{

    ClearTreeNode();
    int a=AddButtonTreeNode(0,&quot;串口命令&quot; ,0);
    int b=AddButtonTreeNode(0,&quot;网络命令&quot; ,0);


    AddSpinTreeNode(a,&quot;1. 设串口号&quot; ,5,1,10); //name,event,value,min,max
    c=AddTextTreeNode(a,&quot;2. IP地址&quot; ,&quot;192.168.1.1&quot;);
    SetTreeNodeBkColor(c,0xffff00);

    //SetTreeNodeCaption(c,&quot;1. ip address&quot;);
    SetTreeNodeValue(c,&quot;3&quot;);


    c=AddPickTreeNode(a,&quot;3. 设波特率&quot; ,&quot;9600&quot;,&quot;1200&quot;,&quot;2400&quot;,&quot;4800&quot;,&quot;9600&quot;,&quot;19200&quot;,0);
    SetTreeNodeValue(c,&quot;1200&quot;);
    SetTreeNodeBkColor(c,0x0000ff);
    int d=AddCheckTreeNode(a,&quot;4. 设串口号&quot; ,1);
    SetTreeNodeValue(d,&quot;False&quot;);
    c=AddButtonTreeNode(a,&quot;5. 发送地址(双击发送)&quot; );
    SetTreeNodeBkColor(d,0x00ff00);

    AddButtonTreeNode(b,&quot;1. ping&quot; );
    AddButtonTreeNode(b,&quot;2. ping2&quot; );
    AddButtonTreeNode(b,&quot;3. ping3&quot; );

    ShowLeftToolPage(1);
    ExplandAllTreeNode();
}
"/>
      <Command cmdname="控件示例" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
void click(int btn)
{
    char s[20];
    printf(&quot;clicked&quot;);
    //SetProperty(btn,&quot;enabled&quot;,&quot;false&quot;);
    GetProperty(btn,&quot;caption&quot;,s,20);
    printf(&quot;button caption is '%s'&quot;,s);
};
void click1(int btn)
{
    char s[20];
    printf(&quot;clicked&quot;);
    //SetProperty(btn,&quot;enabled&quot;,&quot;false&quot;);
    GetProperty(btn,&quot;text&quot;,s,20);
    printf(&quot;edit text is '%s'&quot;,s);
};

void main()
{
    int i;
    int btn;
    int node;
    char s[100];

    ClearVclControls();
    ShowVclWin(150);
    ShowOutputWin(300);
    int p=GetGuiWin();
    for(  i=0; i&lt;3; i++)
    {
        sprintf(s,&quot;按钮:%d&quot;,i);
        btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,s,0);
        SetProperty(btn,&quot;left&quot;,10+i*70);
        SetPropertyList(btn,&quot;top&quot;,30,&quot;width&quot;,65,&quot;onclick&quot;,click,NULL);//创建按钮
    }
    for(  i=0; i&lt;3; i++)
    {
        sprintf(s,&quot;Text:%d&quot;,i);
        btn=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,s,0);
        SetProperty(btn,&quot;left&quot;,10+i*70);
        SetPropertyList(btn,&quot;top&quot;,60,&quot;width&quot;,65,&quot;onclick&quot;,click1,NULL);//创建按钮
    }
    for(  i=0; i&lt;3; i++)
    {
        sprintf(s,&quot;check:%d&quot;,i);
        btn=CreateComponentEx(p,&quot;checkbox&quot;,&quot;caption&quot;,s,0);
        SetProperty(btn,&quot;left&quot;,10+i*70);
        SetPropertyList(btn,&quot;top&quot;,90,&quot;width&quot;,65,&quot;onclick&quot;,click,NULL);//创建按钮
    }

};
"/>
      <Command cmdname="KS8995MA" cmdType="P" cmd="[P]#include&quot;windows.h&quot;
int rootNode;
unsigned char Data[200];
unsigned char skip=1;
void ReadDataFromFile(unsigned char *filename)
{
    char s[100];
    HANDLE Handle=CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    printf(&quot;读取文件名称：%s&quot;,filename);
    if(Handle&lt;=0)
    {
        sprintf(s,&quot;打开文件【%s】错误！&quot;,s);
        ShowMessage(s);//&quot;打开文件【&quot;..pb.edit1.text..&quot;】错误！&quot;);
        return  ;
    }
    int BytesRead ;
    ReadFile(Handle, Data,128,&amp;BytesRead,NULL);
    CloseHandle(Handle);
}
void WriteDataToFile(unsigned char *filename)
{
    char s[100];
    HANDLE Handle=CreateFile(filename, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    printf(&quot;保存文件名称：%s&quot;,filename);
    if(Handle&lt;=0)
    {
        sprintf(s,&quot;打开文件【%s】错误！&quot;,s);
        ShowMessage(s);//&quot;打开文件【&quot;..pb.edit1.text..&quot;】错误！&quot;);
        return  ;
    }

    int BytesWrite ;
    WriteFile(Handle, Data,128,&amp;BytesWrite,NULL);
    CloseHandle(Handle);
}

int GetRegisterIdx(int node)
{
    char buf[50],buf1[20];
    int i,j,k,idx;
    GetTreeNodeCaption(node,buf,50);
    j=0;
    if(buf[0]!='(') return -1;
    for(i=1; i&lt;50; i++)
        if( ((buf[i]&gt;='0')&amp;&amp;(buf[i]&lt;='9')) ||
                ((buf[i]=='x')||(buf[i]=='X')) ||
                ((buf[i]&gt;='a')&amp;&amp;(buf[i]=='f')) ||
                ((buf[i]&gt;='A')&amp;&amp;(buf[i]=='F')) )
        {
            buf1[j++]=buf[i];
        }
        else if(buf[i]==')')
        {
            if(j==0) return -1;
            buf1[j++]=0;
            idx=HexStrToInt(buf1);
            return idx;
        }
        else return -1;
}

int GetRegistBits(int node,int *start,int *len)
{
    char buf[50],buf1[20];
    int i,j,k,idx;
    *start=-1;
    j=0;
    GetTreeNodeCaption(node,buf,50);
    for(i=0; i&lt;50; i++)
        if((buf[i]&gt;='0')&amp;&amp;(buf[i]&lt;='9'))
        {
            buf1[j++]=buf[i];
        }
        else if(buf[i]=='-')
        {
            if(j==0) return -1;
            if(*start!=-1) return -1;
            idx=0;
            for(k=0; k&lt;j; k++)
                idx=idx*10+buf1[k]-'0';
            *start=idx;
            j=0;
        }
        else if(buf[i]==' ')
        {
            if(j==0) return -1;
            idx=0;
            for(k=0; k&lt;j; k++)
                idx=idx*10+buf1[k]-'0';
            if(*start==-1)
            {
                *start=idx;
                *len=1;
                return len;
            }
            else
            {
                if(idx&gt;*start) return -1;

                k=*start;
                *start=idx;
                idx=k;//swap
                *len=idx-*start+1;
                return len;
            }
        }
        else return -1;
}

unsigned int BinStrToInt(char *str)
{
    int i,j,k;
    unsigned int val=0;
    for(i=0; i&lt;10; i++)
        if(str[i]=='0')
            val=val&lt;&lt;1;
        else if(str[i]=='1')
            val=(val&lt;&lt;1)|1;
        else return val;
    return val;
}

void NodeProc(int node,int ReadOrWrite,int loop)
{
    char buf[50],buf1[50];
    int idx,i;
    int start,len;
    unsigned char bits,val;
    unsigned char mask;
    int nd=node;
    int value=0x85;
    int set=ReadOrWrite;
    if(node==0) return;
    do
    {
        idx=GetRegisterIdx(nd); // printf(&quot;idx:%d&quot;,idx);
        if(idx&gt;=0)
        {
            if(set)
            {
                sprintf(buf,&quot;%02X&quot;,Data[idx]);//;
                SetTreeNodeValue(nd,buf);// set value
            }
            int child=GetFirstChild(nd);
            int start,len;
            while(child!=0)
            {
                if(GetRegistBits(child,&amp;start,&amp;len)&gt;=0)
                {
                    //sprintf(buf,&quot;(%d-%d) &quot;,start,start+len-1);PrintToCommWin(buf);
                    GetTreeNodeValue(child,buf,20);
                    bits=BinStrToInt(buf);  //sprintf(buf1,&quot;%d &quot;, bits);PrintToCommWin(buf1);
                    mask=0xff&gt;&gt;start;
                    mask=mask&lt;&lt;start;
                    mask=mask&lt;&lt;(7-(start+len-1));
                    mask=mask&gt;&gt;(7-(start+len-1));

                    if(set)
                    {
                        bits=Data[idx]&amp;mask;
                        bits&gt;&gt;=start;
                        for(i=0; i&lt;len; i++)
                            if(bits&amp;(1&lt;&lt;i))buf[len-i-1]='1';
                            else buf[len-i-1]='0';
                        buf[len]=0;
                        SetTreeNodeValue(child,buf);
                    }
                    else
                    {
                        bits&lt;&lt;=start;
                        GetTreeNodeValue(nd,buf,20);
                        val=HexStrToInt(buf);
                        val=val&amp;(~mask);
                        val=val|(bits&amp;mask);
                        sprintf(buf,&quot;%02X&quot;,val);//PrintToCommWin(buf);
                        SetTreeNodeValue(nd,buf);
                    }
                }
                child=GetNextSibing(child);
            }
            if(!set)
            {
                GetTreeNodeValue(nd,buf,20);
                val=HexStrToInt(buf);
                Data[idx]=val;
                SetHexEditorDat(idx,val);
                SetHexEditorSelection(idx,1);
            }
        }
        nd=GetNextSibing(nd);
    }
    while((nd!=0)&amp;&amp;(loop));

}
void NodeProcAll(int rdwr)
{
    int child;
    char buf[20],buf1[200];
    int nd=rootNode;

    while(nd!=0)
    {
        NodeProc(GetFirstChild(nd),rdwr,1);
        nd=GetNextSibing(nd);
    }

    nd=rootNode;
    while(nd!=0)
    {
        buf1[0]=0;
        child=GetFirstChild(nd);
        while(child!=0)
        {
            GetTreeNodeValue(child,buf,20);
            if(buf1[0]!=0)
                sprintf(buf1,&quot;%s,%s&quot;,buf1,buf);
            else
                sprintf(buf1,&quot;%s&quot;,buf);

            child=GetNextSibing(child);
        }
        SetTreeNodeValue(nd,buf1);
        nd=GetNextSibing(nd);
    }
}


void NodeClick(int node)
{
    node=GetNodeParent(node);
    if(node==0)return;
    int idx=GetRegisterIdx(node); // printf(&quot;idx:%d&quot;,idx);
    if(idx&lt;0) return;

    NodeProc(node,0,0);

    node=GetNodeParent(node);
    if(node==0)return;
    int nd=node;

    char buf[20],buf1[200];
    buf1[0]=0;
    int child=GetFirstChild(nd);
    while(child!=0)
    {
        GetTreeNodeValue(child,buf,20);
        if(buf1[0]!=0)
            sprintf(buf1,&quot;%s,%s&quot;,buf1,buf);
        else
            sprintf(buf1,&quot;%s&quot;,buf);

        child=GetNextSibing(child);
    }
    SetTreeNodeValue(nd,buf1);
}

void TreeNodeDbClick(int node)
{
    NodeClick(node);
}
void TreeNodeEdited(int node)
{
    char buf[20];
    int val;
    if(node==0)return;
    int idx=GetRegisterIdx(node); // printf(&quot;idx:%d&quot;,idx);
    if(idx&lt;0)
        NodeClick(node);
    else
    {

        GetTreeNodeValue(node,buf,20);
        int val=HexStrToInt(buf);
        Data[idx]=val;
        NodeProc(node,1,0);
        SetHexEditorDat(idx,val);
        SetHexEditorSelection(idx,1);
    }
}
void HexEditorChanged(int editor)
{
    int i;
    if(skip) return;
    for(i=0; i&lt;200; i++)
        Data[i]=GetHexEditorDat(i);
    NodeProcAll(1);

}

void BtnClick0()
{
    skip=1;
    ReadDataFromFile(&quot;c:\\zz.bin&quot;);
    HexEditorLoadFromFile(&quot;c:\\zz.bin&quot;);
    NodeProcAll(1);
    skip=0;
}
void BtnClick1()
{
    int i;
    //NodeProcAll(0);
    for(i=0; i&lt;20; i++)
        printf(&quot;%d&quot;,Data[i]);
    WriteDataToFile(&quot;c:\\zz.bin&quot;);
}

void main()
{
    char buf[50],buf1[50];
    ClearVclControls();
    ShowVclWin(80);
    CloseInputWin();
    ShowOutputWin(300);
    int p=GetGuiWin();
    int btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;读取文件&quot;,0);
    SetPropertyList(btn,&quot;left&quot;,10+0*90,&quot;top&quot;,30,&quot;width&quot;,85,&quot;onclick&quot;,BtnClick0,NULL);//创建按钮

    btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;输出文件&quot;,0);
    SetPropertyList(btn,&quot;left&quot;,10+1*90,&quot;top&quot;,30,&quot;width&quot;,85,&quot;onclick&quot;,BtnClick1,NULL);//创建按钮


    ClearTreeNode();
    int i,node0,node1;
    for(i=0; i&lt;200; i++)Data[i]=rand(255);

    int a=AddTextTreeNode(0,&quot;0-1 字节：Chip ID Registers&quot; ,&quot;&quot;);
    int b=AddTextTreeNode(0,&quot;2-11  字节：Global Control Registers&quot; ,&quot;&quot;);
    int c=AddTextTreeNode(0,&quot;12-15 字节：保留&quot; ,&quot;&quot;);
    int d=AddTextTreeNode(0,&quot;16-29 Port 1 Control Registers&quot; ,&quot;&quot;);
    int e=AddTextTreeNode(0,&quot;30-31 Port 1 Status Registers&quot;  ,&quot;&quot;);
    int f=AddTextTreeNode(0,&quot;32-45 Port 2 Control Registers&quot; ,&quot;&quot;);
    int g=AddTextTreeNode(0,&quot;46-47 Port 2 Status Registers&quot;  ,&quot;&quot;);
    int h=AddTextTreeNode(0,&quot;48-61 Port 3 Control Registers&quot; ,&quot;&quot;);
    int i=AddTextTreeNode(0,&quot;62-63 Port 3 Status Registers&quot;  ,&quot;&quot;);
    int j=AddTextTreeNode(0,&quot;64-77 Port 4 Control Registers&quot; ,&quot;&quot;);
    int k=AddTextTreeNode(0,&quot;78-79 Port 4 Status Registers&quot;  ,&quot;&quot;);
    int l=AddTextTreeNode(0,&quot;80-93 Port 5 Control Registers&quot; ,&quot;&quot;);
    int m=AddTextTreeNode(0,&quot;94-95 Port 5 Status Registers&quot;  ,&quot;&quot;);


    c=AddTextTreeNode(a,&quot;(0x00): 第0字节&quot; ,&quot;0&quot;); //name,event,value,min,max
    node0=AddTextTreeNode(a,&quot;(01): 第1字节 / Start Switch&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;7-4 Chip ID&quot; ,&quot;000&quot;);
    node1=AddTextTreeNode(node0,&quot;3-1 Revision ID&quot; ,&quot;000&quot;);
    node1=AddTextTreeNode(node0,&quot;0 Start Switch&quot; ,&quot;0&quot;);

    node0=AddTextTreeNode(b,&quot;(0x02): Global Control 0&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;7-3 hour&quot; ,&quot;00000&quot;);
    node1=AddTextTreeNode(node0,&quot;2-0 min hi3bit&quot; ,&quot;000&quot;);

    node0=AddTextTreeNode(b,&quot;(0x03): Global Control 1&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;7-5 min low3 bit&quot;  ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;4-0 sec hi 5bit &quot;         ,&quot;0&quot;);


    node0=AddTextTreeNode(b,&quot;(0x04): Global Control 2&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;7 sec low 1 bit &quot;  ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;6 Multicast Storm&quot;         ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;5 Back Pressure Mode&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;4 Flow Control and Back&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;3 No Excessive Collision Drop&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;2 Huge Packet Support&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;1 Legal Maximum Packet&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;0 Priority Buffer Reserve&quot; ,&quot;0&quot;);


    node0=AddTextTreeNode(d,&quot;(0x10): Port 1 Control 0&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;7 Broadcast Storm&quot;  ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;6 DiffServ Priority&quot;         ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;5 802.1p Priority&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;4 Port-Based Priority&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;3 Reserved&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;2 Tag Insertion&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;1 Tag Removal&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;0 Priority Enable&quot; ,&quot;0&quot;);



    node0=AddTextTreeNode(d,&quot;(0x20): Port 2 Control 0&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;7 Broadcast Storm&quot;  ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;6 DiffServ Priority&quot;         ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;5 802.1p Priority&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;4 Port-Based Priority&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;3 Reserved&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;2 Tag Insertion&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;1 Tag Removal&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;0 Priority Enable&quot; ,&quot;0&quot;);


    node0=AddTextTreeNode(f,&quot;(0x20): Port 2 Control 0&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;7 Broadcast Storm&quot;  ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;6 DiffServ Priority&quot;         ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;5 802.1p Priority&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;4 Port-Based Priority&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;3 Reserved&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;2 Tag Insertion&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;1 Tag Removal&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;0 Priority Enable&quot; ,&quot;0&quot;);

    node0=AddTextTreeNode(h,&quot;(0x30): Port 3 Control 0&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;7 Broadcast Storm&quot;  ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;6 DiffServ Priority&quot;         ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;5 802.1p Priority&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;4 Port-Based Priority&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;3 Reserved&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;2 Tag Insertion&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;1 Tag Removal&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;0 Priority Enable&quot; ,&quot;0&quot;);

    node0=AddTextTreeNode(j,&quot;(0x40): Port 4 Control 0&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;7 Broadcast Storm&quot;  ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;6 DiffServ Priority&quot;         ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;5 802.1p Priority&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;4 Port-Based Priority&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;3 Reserved&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;2 Tag Insertion&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;1 Tag Removal&quot; ,&quot;0&quot;);
    node1=AddTextTreeNode(node0,&quot;0 Priority Enable&quot; ,&quot;0&quot;);

    rootNode=a;
    NodeProcAll(1);
    SetHexEditorDataList(0,Data,200);
    skip=0;
    ShowLeftToolPage(1);
    ShowDispMode(2);
    ShowMessage(&quot;试试修改左侧树中的数据或右侧十六进制数。两侧数据会同步显示。\r\n[左侧]：为数据含义\r\n[右侧]：为数据内容&quot;);
}
"/>
      <Command cmdname="GB/T19056汽车行驶记录仪" cmdType="P" cmd="[P]#include &quot;windows.h&quot;

//////////////// 接收队列处理 ///////////////////////////////////
#define MAXRXBUFLEN (1024*20)
#define GetRxBufLen()  ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN)
#define IsRxBufEmpty() (RxBufHead==RxBufTail)
#define IsRxBufFull()  ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead)
#define ClearRxBuf()   RxBufHead=RxBufTail=0
void main()
{
  int pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;form1&quot;,&quot;Width&quot;,400,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;visible&quot;,1,NULL);  
};

BYTE RxBuf[MAXRXBUFLEN];
BYTE RxBufHead=0;
BYTE RxBufTail=0;

BYTE GetRxBufByte(void)
{
    BYTE dat;
    dat=RxBuf[RxBufHead];
    RxBufHead++;
    RxBufHead%=MAXRXBUFLEN;
    return dat;
}
void DiscardRxBufBytes(BYTE count)
{
    RxBufHead+=count;
    RxBufHead%=MAXRXBUFLEN;
}
BYTE PeekRxBufByte(BYTE idx)
{
    BYTE tmpHead=RxBufHead;
    tmpHead+=idx;
    tmpHead%=MAXRXBUFLEN;
    return RxBuf[tmpHead];
}
void PutRxBufByte(BYTE dat)
{
    RxBuf[RxBufTail]=dat;
    RxBufTail++;
    RxBufTail%=MAXRXBUFLEN;
}

//////////////////////////////////////////////////////////////////
//////////////// 队列处理 ///////////////////////////////////
//#define MAXRXBUFLEN (1024*20)
#define GetPrtclBufLen()  ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN)
#define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail)
#define IsPrtclBufFull()  ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead)
#define ClearPrtclBuf()   PrtclBufHead=PrtclBufTail=0

BYTE PrtclBuf[MAXRXBUFLEN];
BYTE PrtclBufHead=0;
BYTE PrtclBufTail=0;

BYTE GetPrtclBufByte(void)
{
    BYTE dat;
    dat=PrtclBuf[PrtclBufHead];
    PrtclBufHead++;
    PrtclBufHead%=MAXRXBUFLEN;
    return dat;
}
void DiscardPrtclBufBytes(BYTE count)
{
    PrtclBufHead+=count;
    PrtclBufHead%=MAXRXBUFLEN;
}
BYTE PeekPrtclBufByte(BYTE idx)
{
    BYTE tmpHead=PrtclBufHead;
    tmpHead+=idx;
    tmpHead%=MAXRXBUFLEN;
    return PrtclBuf[tmpHead];
}
void PutPrtclBufByte(BYTE dat)
{
    PrtclBuf[PrtclBufTail]=dat;
    PrtclBufTail++;
    PrtclBufTail%=MAXRXBUFLEN;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////



#define MAXCMDLEN 200
BYTE cmdData[MAXCMDLEN];
BYTE cmdLen;

void ProcessRecvCmd(int node,int cmd,unsigned char *dat,int len)
{
    unsigned char s[100];
    if(cmd==0x00)
    {
        dat[len]=0;
        sprintf(s,&quot;%s&quot;,dat);
        AddPrtclDetailNode(node,s,0,0);
    }

}

void EncodePrtclData(void)//包裹解码
{
    int i,len;
    int cmd;
    int node;
    unsigned char s[100];
    BYTE cs;

    AddPrtclDetailNode(NULL,&quot;起始字头&quot;,PrtclBufHead,2);
    GetPrtclBufByte();//丢弃一个字节; 55
    GetPrtclBufByte();//丢弃一个字节; 7a
    AddPrtclDetailNode(NULL,&quot;命令字&quot;,PrtclBufHead,1);

    cmd=GetPrtclBufByte();//丢弃一个字节; len
    int node=AddPrtclDetailNode(NULL,&quot;长度&quot;,PrtclBufHead,2);
    len=GetPrtclBufByte();
    len=len*256+GetPrtclBufByte();
    sprintf(s,&quot;长度为:%d&quot;,len);
    AddPrtclDetailNode(node,s,0,0);

    AddPrtclDetailNode(NULL,&quot;保留&quot;,PrtclBufHead,1);
    GetPrtclBufByte();//丢弃一个字节;

    node=AddPrtclDetailNode(NULL,&quot;数据块&quot;,PrtclBufHead,len);

    for(i=0; i&lt;len; i++)
        cmdData[i]=GetPrtclBufByte();

    AddPrtclDetailNode(NULL,&quot;校验&quot;,PrtclBufHead,1);
    GetPrtclBufByte(); //cs

    cmdLen=len;
    printf(&quot;Recv a command!&quot;);
    ProcessRecvCmd(node,cmd,cmdData,cmdLen);

}


//通讯处理
void ProcessRxComm(void)
{
    BYTE len;
    unsigned char cs;
    int i;
    while(GetRxBufLen()&gt;=7)
    {
        if(PeekRxBufByte(0)!=0x55)
        {
            DiscardRxBufBytes(1);
        }
        else if(PeekRxBufByte(1)!=0x7a)
        {
            DiscardRxBufBytes(2);
        }
        else
        {
            len=PeekRxBufByte(3)*256+PeekRxBufByte(4);
            if(GetRxBufLen()&gt;=len+7)
            {
                cs=0;
                for(i=0; i&lt;len+7-1; i++)
                    cs=cs^PeekRxBufByte(i);
                if(cs!=PeekRxBufByte(len+6))
                {
                    printf(&quot;校验出错!&quot;);
                    DiscardRxBufBytes(2);
                }
                else
                {
                    if(PeekRxBufByte(2)==0x00)
                    {
                        printf(&quot;采集执行标准版本号&quot;);
                        AddPrtclDataNode(NULL,&quot;采集执行标准版本号&quot;,&amp;RxBuf[RxBufHead],len+7,0);
                    }
                    else if(PeekRxBufByte(2)==0x01)
                    {
                        printf(&quot;采集当前驾驶人信息&quot;);
                        AddPrtclDataNode(NULL,&quot;采集当前驾驶人信息&quot;,&amp;RxBuf[RxBufHead],len+7,0);
                    }
                    else if(PeekRxBufByte(2)==0x02)
                    {
                        printf(&quot;采集实时时钟&quot;);
                        AddPrtclDataNode(NULL,&quot;采集实时时钟&quot;,&amp;RxBuf[RxBufHead],len+7,0);
                    }
                    //else if(...)  //继续扩充
                    //{ ...  }

                    DiscardRxBufBytes(len+7);
                }
            }
            else
            {
                break;
            }
        }
    }	//while
}

void ProcessPrtclData(void)
{
    EncodePrtclData();
}


//////////////////////////////////////////////////////////////////////

void RecvSerialData(char *buf,int count)
{
    int i;
    for(i=0; i&lt;count; i++)
    {
        PutRxBufByte(buf[i]);
    }
    printf(&quot;RecvSerialData,len(%d)&quot;,count);
    ProcessRxComm();

}
void AnaProtocolData(char *buf,int count)
{
    int node;
    int i;
    printf(&quot;AnaProtocolData,len(%d) &quot;,count );
    ClearPrtclBuf();
    for(i=0; i&lt;count; i++)
        PutPrtclBufByte(buf[i]);
    ProcessPrtclData();
}

void click(int btn)
{
    unsigned char s0[]= {0x55 ,0x7A ,0x00 ,0x00 ,0x0e  ,0x00  ,0x47 ,0x42 ,0x2F ,0x54 ,0x31 ,0x39 ,0x30 ,0x35 ,0x36 ,0x2D ,0x32 ,0x30 ,0x30 ,0x39,0x42};
    //char s1[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x02 ,0x02 ,0xf3 ,0xf7 ,0x03};
    RecvSerialData(s0,sizeof(s0));
    //RecvSerialData(s1,sizeof(s1));
};



















void SendCmd(unsigned char cmd,unsigned char *data,int len)
{
    int i;
    unsigned char buf[1024];
    unsigned char s[1024];
    unsigned char tmp[10];
    unsigned char cs=0;
    buf[0]=0xAA;
    buf[1]=0x75;
    buf[2]=cmd;
    buf[3]=(len&gt;&gt;8)&amp;0xff;
    buf[4]=len&amp;0xff;
    buf[5]=0;
    for(i=0; i&lt;len; i++)
        buf[6+i]=data[i];
    for(i=0; i&lt;7+len; i++)
        cs=cs^buf[i];
    buf[6+len]=cs;
    SendBuffer(buf,7+len);
    s[0]=0;
    for(i=0; i&lt;7+len; i++)
    {
        sprintf(tmp,&quot;%02X,&quot;,buf[i]);
        strcat(s,tmp);
    }
    printf(&quot;send cmd: %s&quot;,s);
}
void TreeNodeDbClick(int node)
{
    char buf[80];
    unsigned char data[100];
    int DatCount=0;
    GetTreeNodeCaption(node,buf+2,80);
    if(GetNodeParent(node)!=0) return;
    buf[0]='0';
    buf[1]='x';
    buf[4]=0;
    int cmd=StrToInt(buf);
    int nd=GetFirstChild(node);
    while(nd!=0)
    {
        GetTreeNodeValue(nd,buf,80);
        //printf(&quot;data %d is:%d %d&quot;,DatCount,buf[0]&amp;0xff,buf[1]&amp;0xff);
        data[DatCount++]=StrToInt(buf);
        nd=GetNextSibing(nd);
    }
    //printf(&quot;cmd is %d&quot;,cmd);
    SendCmd(cmd,data,DatCount);
}
void main0()
{
    int i,btn,node;
    ShowProtocolWin();
    ClearVclControls();
    ShowOutputWin(700);
    ShowVclWin(140);
    int p=GetGuiWin(0);
    btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;模拟数据&quot;,&quot;left&quot;,10,&quot;top&quot;,30,&quot;width&quot;,85,&quot;onclick&quot;,click,NULL);//创建按钮
    ClearProtocolTree();
    click(0);
};

void main()
{
    int node;
    ShowOutputWin(-1);
    main0();
    ClearTreeNode();
    node =AddButtonTreeNode(0,&quot;00.采集记录仪执行标准版本号&quot; ,0);
    SetTreeNodeBkColor(node,0x0000ff);
    int b=AddButtonTreeNode(0,&quot;01.采集当前驾驶人信息&quot; ,0);

    AddButtonTreeNode(0,&quot;02.采集记录仪的实时时钟&quot; ,0);
    AddButtonTreeNode(0,&quot;03.采集累计行驶里程&quot; ,0);
    AddButtonTreeNode(0,&quot;04.采集记录仪速度脉冲系数&quot; ,0);
    AddButtonTreeNode(0,&quot;06.采集车辆信息&quot; ,0);
    AddButtonTreeNode(0,&quot;08.采集记录仪状态信号配置信息&quot; ,0);
    AddButtonTreeNode(0,&quot;16.采集记录仪唯一性编号&quot; ,0);
    node=AddButtonTreeNode(0,&quot;09.采集指定的每秒钟平均速度记录&quot; ,0);

    AddSpinTreeNode(node,&quot;起始年&quot; ,11,0,99);
    AddSpinTreeNode(node,&quot;月&quot; ,10,1,12);
    AddSpinTreeNode(node,&quot;日&quot; ,11,1,21);
    AddSpinTreeNode(node,&quot;时&quot; ,16,0,23);
    AddSpinTreeNode(node,&quot;分&quot; ,11,0,59);
    AddSpinTreeNode(node,&quot;秒&quot; ,16,0,59);
    AddSpinTreeNode(node,&quot;结束年&quot; ,11,0,99);
    AddSpinTreeNode(node,&quot;月&quot; ,10,1,12);
    AddSpinTreeNode(node,&quot;日&quot; ,11,1,21);
    AddSpinTreeNode(node,&quot;时&quot; ,16,0,23);
    AddSpinTreeNode(node,&quot;分&quot; ,11,0,59);
    AddSpinTreeNode(node,&quot;秒&quot;,16 ,0,59);
    AddSpinTreeNode(node,&quot;最大单位数据块个数N(高字节)&quot; ,0,59,16);
    AddSpinTreeNode(node,&quot;最大单位数据块个数N(低字节)&quot; ,0,59,16);

    AddButtonTreeNode(0,&quot;05.采集指定的每分钟平均速度记录&quot; ,0);
    AddButtonTreeNode(0,&quot;13.采集指定的位置信息记录&quot; ,0);
    AddButtonTreeNode(0,&quot;07.采集指定的事故疑点记录&quot; ,0);
    AddButtonTreeNode(0,&quot;11.采集指定的疲劳驾驶记录&quot; ,0);
    AddButtonTreeNode(0,&quot;10.采集指定的登录退出记录&quot; ,0);
    AddButtonTreeNode(0,&quot;14.采集指定的外部供电记录&quot; ,0);
    AddButtonTreeNode(0,&quot;15.采集指定的参数修改记录&quot; ,0);


    node=AddButtonTreeNode(0,&quot;82.设置车辆信息&quot; ,0);
    SetTreeNodeBkColor(node,0x0000ff);
    AddButtonTreeNode(0,&quot;83.设置记录仪初次安装日期&quot; ,0);
    AddButtonTreeNode(0,&quot;84.设置状态量信息&quot; ,0);
    AddButtonTreeNode(0,&quot;C2.设置记录仪时钟&quot; ,0);
    AddButtonTreeNode(0,&quot;C3.设置记录仪速度脉冲系数&quot; ,0);
    node=AddButtonTreeNode(0,&quot;E0.检定控制命令&quot; ,0);
    SetTreeNodeBkColor(node,0x0000ff);
    AddButtonTreeNode(0,&quot;E1.记录仪发送速度里程数据&quot; ,0);
    AddButtonTreeNode(0,&quot;E2.检定模式保持命令&quot; ,0);



    ShowLeftToolPage(1);
    //ExplandAllTreeNode();
}
"/>
      <Command cmdname="创建PageControl控件" cmdType="P" cmd="[P]void main()
{
    ClearVclControls();
    ShowVclWin(150);
    ShowOutputWin(300);
    int p=GetGuiWin(0);
    int pnl=CreateComponentEx(p,&quot;panel&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,350,&quot;height&quot;,200,0);
    int pc=CreateComponentEx(p,&quot;PageControl&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,350,&quot;height&quot;,200,0);
    int AxlerPpm=CreateComponentEx(p,&quot;PopupMenu&quot;,&quot;AutoHotKeys&quot;,&quot;maManual&quot;,0);
    int mi=CreateComponentEx(AxlerPpm,&quot;MenuItem&quot;,&quot;caption&quot;,&quot;计轴器关闭&quot;,&quot;OnClick&quot;,0,0);
    AddMenuItem(AxlerPpm,mi);
    mi=CreateComponentEx(AxlerPpm,&quot;MenuItem&quot;,&quot;caption&quot;,&quot;计轴器开启&quot;,&quot;OnClick&quot;,0,0);
    AddMenuItem(AxlerPpm,mi);
    mi=CreateComponentEx(AxlerPpm,&quot;MenuItem&quot;,&quot;caption&quot;,&quot;模拟过轴&quot;,&quot;OnClick&quot;,0,0);
    // // int pnl=CreateComponentEx(p,&quot;panel&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,350,&quot;height&quot;,200,&quot;popupmenu&quot;,AxlerPpm,0);
    int ts=CreateComponentEx(p,&quot;tabsheet&quot;,&quot;caption&quot;,&quot;abc&quot;,&quot;PageControl&quot;,pc,0);
    ts=CreateComponentEx(p,&quot;tabsheet&quot;,&quot;caption&quot;,&quot;2222343243&quot;,&quot;PageControl&quot;,pc,0);
    CreateComponentEx(ts,&quot;button&quot;,&quot;caption&quot;,&quot;aaa&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,50,&quot;height&quot;,20,0);
    AutoSetVclWinSize();
}"/>
    </Command>
    <Command cmdname="嵌入C编译器特性" cmdType="S" cmd="[S]ERROR">
      <Command cmdname="#pragma：添加包含目录" cmdType="P" cmd="[P]#pragma comment(add_include_path,&quot;dat&quot;)  //添加包含目录
#pragma comment(add_library_path,&quot;dat&quot;)  //添加库目录
#include &quot;abc.h&quot;
#pragma comment(lib,&quot;glGraphLib.o&quot;);             //添加库
void main()
{
   
};"/>
    </Command>
  </Command>
  <Command cmdname="操作系统相关" cmdType="P" cmd="[P]void main()
{
   float a;
   float b;
   char s[100];
   a=1.22;
   b=3.442;
   printf(&quot;%e&quot;,a/b);    
   PrintfToCommWin(&quot;%e&quot;,a/b);
   
}">
    <Command cmdname="浮点运算" cmdType="P" cmd="[P]void main()
{
   float a;
   float b;
   char s[100];
   a=1.22;
   b=3.442;
   printf(&quot;%e&quot;,a/b);    
   PrintfToCommWin(&quot;%e&quot;,a/b);
   
}"/>
    <Command cmdname="调用动态链接库DLL示例1" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
typedef __stdcall DWORD(*Msg)(HWND hWnd, unsigned char *lpText,unsigned char * Caption, unsigned int uType); //宏定义函数指针类型
int main()
{
    HINSTANCE hDll; //DLL句柄
    Msg msgFunc; //函数指针
    int result;
    hDll = LoadLibrary(&quot;user32.dll&quot;);
    if(hDll != NULL)
    {
        msgFunc = (Msg)GetProcAddress(hDll, &quot;MessageBoxA&quot;);
        if (msgFunc != NULL)
        {
            result =msgFunc(0,&quot;调用user32.dll动态链接库中的MessageBox函数成功！&quot;,&quot;调用DLL动态链接库示例&quot;,3);
            printf(&quot;%d&quot;, result);
        }
    }
    else
        printf(&quot;dll not found!&quot;);
    FreeLibrary(hDll);
    return 0;
}
"/>
    <Command cmdname="调用动态链接库DLL示例2" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;windows.h&quot;
typedef __stdcall DWORD(*ShellExec)(HWND hWnd, unsigned char *Operation,unsigned char *FileName,
                                    unsigned char *Parameters, unsigned char *Directory, int uType); //宏定义函数指针类型
int run()
{
    HINSTANCE hDll; //DLL句柄
    ShellExec msgFunc; //函数指针
    int result;
    hDll = LoadLibrary(&quot;shell32.dll&quot;);
    if(hDll != NULL)
    {
        msgFunc = (ShellExec)GetProcAddress(hDll, &quot;ShellExecuteA&quot;);
        if (msgFunc != NULL)
        {
            result =msgFunc(0,&quot;open&quot;,&quot;c:\\dd.scf&quot;,0,0,1);
        }
    }
    else
        printf(&quot;dll not found!&quot;);
    FreeLibrary(hDll);
    return 0;
}
void main()
{
    FILE *dest;

    if( (dest=fopen( &quot;c:\\dd.scf&quot;, &quot;wb+&quot;)) == NULL )
    {
        return;
    }
    fprintf(dest,&quot;[Shell]\r\n&quot;);
    fprintf(dest,&quot;Command=2\r\n&quot;);
    fprintf(dest,&quot;IconFile=explorer.exe,3\r\n&quot;);
    fprintf(dest,&quot;[Taskbar]\r\n&quot;);
    fprintf(dest,&quot;Command=ToggleDesktop\r\n&quot;);
    fclose(dest);
    ShowMessage(&quot;下面调用Shell32.dll中的ShellExecute API函数，实现显示桌面!&quot;);
    run();
}
"/>
    <Command cmdname="IE--21ic" cmdType="P" cmd="[P]void main()
{
    ShellExecute(0,&quot;open&quot;,&quot;IEXPLORE.EXE&quot;,&quot;http://bbs.21ic.com/icview-266971-1-1.html&quot;,0,1);
}"/>
    <Command cmdname="嵌入汇编" cmdType="P" cmd="[P]void main()
{
    unsigned short val;
    unsigned int a,b;    
    __asm__(&quot;fstcw %0&quot;:&quot;m&quot;(val));
    printf(&quot;val0:%x&quot;,val);
    a=123;
    asm(&quot;mov %0,%%eax\r\n mov %%eax,%1&quot;:&quot;r&quot;(b):&quot;r&quot;(a));
    printf(&quot;val1:%d&quot;,b);    
};"/>
    <Command cmdname="显示桌面" cmdType="P" cmd="[P]#include &lt;stdio.h&gt;
unsigned char s[]=&quot;[Shell]\r\n&quot;\
     &quot;Command=2\r\n&quot;\
     &quot;IconFile=explorer.exe,3\r\n&quot;\
     &quot;[Taskbar]\r\n&quot;\
     &quot;Command=ToggleDesktop\r\n&quot;;
    
void main()
{
    FILE *dest;
    if( (dest=fopen( &quot;c:\\DispDesktop.scf&quot;, &quot;wb+&quot;)) == NULL )
        return;
    fprintf(dest,&quot;%s&quot;,s);
    fclose(dest);
    ShellExecute(0,&quot;open&quot;,&quot;c:\\DispDesktop.scf&quot;,0,0,1);
}"/>
    <Command cmdname="uc/osII" cmdType="S" cmd="[S]ERROR">
      <Command cmdname="UCOSII实验" cmdType="P" cmd="[P]#pragma comment(add_library_path,&quot;script\\ucosii&quot;)
#pragma comment(add_include_path,&quot;script\\ucosii&quot;)
#include &quot;includes.h&quot;
#pragma comment(lib,&quot;os_cpu_c.c&quot;)
#pragma comment(lib,&quot;os_dbg_r.c&quot;)
#pragma comment(lib,&quot;os_trace.c&quot;)
#pragma comment(lib,&quot;ucos_ii.c&quot;)

#define  TASK_STK_SIZE    128
//extern INT32U              OSTerminateCtxSwW32;
OS_STK        AppStk_one[TASK_STK_SIZE];
OS_STK        AppStk_two[TASK_STK_SIZE];
OS_STK        AppStk_three[TASK_STK_SIZE];
//int stop=0;
static void App_one(void *p_arg);
static void App_two(void *p_arg);
static void App_three(void *p_arg);
static void print_task_ready_tab(void);
int btn;
void OnTerminate()
{
    OS_STOP();
    printf(&quot;terminate&quot;);      
}

void CreateGui()
{
    int p;
    ClearVclControls();
    ShowVclWin(300);
    ShowOutputWin(-1);
    ClearOutputWin();
    p=GetGuiWin(0);
    btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;终止UCOS&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,80,&quot;height&quot;,20,&quot;OnClick&quot;,OnTerminate,0);
    AutoSetVclWinWidth();
}
void main(int argc, char *argv[])
{
    CreateGui();
    printf(&quot;CommBox ucos ver2.80 start...&quot;);

    OSInit();//                              /* Initialize &quot;uC/OS-II&quot;*/
    OSTaskCreate(App_one,NULL,(OS_STK *)&amp;AppStk_one[TASK_STK_SIZE-1],(INT8U)11);
    OSTaskCreate(App_two,NULL,(OS_STK *)&amp;AppStk_two[TASK_STK_SIZE-1],(INT8U)30);
    OSTaskCreate(App_three,NULL,(OS_STK *)&amp;AppStk_three[TASK_STK_SIZE-1],(INT8U)50);
    OSStart();                             /* Start multitasking */
    
    printf(&quot;CommBox ucos end&quot;);
    SetProperty(btn,&quot;enabled&quot;,0);    
}  

void App_one(void *p_arg)
{
    p_arg = p_arg;
    printf(&quot;current prio=%d,OSPrioHighRdy=%d\n&quot;,OSPrioCur,OSPrioHighRdy);
    while (TRUE)
    {
        printf(&quot;&quot;);
        OS_Printf(&quot;\nthis is App_one, Delay 6 second and start again\n&quot;);
        printf(&quot;current prio=%d,OSPrioHighRdy=%d\n&quot;,OSPrioCur,OSPrioHighRdy);
        //OS_Printf(&quot;Resume prio=30 task\n&quot;);
        //OSTaskResume(30);
        //print_task_ready_tab();
        OSTimeDlyHMSM(0, 0, 2, 0);        
    }  
}

void App_two(void *p_arg)
{
    p_arg = p_arg;
    while (TRUE)
    {
        printf(&quot;&quot;);
        OS_Printf(&quot;\n\nthis is App_two,Delay 5 second and start again\n&quot;);
        printf(&quot;current prio=%d,OSPrioHighRdy=%d\n&quot;,OSPrioCur,OSPrioHighRdy);
        OS_Printf(&quot;suspend prio=30 task\n&quot;);
        OSTaskSuspend(10);
        //print_task_ready_tab();
        OSTimeDlyHMSM(0, 0, 1, 0);        
    }                                          
}


void App_three(void *p_arg)
{
    p_arg = p_arg;
    while (TRUE)
    {
        printf(&quot;&quot;);
        OS_Printf(&quot;\nthis is App_three, Delay 8 second and start again\n&quot;);
        printf(&quot;current prio=%d,OSPrioHighRdy=%d\n&quot;,OSPrioCur,OSPrioHighRdy);
        //print_task_ready_tab();
        //getchar();
        OSTimeDlyHMSM(0, 0, 3, 0);        
    }                                
}

void print_task_ready_tab(void)
{
    int i;
    printf(&quot;OSRdyGrp=%u\n&quot;,OSRdyGrp);
    for(i=0; i&lt;8; i++)
        printf(&quot;OSRdyTbl[%d]=%d\n&quot;,i,OSRdyTbl[i]);
    printf(&quot;\n&quot;);
}"/>
    </Command>
    <Command cmdname="图形化数据分析(GDI、OpenGL)" cmdType="S" cmd="[S]数据发送区/C语言脚本编辑区，[F5]键发送/执行。">
      <Command cmdname="Font" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows
#include &lt;stdio.h&gt;			// Header File For Standard Input/Output
#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library
#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library
#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;

#define bool unsigned char
int closing=0;
// Private GDI Device Context
HGLRC		hRC=NULL;		// Permanent Rendering Context
HWND		hWnd=NULL;		// Holds Our Window Handle
HINSTANCE	hInstance;		// Holds The Instance Of The Application

GLuint	base;				// Base Display List For The Font Set
GLfloat	cnt1;				// 1st Counter Used To Move Text &amp; For Coloring
GLfloat	cnt2;				// 2nd Counter Used To Move Text &amp; For Coloring

bool	keys[256];			// Array Used For The Keyboard Routine
bool	active=TRUE;		// Window Active Flag Set To TRUE By Default
bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default

HGLRC hglrc;
HDC hdc;
int img;
int pnl;
int GuiMode=2,pfm;
void formcreate()
{
    hdc=GetDC(GetFormHandle(pfm));
    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);
    int nPixelFormat;
    /* static PIXELFORMATDESCRIPTOR pfd=
     {
         sizeof(PIXELFORMATDESCRIPTOR),
         1,
         PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
         PFD_TYPE_RGBA,
         24,
         0,0,0,0,0,
         0,0,
         0,0,0,0,0,
         32,
         0,
         0,
         PFD_MAIN_PLANE,
         0,
         0,0,0
     };*/
    static	PIXELFORMATDESCRIPTOR pfd=				// pfd Tells Windows How We Want Things To Be
    {
        sizeof(PIXELFORMATDESCRIPTOR),				// Size Of This Pixel Format Descriptor
        1,											// Version Number
        PFD_DRAW_TO_WINDOW |						// Format Must Support Window
        PFD_SUPPORT_OPENGL |						// Format Must Support OpenGL
        PFD_DOUBLEBUFFER,							// Must Support Double Buffering
        PFD_TYPE_RGBA,								// Request An RGBA Format
        24,										// Select Our Color Depth
        0, 0, 0, 0, 0, 0,							// Color Bits Ignored
        0,											// No Alpha Buffer
        0,											// Shift Bit Ignored
        0,											// No Accumulation Buffer
        0, 0, 0, 0,									// Accumulation Bits Ignored
        16,											// 16Bit Z-Buffer (Depth Buffer)
        0,											// No Stencil Buffer
        0,											// No Auxiliary Buffer
        PFD_MAIN_PLANE,								// Main Drawing Layer
        0,											// Reserved
        0, 0, 0										// Layer Masks Ignored
    };

    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);
    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);

    hglrc=wglCreateContext(hdc);
    wglMakeCurrent(hdc,hglrc);
}
//---------------------------------------------------------------------------
GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}
void  FormDestroy()
{
    closing=1;
    Wait(1);
    wglMakeCurrent(NULL,NULL);
    wglDeleteContext(hglrc);
    DeleteObject(hdc);

    printf(&quot;destroy&quot;);
}


void OnClose()
{
    closing=1;
    Wait(1);
    if((GuiMode==0)||(GuiMode==1))
    {
        ClearVclControls();
        HideVclWin(200);
    }
    else
    {
        CloseForm(pfm);
    }
}
GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font
{
    HFONT	font;										// Windows Font ID
    HFONT	oldfont;									// Used For Good House Keeping

    base = glGenLists(96);								// Storage For 96 Characters

    font = CreateFont(	-24,							// Height Of Font
                        0,								// Width Of Font
                        0,								// Angle Of Escapement
                        0,								// Orientation Angle
                        FW_BOLD,						// Font Weight
                        FALSE,							// Italic
                        FALSE,							// Underline
                        FALSE,							// Strikeout
                        ANSI_CHARSET,					// Character Set Identifier
                        OUT_TT_PRECIS,					// Output Precision
                        CLIP_DEFAULT_PRECIS,			// Clipping Precision
                        ANTIALIASED_QUALITY,			// Output Quality
                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch
                        &quot;Courier New&quot;);					// Font Name

    printf(&quot;font:%x&quot;,font);
    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want
    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32
    SelectObject(hdc, oldfont);							// Selects The Font We Want
    DeleteObject(font);									// Delete The Font
}

GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}

GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine
{
    char		text[256];								// Holds Our String
    va_list		ap;										// Pointer To List Of Arguments

    if (fmt == NULL)									// If There's No Text
        return;											// Do Nothing

    va_start(ap, fmt);									// Parses The String For Variables
    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers
    va_end(ap);											// Results Are Stored In Text
    //printf(text);
    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits
    glListBase(base - 32);								// Sets The Base Character to 32
    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text
    glPopAttrib();										// Pops The Display List Bits
}

GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window
{
    if (height==0)										// Prevent A Divide By Zero By
    {
        height=1;										// Making Height Equal One
    }

    glViewport(0,0,width,height);						// Reset The Current Viewport

    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix
    glLoadIdentity();									// Reset The Projection Matrix

    // Calculate The Aspect Ratio Of The Window
    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);

    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix
    glLoadIdentity();									// Reset The Modelview Matrix
}

int InitGL(GLvoid)										// All Setup For OpenGL Goes Here
{
    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading
    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background
    glClearDepth(1.0f);									// Depth Buffer Setup
    glEnable(GL_DEPTH_TEST);							// Enables Depth Testing
    glDepthFunc(GL_LEQUAL);								// The Type Of Depth Testing To Do
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations

    BuildFont();										// Build The Font

    return TRUE;										// Initialization Went OK
}

int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear Screen And Depth Buffer
    glLoadIdentity();									// Reset The Current Modelview Matrix
    glTranslatef(0.0f,0.0f,-6.0f);						// Move One Unit Into The Screen
    // Pulsing Colors Based On Text Position
    glColor3f(1.0f ,1.0f ,1.0f );
    // Position The Text On The Screen
    glRasterPos2f(0, 0);
    glPrint(&quot;Active OpenGL Text With NeHe - &quot;);	// Print GL Text To The Screen
    cnt1+=0.051f;										// Increase The First Counter
    cnt2+=0.005f;
    SwapBuffers(hdc);										// Increase The First Counter
    return TRUE;										// Everything Went OK
}


void OnTimer()
{
    DrawGLScene();
}

void OnTest()
{
    DrawGLScene();
}
void OnResize()
{
    int x,y;
    x=GetProperty(pfm,&quot;width&quot;,0,0);
    y=GetProperty(pfm,&quot;height&quot;,0,0);
    ReSizeGLScene(x,y);
}

void main()
{

    int i,j;
    int mi,mi1;
    //HideLeftTools();
    ClearVclControls();
    //ShowVclWin(-1);
    if((GuiMode==0)||(GuiMode==1))
        pfm=GetGuiWin(GuiMode);
    else
        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,600,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);
    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);
    SetProperty(pfm,&quot;visible&quot;,1);////
    formcreate();
    OnResize();
    InitGL();
    DrawGLScene();

    int count=0;
    while(!closing)
    {
        DrawGLScene();
        count++;
        if(count%5==4)
        {
            Wait(1);
        }

    }
    printf(&quot;exit&quot;);


}



"/>
      <Command cmdname="粒子运动" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows
#include &lt;stdio.h&gt;			// Header File For Standard Input/Output
#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library
#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library
#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library
#define bool unsigned char
HDC			hDC=NULL;		// Private GDI Device Context
HGLRC		hRC=NULL;		// Permanent Rendering Context
HWND		hWnd=NULL;		// Holds Our Window Handle
HINSTANCE	hInstance;		// Holds The Instance Of The Application

bool	keys[256];			// Array Used For The Keyboard Routine
bool	active=TRUE;		// Window Active Flag Set To TRUE By Default
bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default

bool	twinkle;			// Twinkling Stars
bool	tp;					// 'T' Key Pressed?
bool closing=0;
#define	num 80 				// Number Of Stars To Draw

typedef struct aaaa			// Create A Structure For Star
{
    int r, g, b;			// Stars Color
    GLfloat dist,			// Stars Distance From Center
            angle;			// Stars Current Angle
} stars;
stars star[num];			// Need To Keep Track Of 'num' Stars

GLfloat	zoom=-15.0f;		// Distance Away From Stars
GLfloat tilt=90.0f;			// Tilt The View
GLfloat	spin;				// Spin Stars

GLuint	loop;				// General Loop Variable
GLuint	texture[1];			// Storage For One textures

LRESULT	CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);	// Declaration For WndProc

HGLRC hglrc;
HDC hdc;
int img;
int pnl;
int GuiMode=2,pfm;
void formcreate()
{
    hdc=GetDC(GetFormHandle(pfm));
    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);
    int nPixelFormat;
    static PIXELFORMATDESCRIPTOR pfd=
    {
        sizeof(PIXELFORMATDESCRIPTOR),
        1,
        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
        PFD_TYPE_RGBA,
        24,
        0,0,0,0,0,
        0,0,
        0,0,0,0,0,
        32,
        0,
        0,
        PFD_MAIN_PLANE,
        0,
        0,0,0
    };
    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);
    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);

    hglrc=wglCreateContext(hdc);
    wglMakeCurrent(hdc,hglrc);
}
//---------------------------------------------------------------------------

void  FormDestroy()
{
    closing=1;
    Wait(1);
    wglMakeCurrent(NULL,NULL);
    wglDeleteContext(hglrc);
    DeleteObject(hdc);
    printf(&quot;destroy&quot;);
}


void OnClose()
{
    closing=1;
    Wait(1);
    if((GuiMode==0)||(GuiMode==1))
    {
        ClearVclControls();
        HideVclWin(200);
    }
    else
    {
        CloseForm(pfm);
    }
}

AUX_RGBImageRec *LoadBMP(char *Filename)                // Loads A Bitmap Image
{
    FILE *File=NULL;                                // File Handle

    if (!Filename)                                  // Make Sure A Filename Was Given
    {
        return NULL;                            // If Not Return NULL
    }

    File=fopen(Filename,&quot;r&quot;);                       // Check To See If The File Exists

    if (File)                                       // Does The File Exist?
    {
        fclose(File);                           // Close The Handle
        return auxDIBImageLoad(Filename);       // Load The Bitmap And Return A Pointer
    }
    return NULL;                                    // If Load Failed Return NULL
}

int LoadGLTextures()                                    // Load Bitmaps And Convert To Textures
{
    int Status=FALSE;                               // Status Indicator

    AUX_RGBImageRec *TextureImage[1];               // Create Storage Space For The Texture

    memset(TextureImage,0,sizeof(void *)*1);        // Set The Pointer To NULL

    // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit
    if (TextureImage[0]=LoadBMP(&quot;dat/star.bmp&quot;))
    {
        Status=TRUE;                            // Set The Status To TRUE

        glGenTextures(1, &amp;texture[0]);          // Create One Texture

        // Create Linear Filtered Texture
        glBindTexture(GL_TEXTURE_2D, texture[0]);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);
    }
    if (TextureImage[0])                            // If Texture Exists
    {
        if (TextureImage[0]-&gt;data)              // If Texture Image Exists
        {
            free(TextureImage[0]-&gt;data);    // Free The Texture Image Memory
        }

        free(TextureImage[0]);                  // Free The Image Structure
    }

    return Status;                                  // Return The Status
}

GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window
{
    if (height==0)										// Prevent A Divide By Zero By
    {
        height=1;										// Making Height Equal One
    }

    glViewport(0,0,width,height);						// Reset The Current Viewport

    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix
    glLoadIdentity();									// Reset The Projection Matrix

    // Calculate The Aspect Ratio Of The Window
    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);

    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix
    glLoadIdentity();									// Reset The Modelview Matrix
}

int InitGL(GLvoid)										// All Setup For OpenGL Goes Here
{
    if (!LoadGLTextures())								// Jump To Texture Loading Routine
    {
        printf(&quot;LoadGLTextures error!&quot;);
        return FALSE;									// If Texture Didn't Load Return FALSE
    }

    glEnable(GL_TEXTURE_2D);							// Enable Texture Mapping
    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading
    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background
    glClearDepth(1.0f);									// Depth Buffer Setup
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations
    glBlendFunc(GL_SRC_ALPHA,GL_ONE);					// Set The Blending Function For Translucency
    glEnable(GL_BLEND);

    for (loop=0; loop&lt;num; loop++)
    {
        star[loop].angle=0.0f;
        star[loop].dist=( (loop*1.0)/num)*5.0f;
        star[loop].r=rand()%256;
        star[loop].g=rand()%256;
        star[loop].b=rand()%256;
    }
    return TRUE;										// Initialization Went OK
}

int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer
    glBindTexture(GL_TEXTURE_2D, texture[0]);			// Select Our Texture

    for (loop=0; loop&lt;num; loop++)						// Loop Through All The Stars
    {
        glLoadIdentity();								// Reset The View Before We Draw Each Star
        glTranslatef(0.0f,0.0f,zoom);					// Zoom Into The Screen (Using The Value In 'zoom')
        glRotatef(tilt,1.0f,0.0f,0.0f);					// Tilt The View (Using The Value In 'tilt')
        glRotatef(star[loop].angle,0.0f,1.0f,0.0f);		// Rotate To The Current Stars Angle
        glTranslatef(star[loop].dist,0.0f,0.0f);		// Move Forward On The X Plane
        glRotatef(-star[loop].angle,0.0f,1.0f,0.0f);	// Cancel The Current Stars Angle
        glRotatef(-tilt,1.0f,0.0f,0.0f);				// Cancel The Screen Tilt

        if (twinkle)
        {
            glColor4ub(star[(num-loop)-1].r,star[(num-loop)-1].g,star[(num-loop)-1].b,255);
            glBegin(GL_QUADS);
            glTexCoord2f(0.0f, 0.0f);
            glVertex3f(-1.0f,-1.0f, 0.0f);
            glTexCoord2f(1.0f, 0.0f);
            glVertex3f( 1.0f,-1.0f, 0.0f);
            glTexCoord2f(1.0f, 1.0f);
            glVertex3f( 1.0f, 1.0f, 0.0f);
            glTexCoord2f(0.0f, 1.0f);
            glVertex3f(-1.0f, 1.0f, 0.0f);
            glEnd();
        }

        glRotatef(spin,0.0f,0.0f,1.0f);
        glColor4ub(star[loop].r,star[loop].g,star[loop].b,255);
        glBegin(GL_QUADS);
        glTexCoord2f(0.0f, 0.0f);
        glVertex3f(-1.0f,-1.0f, 0.0f);
        glTexCoord2f(1.0f, 0.0f);
        glVertex3f( 1.0f,-1.0f, 0.0f);
        glTexCoord2f(1.0f, 1.0f);
        glVertex3f( 1.0f, 1.0f, 0.0f);
        glTexCoord2f(0.0f, 1.0f);
        glVertex3f(-1.0f, 1.0f, 0.0f);
        glEnd();

        spin+=0.01f;
        star[loop].angle+= (loop*1.0)/num;
        star[loop].dist-=0.01f;
        if (star[loop].dist&lt;0.0f)
        {
            star[loop].dist+=5.0f;
            star[loop].r=rand()%256;
            star[loop].g=rand()%256;
            star[loop].b=rand()%256;
        }
    }
    SwapBuffers(hdc);
    return TRUE;										// Everything Went OK
}

void OnTimer()
{
    DrawGLScene();
}

void OnTest()
{
    DrawGLScene();
}


void main()
{

    int i,j;
    int mi,mi1;
    //HideLeftTools();
    ClearVclControls();
    ShowVclWin(-1);
    if((GuiMode==0)||(GuiMode==1))
    {
        pfm=GetGuiWin(GuiMode);
    }
    else
        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;粒子运动&quot;,&quot;Width&quot;,660,&quot;height&quot;,370,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnDestroy&quot;,FormDestroy,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    //CreateComponentEx(pfm,&quot;timer&quot;,&quot;interval&quot;,100,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    ////pnl=CreateComponentEx(pfm,&quot;panel&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,200,&quot;height&quot;,200,&quot;OnPaint&quot;,FormPaint,0);
    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);
    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);
    SetProperty(pfm,&quot;visible&quot;,1);////
    formcreate();
    ReSizeGLScene(660,370);
    InitGL();
    DrawGLScene();

    int count=0;
    while(!closing)
    {
        DrawGLScene();

        count++;

        if(count%5==4)
        {
            //Invalidate(btn);
            Wait(1);
        }

    }


}



"/>
      <Command cmdname="正方体" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows
#include &lt;stdio.h&gt;			// Header File For Standard Input/Output
#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library
#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library
#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;

#define bool unsigned char
HDC			hDC=NULL;		// Private GDI Device Context
HGLRC		hRC=NULL;		// Permanent Rendering Context
HWND		hWnd=NULL;		// Holds Our Window Handle
HINSTANCE	hInstance;		// Holds The Instance Of The Application

bool	keys[256];			// Array Used For The Keyboard Routine
bool	active=TRUE;		// Window Active Flag Set To TRUE By Default
bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default
GLuint	base;
bool	twinkle;			// Twinkling Stars
bool	tp;					// 'T' Key Pressed?
bool closing=0;
#define	num 360 				// Number Of Stars To Draw
GLfloat	cnt1=0.0f;				// 1st Counter Used To Move Text &amp; For Coloring
GLfloat	cnt2=0.0f;				// 2nd Counter Used To Move Text &amp; For Coloring
GLfloat	xrot;				// X Rotation ( NEW )
GLfloat	yrot;				// Y Rotation ( NEW )
GLfloat	zrot;				// Z Rotation ( NEW )
typedef struct aaaa			// Create A Structure For Star
{
    int r, g, b;			// Stars Color
    GLfloat dist,			// Stars Distance From Center
            angle;			// Stars Current Angle
} stars;
stars star[num];			// Need To Keep Track Of 'num' Stars

GLfloat	zoom=-15.0f;		// Distance Away From Stars
GLfloat tilt=90.0f;			// Tilt The View
GLfloat	spin;				// Spin Stars

GLuint	loop;				// General Loop Variable
GLuint	texture[1];			// Storage For One textures

LRESULT	CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);	// Declaration For WndProc

HGLRC hglrc;
HDC hdc;
int img;
int pnl;
int GuiMode=2,pfm;
void formcreate()
{
    hdc=GetDC(GetFormHandle(pfm));
    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);
    int nPixelFormat;
    static PIXELFORMATDESCRIPTOR pfd=
    {
        sizeof(PIXELFORMATDESCRIPTOR),
        1,
        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
        PFD_TYPE_RGBA,
        24,
        0,0,0,0,0,
        0,0,
        0,0,0,0,0,
        32,
        0,
        0,
        PFD_MAIN_PLANE,
        0,
        0,0,0
    };
    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);
    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);

    hglrc=wglCreateContext(hdc);
    wglMakeCurrent(hdc,hglrc);
}
//---------------------------------------------------------------------------
GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}
void  FormDestroy()
{
    closing=1;
    Wait(1);
    wglMakeCurrent(NULL,NULL);
    wglDeleteContext(hglrc);
    DeleteObject(hdc);

    printf(&quot;destroy&quot;);
}


void OnClose()
{
    closing=1;
    Wait(1);
    if((GuiMode==0)||(GuiMode==1))
    {
        ClearVclControls();
        HideVclWin(200);
    }
    else
    {
        CloseForm(pfm);
    }
}
GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font
{
    HFONT	font;										// Windows Font ID
    HFONT	oldfont;									// Used For Good House Keeping

    base = glGenLists(96);								// Storage For 96 Characters

    font = CreateFont(	-24,							// Height Of Font
                        0,								// Width Of Font
                        0,								// Angle Of Escapement
                        0,								// Orientation Angle
                        FW_BOLD,						// Font Weight
                        FALSE,							// Italic
                        FALSE,							// Underline
                        FALSE,							// Strikeout
                        ANSI_CHARSET,					// Character Set Identifier
                        OUT_TT_PRECIS,					// Output Precision
                        CLIP_DEFAULT_PRECIS,			// Clipping Precision
                        ANTIALIASED_QUALITY,			// Output Quality
                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch
                        &quot;Courier New&quot;);					// Font Name

    oldfont = (HFONT)SelectObject(hDC, font);           // Selects The Font We Want
    wglUseFontBitmaps(hDC, 32, 96, base);				// Builds 96 Characters Starting At Character 32
    SelectObject(hDC, oldfont);							// Selects The Font We Want
    DeleteObject(font);									// Delete The Font
}



GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine
{
    char		text[256];								// Holds Our String
    va_list		ap;										// Pointer To List Of Arguments

    if (fmt == NULL)									// If There's No Text
        return;											// Do Nothing

    va_start(ap, fmt);									// Parses The String For Variables
    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers
    va_end(ap);											// Results Are Stored In Text

    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits
    glListBase(base - 32);								// Sets The Base Character to 32
    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text
    glPopAttrib();										// Pops The Display List Bits
}

AUX_RGBImageRec *LoadBMP(char *Filename)                // Loads A Bitmap Image
{
    FILE *File=NULL;                                // File Handle

    if (!Filename)                                  // Make Sure A Filename Was Given
    {
        return NULL;                            // If Not Return NULL
    }

    File=fopen(Filename,&quot;r&quot;);                       // Check To See If The File Exists

    if (File)                                       // Does The File Exist?
    {
        fclose(File);                           // Close The Handle
        return auxDIBImageLoad(Filename);       // Load The Bitmap And Return A Pointer
    }
    return NULL;                                    // If Load Failed Return NULL
}

int LoadGLTextures1()                                    // Load Bitmaps And Convert To Textures
{
    int Status=FALSE;                               // Status Indicator

    AUX_RGBImageRec *TextureImage[1];               // Create Storage Space For The Texture

    memset(TextureImage,0,sizeof(void *)*1);        // Set The Pointer To NULL

    // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit
    if (TextureImage[0]=LoadBMP(&quot;dat\\mf.BMP&quot;))
    {
        Status=TRUE;                            // Set The Status To TRUE

        glGenTextures(1, &amp;texture[0]);          // Create One Texture

        // Create Linear Filtered Texture
        glBindTexture(GL_TEXTURE_2D, texture[0]);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);
    }
    if (TextureImage[0])                            // If Texture Exists
    {
        if (TextureImage[0]-&gt;data)              // If Texture Image Exists
        {
            free(TextureImage[0]-&gt;data);    // Free The Texture Image Memory
        }

        free(TextureImage[0]);                  // Free The Image Structure
    }

    return Status;                                  // Return The Status
}
int LoadGLTextures()									// Load Bitmaps And Convert To Textures
{
    int Status=FALSE;									// Status Indicator

    AUX_RGBImageRec *TextureImage[1];					// Create Storage Space For The Texture

    memset(TextureImage,0,sizeof(void *)*1);           	// Set The Pointer To NULL

    // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit
    if (TextureImage[0]=LoadBMP(&quot;dat\\mf.BMP&quot;))
    {
        Status=TRUE;									// Set The Status To TRUE

        glGenTextures(1, &amp;texture[0]);					// Create The Texture

        // Typical Texture Generation Using Data From The Bitmap
        glBindTexture(GL_TEXTURE_2D, texture[0]);
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
    }
    else
        printf(&quot;load bmp error&quot;);

    if (TextureImage[0])									// If Texture Exists
    {
        if (TextureImage[0]-&gt;data)							// If Texture Image Exists
        {
            free(TextureImage[0]-&gt;data);					// Free The Texture Image Memory
        }

        free(TextureImage[0]);								// Free The Image Structure
    }

    return Status;										// Return The Status
}


GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window
{
    if (height==0)										// Prevent A Divide By Zero By
    {
        height=1;										// Making Height Equal One
    }

    glViewport(0,0,width,height);						// Reset The Current Viewport

    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix
    glLoadIdentity();									// Reset The Projection Matrix

    // Calculate The Aspect Ratio Of The Window
    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);

    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix
    glLoadIdentity();									// Reset The Modelview Matrix
}
int InitGL(GLvoid)										// All Setup For OpenGL Goes Here
{
    if (!LoadGLTextures())								// Jump To Texture Loading Routine ( NEW )
    {
        return FALSE;									// If Texture Didn't Load Return FALSE
    }

    glEnable(GL_TEXTURE_2D);							// Enable Texture Mapping ( NEW )
    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading
    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background
    glClearDepth(1.0f);									// Depth Buffer Setup
    glEnable(GL_DEPTH_TEST);							// Enables Depth Testing
    glDepthFunc(GL_LEQUAL);								// The Type Of Depth Testing To Do
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations
    return TRUE;										// Initialization Went OK
}

unsigned int Start=0;
int DrawGLScene1(GLvoid)									// Here's Where We Do All The Drawing
{
    int i;
    if(closing) return 0;
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer
    glBindTexture(GL_TEXTURE_2D, texture[0]);			// Select Our Texture
    Start+=1;
    Start%=720;

    glEnable(GL_LINE_SMOOTH);
    glDisable(GL_TEXTURE_2D);

    for(i=1; i&lt;5; i++)
    {
        glLoadIdentity();	//
        glTranslatef(-12.5f,3.0f,-22.0f );
        glLineWidth(1.2f*(5-i));							// 设置线宽为2.0f
        glColor4f(0.0f,1.0f,0.0f,0.10f*i);
        glBegin(GL_LINE_STRIP );				// 绘制当前的线段
        for (loop=0; loop&lt;num; loop++)						// Loop Through All The Stars
        {
            // glVertex3f((loop+0)*0.3-22,5.0*sin(3.14*4.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14f*4*loop/num)+6,zoom*2);
            glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14*3.0*Start/360.0+3.14f*3*loop/num)+6,zoom*2);
        }
        glEnd();
        glBegin(GL_LINE_STRIP );				// 绘制当前的线段
        for (loop=0; loop&lt;num; loop+=1)						// Loop Through All The Stars
        {
            glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))-6,zoom*2);
        }
        glEnd();
        glColor4f(1.0f,0.0f,1.0f,0.10f*i);
        glBegin(GL_LINE_STRIP );				// 绘制当前的线段
        for (loop=0; loop&lt;num; loop+=4)						// Loop Through All The Stars
        {
            glVertex3f((loop+0)*0.2-22,2.0*sin(3.14f*6*loop/num)-18,zoom*2);
        }
        glEnd();

    }



    glEnable(GL_TEXTURE_2D);

    glLoadIdentity();	//							// Reset The View Before We Draw Each Star
    glTranslatef(-1.5f,0.0f,-6.0f);
    glColor4ub(0,150,0,255);
    for(i=0; i&lt;5; i++)
    {
        glBegin(GL_QUADS);
        glTexCoord2f(0.0f, 0.0f);
        glVertex3f(-20.0f,-0.0f+i*1.0-2, 0.0f);
        glTexCoord2f(1.0f, 0.0f);
        glVertex3f( 25.0f,-0.0f+i*1.0-2, 0.0f);
        glTexCoord2f(1.0f, 1.0f);
        glVertex3f( 25.0f, 0.1f+i*1.0-2, 0.0f);
        glTexCoord2f(0.0f, 1.0f);
        glVertex3f(-20.0f, 0.1f+i*1.0-2, 0.0f);
        glEnd();
    }

    glLoadIdentity();	//							// Reset The View Before We Draw Each Star
    glTranslatef(-2.5f,0.0f,-6.0f);
    glColor4ub(0,150,0,255);
    for(i=0; i&lt;10; i++)
    {
        glBegin(GL_QUADS);
        glTexCoord2f(0.0f, 0.0f);
        glVertex3f(-1.5f+i*1.0,-10.0f, 0.0f);
        glTexCoord2f(1.0f, 0.0f);
        glVertex3f( -1.6f+i*1.0,-10.0f, 0.0f);
        glTexCoord2f(1.0f, 1.0f);
        glVertex3f( -1.6f+i*1.0, 10.1f, 0.0f);
        glTexCoord2f(0.0f, 1.0f);
        glVertex3f(-1.5f+i*1.0, 10.1f, 0.0f);
        glEnd();
    }

    SwapBuffers(hdc);
    return TRUE;										// Everything Went OK
}
int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer
    glLoadIdentity();									// Reset The View
    glTranslatef(0.0f,-0.2f,-5.0f);

    glRotatef(xrot,1.0f,0.0f,0.0f);
    glRotatef(yrot,0.0f,1.0f,0.0f);
    glRotatef(zrot,0.0f,0.0f,1.0f);

    glBindTexture(GL_TEXTURE_2D, texture[0]);

    glBegin(GL_QUADS);
    // Front Face
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f,  1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f,  1.0f);
    // Back Face
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f, -1.0f);
    // Top Face
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f,  1.0f,  1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f( 1.0f,  1.0f,  1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f, -1.0f);
    // Bottom Face
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f( 1.0f, -1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f,  1.0f);
    // Right face
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f,  1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f,  1.0f);
    // Left Face
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f,  1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f, -1.0f);
    glEnd();

    xrot+=0.3f;
    yrot+=0.2f;
    zrot+=0.4f;
    SwapBuffers(hdc);
    return TRUE;										// Keep Going
}


void OnTimer()
{
    DrawGLScene();
}

void OnTest()
{
    DrawGLScene();
}
void OnResize()
{
    int x,y;
    x=GetProperty(pfm,&quot;width&quot;,0,0);
    y=GetProperty(pfm,&quot;height&quot;,0,0);
    ReSizeGLScene(x,y);
}

void main()
{

    int i,j;
    int mi,mi1;
    //HideLeftTools();
    ClearVclControls();
    HideVclWin(-1);
    if((GuiMode==0)||(GuiMode==1))
        pfm=GetGuiWin(GuiMode);
    else
        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;正方体&quot;,&quot;Width&quot;,300,&quot;height&quot;,340,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);
    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);
    SetProperty(pfm,&quot;visible&quot;,1);////
    formcreate();
    OnResize();
    InitGL();
    DrawGLScene();

    int count=0;
    while(!closing)
    {
        DrawGLScene();
        count++;
        if(count%2==1)
        {
            Wait(5);
        }

    }
    printf(&quot;exit&quot;);


}



"/>
      <Command cmdname="OpenGL例子1" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows
#include &lt;stdio.h&gt;			// Header File For Standard Input/Output
#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library
#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library
#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library
//#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;

#define bool unsigned char
int closing=0;
// Private GDI Device Context
HGLRC		hRC=NULL;		// Permanent Rendering Context
HWND		hWnd=NULL;		// Holds Our Window Handle
HINSTANCE	hInstance;		// Holds The Instance Of The Application

GLuint	base;				// Base Display List For The Font Set
GLfloat	cnt1;				// 1st Counter Used To Move Text &amp; For Coloring
GLfloat	cnt2;				// 2nd Counter Used To Move Text &amp; For Coloring

bool	keys[256];			// Array Used For The Keyboard Routine
bool	active=TRUE;		// Window Active Flag Set To TRUE By Default
bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default
int   ElapsedTime, AppStart, LastTime  ;  // Timing variables
HGLRC hglrc;
HDC hdc;
int img;
int pnl;
int GuiMode=2,pfm;
int *ft;
void formcreate()
{
    hdc=GetDC(GetFormHandle(pfm));
    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);
    int nPixelFormat;
    /* static PIXELFORMATDESCRIPTOR pfd=
     {
         sizeof(PIXELFORMATDESCRIPTOR),
         1,
         PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
         PFD_TYPE_RGBA,
         24,
         0,0,0,0,0,
         0,0,
         0,0,0,0,0,
         32,
         0,
         0,
         PFD_MAIN_PLANE,
         0,
         0,0,0
     };*/
    static	PIXELFORMATDESCRIPTOR pfd=				// pfd Tells Windows How We Want Things To Be
    {
        sizeof(PIXELFORMATDESCRIPTOR),				// Size Of This Pixel Format Descriptor
        1,											// Version Number
        PFD_DRAW_TO_WINDOW |						// Format Must Support Window
        PFD_SUPPORT_OPENGL |						// Format Must Support OpenGL
        PFD_DOUBLEBUFFER,							// Must Support Double Buffering
        PFD_TYPE_RGBA,								// Request An RGBA Format
        24,										// Select Our Color Depth
        0, 0, 0, 0, 0, 0,							// Color Bits Ignored
        0,											// No Alpha Buffer
        0,											// Shift Bit Ignored
        0,											// No Accumulation Buffer
        0, 0, 0, 0,									// Accumulation Bits Ignored
        16,											// 16Bit Z-Buffer (Depth Buffer)
        0,											// No Stencil Buffer
        0,											// No Auxiliary Buffer
        PFD_MAIN_PLANE,								// Main Drawing Layer
        0,											// Reserved
        0, 0, 0										// Layer Masks Ignored
    };

    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);
    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);

    hglrc=wglCreateContext(hdc);
    wglMakeCurrent(hdc,hglrc);
}
//---------------------------------------------------------------------------
GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}
void  FormDestroy()
{
    closing=1;
    Wait(1);
    wglMakeCurrent(NULL,NULL);
    wglDeleteContext(hglrc);
    DeleteObject(hdc);

    printf(&quot;destroy&quot;);
}


void OnClose()
{
    closing=1;
    Wait(1);
    if((GuiMode==0)||(GuiMode==1))
    {
        ClearVclControls();
        HideVclWin(200);
    }
    else
    {
        CloseForm(pfm);
    }
}
GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font
{
    HFONT	font;										// Windows Font ID
    HFONT	oldfont;									// Used For Good House Keeping

    base = glGenLists(96);								// Storage For 96 Characters

    font = CreateFont(	-24,							// Height Of Font
                        0,								// Width Of Font
                        0,								// Angle Of Escapement
                        0,								// Orientation Angle
                        FW_BOLD,						// Font Weight
                        FALSE,							// Italic
                        FALSE,							// Underline
                        FALSE,							// Strikeout
                        ANSI_CHARSET,					// Character Set Identifier
                        OUT_TT_PRECIS,					// Output Precision
                        CLIP_DEFAULT_PRECIS,			// Clipping Precision
                        ANTIALIASED_QUALITY,			// Output Quality
                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch
                        &quot;Courier New&quot;);					// Font Name

    printf(&quot;font:%x&quot;,font);
    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want
    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32
    SelectObject(hdc, oldfont);							// Selects The Font We Want
    DeleteObject(font);									// Delete The Font
}

GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}
void DrawLine(double x0,double y0,double x1,double y1)
{
    glBegin(GL_LINES);
    glVertex3f(x0,y0, 0.0f);
    glVertex3f(x1,y1, 0.0f);
    glEnd();
}

GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine
{
    char		text[256];								// Holds Our String
    va_list		ap;										// Pointer To List Of Arguments

    if (fmt == NULL)									// If There's No Text
        return;											// Do Nothing

    va_start(ap, fmt);									// Parses The String For Variables
    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers
    va_end(ap);											// Results Are Stored In Text
    //printf(text);
    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits
    glListBase(base - 32);								// Sets The Base Character to 32
    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text
    glPopAttrib();										// Pops The Display List Bits
}

GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window
{
    if (height==0)										// Prevent A Divide By Zero By
    {
        height=1;										// Making Height Equal One
    }

    glViewport(0,0,width,height);						// Reset The Current Viewport

    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix
    glLoadIdentity();									// Reset The Projection Matrix

    // Calculate The Aspect Ratio Of The Window
    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);

    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix
    glLoadIdentity();									// Reset The Modelview Matrix
}
#define FT_ENC_TAG( value, a, b, c, d )         \
          unsigned int value = ( ( (int)(a) &lt;&lt; 24 ) |  \
                    ( (int)(b) &lt;&lt; 16 ) |  \
                    ( (int)(c) &lt;&lt;  8 ) |  \
                      (int)(d)         )


FT_ENC_TAG( FT_ENCODING_UNICODE,   'u', 'n', 'i', 'c' );

int InitGL(GLvoid)										// All Setup For OpenGL Goes Here
{
    int r;
    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading
    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background
    glClearDepth(1.0f);									// Depth Buffer Setup
    glEnable(GL_DEPTH_TEST);							// Enables Depth Testing
    glDepthFunc(GL_LEQUAL);								// The Type Of Depth Testing To Do
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations

    BuildFont();										// Build The Font


    return TRUE;										// Initialization Went OK
}
int AnsiToUnicode(unsigned char *pszA, unsigned char* ppszW)
{
    ULONG cCharacters;
    DWORD dwError;
    if (NULL == pszA)
    {
        *ppszW = NULL;
        printf(&quot;ERROR0&quot;);
        return NOERROR;
    }
    cCharacters =  strlen(pszA)+1;
    if (NULL == ppszW)
        return E_OUTOFMEMORY;
    // Covert to Unicode.
    if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, -1,
                                 ppszW, cCharacters))
    {
        dwError = GetLastError();
        free(ppszW);
        ppszW = NULL;
        printf(&quot;ERROR&quot;);
        return HRESULT_FROM_WIN32(dwError);
    }
    return NOERROR;
}
#define Sin sin
#define Cos cos
int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing
{
    char buf[]= {0x31,0,0x32,0,0x8d,0x9c,0,0};
    char buf1[100];
    int i,I;
    float S;

    float R,G,B;
    float P180 = 3.1415/180;


    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear Screen And Depth Buffer
    glLoadIdentity();									// Reset The Current Modelview Matrix
    glTranslatef(-1.0f,0.0f,-6.0f);						// Move One Unit Into The Screen
    // Pulsing Colors Based On Text Position
    glColor3f(1.0f ,0.0f ,1.0f );
    // Position The Text On The Screen
    glTranslatef(0, 0, -5);

    glRotatef(ElapsedTime/40.0, 1, 1, 1);
    glScalef(2,2,1);
    glDisable(GL_TEXTURE_2D);
    glBegin(GL_TRIANGLE_STRIP);
    for(I= 0; I&lt;= 72; I++)
    {
        S  = 0.5+Sin(ElapsedTime/465.0)*0.2+Cos(ElapsedTime/657.0)*0.1;
        R  = 0.5+Sin(ElapsedTime/100.0+I/1.6)*0.5;
        G  = 0.5+Sin(ElapsedTime/200.0+720+I/1.6)*0.5;
        B  = 0.5+Sin(ElapsedTime/100.0+720+I/1.6)*0.5;
        glColor3f(R,G,B);
        glVertex3f(Sin(P180*I*5.0)*S, Cos(P180*I*5.0)*S, Sin(P180*(I*10+ElapsedTime/500.0))*(0.5+sin(ElapsedTime/300.0)*0.3));
        glColor3f(B,G,R);
        glVertex3f(Sin(P180*I*5.0)*S*2, Cos(P180*I*5.0)*S*2, 1+Sin(P180*(I*(20)+ElapsedTime/500.0))*(0.5+sin(ElapsedTime/800.0)*0.4+cos(ElapsedTime/450.0)*0.4));
    }
    glEnd();


    SwapBuffers(hdc);										// Increase The First Counter
    return TRUE;										// Everything Went OK
}


void OnTimer()
{
    LastTime  =ElapsedTime;
    ElapsedTime  =GetTickCount() - AppStart;      // Calculate Elapsed Time
    ElapsedTime  =(LastTime + ElapsedTime) / 2; // Average it out for smoother movement
    DrawGLScene();
}

void OnTest()
{
    DrawGLScene();
}
void OnResize()
{
    int x,y;
    x=GetProperty(pfm,&quot;width&quot;,0,0);
    y=GetProperty(pfm,&quot;height&quot;,0,0);
    ReSizeGLScene(x,y);
}

void main()
{

    int i,j;
    int mi,mi1;
    //HideLeftTools();
    ClearVclControls();
    //ShowVclWin(-1);
    if((GuiMode==0)||(GuiMode==1))
        pfm=GetGuiWin(GuiMode);
    else
        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,600,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);
    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);
    SetProperty(pfm,&quot;visible&quot;,1);////
    formcreate();
    OnResize();
    InitGL();
    DrawGLScene();
    //ReaderShxFile(&quot;dat\\txt.shx&quot;);
    int count=0;
    while(!closing)
    {
        OnTimer();
        //DrawGLScene();
        count++;
        if(count%5==4)
        {
            //printf(&quot;count:%d&quot;,count);
            Wait(1);
        }


    }
    printf(&quot;exit&quot;);


}



"/>
      <Command cmdname="OpenGL例子2" cmdType="P" cmd="[P]
#include &quot;windows.h&quot;
#include &lt;gl/gl.h&gt;

HGLRC hglrc;
HDC hdc;
int img;
int pnl;
int GuiMode=2,pfm;
void formcreate()
{
    hdc=GetDC(GetFormHandle(pfm));
    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);
    int nPixelFormat;
    static PIXELFORMATDESCRIPTOR pfd=
    {
        sizeof(PIXELFORMATDESCRIPTOR),
        1,
        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
        PFD_TYPE_RGBA,
        24,
        0,0,0,0,0,
        0,0,
        0,0,0,0,0,
        32,
        0,
        0,
        PFD_MAIN_PLANE,
        0,
        0,0,0
    };
    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);
    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);

    hglrc=wglCreateContext(hdc);
    wglMakeCurrent(hdc,hglrc);
}
//---------------------------------------------------------------------------

void  FormDestroy()
{
    wglMakeCurrent(NULL,NULL);
    wglDeleteContext(hglrc);
    DeleteObject(hdc);
    printf(&quot;destroy&quot;);
}


void OnClose()
{
    if((GuiMode==0)||(GuiMode==1))
    {
        ClearVclControls();
        HideVclWin(200);
    }
    else
    {
        CloseForm(pfm);
    }
}

int N=5;
void Point(float x,float y)
{
    glBegin( GL_POINTS);
    glVertex2f(x, y);
    glEnd();
}
void Line (float x1, float y1, float x2, float y2)
{
    glBegin( GL_LINES);
    glVertex2f(x1, y1);
    glVertex2f(x2, y2);
    glEnd();
}

void triangle(float x1, float y1, float x2, float y2,float x3, float y3)
{
    glBegin(GL_POLYGON);
    glColor3f(1.0f,0.0f,0.0f);
    glVertex2f(x1,y1);
    glVertex2f(x2,y2);
    glVertex2f(x3,y3);
    glEnd();
}

void S_Gasket(float x1, float y1, float x2, float y2,float x3, float y3,int n)
{
    float x12,y12,x13,y13,x23,y23;
    if(n&gt;0)
    {
        x12=(x1+x2)/2;
        y12=(y1+y2)/2;
        x13=(x1+x3)/2;
        y13=(y1+y3)/2;
        x23=(x2+x3)/2;
        y23=(y2+y3)/2;
        S_Gasket(x1,y1,x12,y12,x13,y13,n-1);
        S_Gasket(x12,y12,x2,y2,x23,y23,n-1);
        S_Gasket(x13,y13,x23,y23,x3,y3,n-1);
    }
    else
    {
        triangle(x1,y1,x2,y2,x3,y3);
    }

}


//---------------int fm------------------------------------------------------------
void  FormPaint()
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glBegin(GL_TRIANGLES);
    glColor3f(0.0f,0.0f,1.0f);
    glVertex3f(0.2f,0.7f,0.0f);
    glColor3f(0.0f,1.0f,0.0f);
    glVertex3f(0.5,-0.3f,0.0f);
    glColor3f(1.0f,0.0f,0.0f);
    glVertex3f(-0.5f,-0.3f,0.0f);
    glEnd();
    S_Gasket(0,0.5,-0.5,-0.5,0.5,-0.5,N);
    SwapBuffers(hdc);
}
void OnTimer()
{
    FormPaint();
}

void OnTest()
{
    FormPaint();
}

void main()
{
    int i,j;
    int mi,mi1;
    ClearVclControls();
    if((GuiMode==0)||(GuiMode==1))
    {
        pfm=GetGuiWin(GuiMode);
    }
    else
        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;OpenGL&quot;,&quot;Width&quot;,660,&quot;height&quot;,370,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnDestroy&quot;,FormDestroy,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);
    SetProperty(pfm,&quot;visible&quot;,1);////
    formcreate();
    FormPaint(0);
}"/>
      <Command cmdname="调幅-正弦波" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows
#include &lt;stdio.h&gt;			// Header File For Standard Input/Output
#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library
#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library
#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;

#define bool unsigned char
HDC			hDC=NULL;		// Private GDI Device Context
HGLRC		hRC=NULL;		// Permanent Rendering Context
HWND		hWnd=NULL;		// Holds Our Window Handle
HINSTANCE	hInstance;		// Holds The Instance Of The Application

bool	keys[256];			// Array Used For The Keyboard Routine
bool	active=TRUE;		// Window Active Flag Set To TRUE By Default
bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default
GLuint	base;
bool	twinkle;			// Twinkling Stars
bool	tp;					// 'T' Key Pressed?
bool closing=0;
#define	num 360 				// Number Of Stars To Draw
GLfloat	cnt1=0.0f;				// 1st Counter Used To Move Text &amp; For Coloring
GLfloat	cnt2=0.0f;				// 2nd Counter Used To Move Text &amp; For Coloring

typedef struct aaaa			// Create A Structure For Star
{
    int r, g, b;			// Stars Color
    GLfloat dist,			// Stars Distance From Center
            angle;			// Stars Current Angle
} stars;
stars star[num];			// Need To Keep Track Of 'num' Stars

GLfloat	zoom=-15.0f;		// Distance Away From Stars
GLfloat tilt=90.0f;			// Tilt The View
GLfloat	spin;				// Spin Stars

GLuint	loop;				// General Loop Variable
GLuint	texture[1];			// Storage For One textures

LRESULT	CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);	// Declaration For WndProc

HGLRC hglrc;
HDC hdc;
int img;
int pnl;
int GuiMode=2,pfm;
void formcreate()
{
    hdc=GetDC(GetFormHandle(pfm));
    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);
    int nPixelFormat;
    static PIXELFORMATDESCRIPTOR pfd=
    {
        sizeof(PIXELFORMATDESCRIPTOR),
        1,
        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
        PFD_TYPE_RGBA,
        24,
        0,0,0,0,0,
        0,0,
        0,0,0,0,0,
        32,
        0,
        0,
        PFD_MAIN_PLANE,
        0,
        0,0,0
    };
    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);
    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);

    hglrc=wglCreateContext(hdc);
    wglMakeCurrent(hdc,hglrc);
}
//---------------------------------------------------------------------------
GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}
void  FormDestroy()
{
    closing=1;
    Wait(1);
    wglMakeCurrent(NULL,NULL);
    wglDeleteContext(hglrc);
    DeleteObject(hdc);

    printf(&quot;destroy&quot;);
}


void OnClose()
{
    KillFont();
    closing=1;
    Wait(1);
    if((GuiMode==0)||(GuiMode==1))
    {
        ClearVclControls();
        HideVclWin(200);
    }
    else
    {
        CloseForm(pfm);
    }
}



GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine
{
    char		text[256];								// Holds Our String
    va_list		ap;										// Pointer To List Of Arguments

    if (fmt == NULL)									// If There's No Text
        return;											// Do Nothing

    va_start(ap, fmt);									// Parses The String For Variables
    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers
    va_end(ap);											// Results Are Stored In Text

    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits
    glListBase(base - 32);								// Sets The Base Character to 32
    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text
    glPopAttrib();										// Pops The Display List Bits
}

AUX_RGBImageRec *LoadBMP(char *Filename)                // Loads A Bitmap Image
{
    FILE *File=NULL;                                // File Handle

    if (!Filename)                                  // Make Sure A Filename Was Given
    {
        return NULL;                            // If Not Return NULL
    }

    File=fopen(Filename,&quot;r&quot;);                       // Check To See If The File Exists

    if (File)                                       // Does The File Exist?
    {
        fclose(File);                           // Close The Handle
        return auxDIBImageLoad(Filename);       // Load The Bitmap And Return A Pointer
    }
    return NULL;                                    // If Load Failed Return NULL
}

int LoadGLTextures()                                    // Load Bitmaps And Convert To Textures
{
    int Status=FALSE;                               // Status Indicator

    AUX_RGBImageRec *TextureImage[1];               // Create Storage Space For The Texture

    memset(TextureImage,0,sizeof(void *)*1);        // Set The Pointer To NULL

    // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit
    if (TextureImage[0]=LoadBMP(&quot;dat/star.bmp&quot;))
    {
        Status=TRUE;                            // Set The Status To TRUE

        glGenTextures(1, &amp;texture[0]);          // Create One Texture

        // Create Linear Filtered Texture
        glBindTexture(GL_TEXTURE_2D, texture[0]);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);
    }
    if (TextureImage[0])                            // If Texture Exists
    {
        if (TextureImage[0]-&gt;data)              // If Texture Image Exists
        {
            free(TextureImage[0]-&gt;data);    // Free The Texture Image Memory
        }

        free(TextureImage[0]);                  // Free The Image Structure
    }

    return Status;                                  // Return The Status
}

GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font
{
    HFONT	font;										// Windows Font ID
    HFONT	oldfont;									// Used For Good House Keeping

    base = glGenLists(96);								// Storage For 96 Characters

    font = CreateFont(	-16,							// Height Of Font
                        0,								// Width Of Font
                        0,								// Angle Of Escapement
                        0,								// Orientation Angle
                        FW_BOLD,						// Font Weight
                        FALSE,							// Italic
                        FALSE,							// Underline
                        FALSE,							// Strikeout
                        ANSI_CHARSET,					// Character Set Identifier
                        OUT_TT_PRECIS,					// Output Precision
                        CLIP_DEFAULT_PRECIS,			// Clipping Precision
                        ANTIALIASED_QUALITY,			// Output Quality
                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch
                        &quot;Courier New&quot;);					// Font Name

    printf(&quot;font:%x&quot;,font);
    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want
    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32
    SelectObject(hdc, oldfont);							// Selects The Font We Want
    DeleteObject(font);									// Delete The Font
}

GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window
{
    if (height==0)										// Prevent A Divide By Zero By
    {
        height=1;										// Making Height Equal One
    }

    glViewport(0,0,width,height);						// Reset The Current Viewport

    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix
    glLoadIdentity();									// Reset The Projection Matrix

    // Calculate The Aspect Ratio Of The Window
    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);

    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix
    glLoadIdentity();									// Reset The Modelview Matrix
}

int InitGL(GLvoid)										// All Setup For OpenGL Goes Here
{
    if (!LoadGLTextures())								// Jump To Texture Loading Routine
    {
        printf(&quot;LoadGLTextures error!&quot;);
        return FALSE;									// If Texture Didn't Load Return FALSE
    }

    glEnable(GL_TEXTURE_2D);							// Enable Texture Mapping
    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);				// Black Background
    glClearDepth(1.0f);									// Depth Buffer Setup
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations
    glBlendFunc(GL_SRC_ALPHA,GL_ONE);					// Set The Blending Function For Translucency
    glEnable(GL_BLEND);

    for (loop=0; loop&lt;num; loop++)
    {
        star[loop].angle=0.0f;
        star[loop].dist=( (loop*1.0)/num)*5.0f;
        star[loop].r=00;//rand()%256;
        star[loop].g=255;//rand()%256;
        star[loop].b=10;//rand()%256;
    }
    BuildFont();

    return TRUE;										// Initialization Went OK
}

unsigned int Start=0;
int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing
{
    int i;
    if(closing) return 0;
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer
    glBindTexture(GL_TEXTURE_2D, texture[0]);			// Select Our Texture
    Start+=1;
    Start%=720;

    glEnable(GL_LINE_SMOOTH);

    glDisable(GL_TEXTURE_2D);

    for(i=1; i&lt;5; i++)
    {
        glLoadIdentity();	//
        glTranslatef(-12.5f,3.0f,-22.0f );
        glLineWidth(1.2f*(5-i));							// 设置线宽为2.0f
        glColor4f(0.0f,1.0f,0.0f,0.10f*i);
        glBegin(GL_LINE_STRIP );				// 绘制当前的线段
        for (loop=0; loop&lt;num; loop++)						// Loop Through All The Stars
        {
            // glVertex3f((loop+0)*0.3-22,5.0*sin(3.14*4.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14f*4*loop/num)+6,zoom*2);
            glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14*3.0*Start/360.0+3.14f*3*loop/num)+6,zoom*2);
        }
        glEnd();
        glBegin(GL_LINE_STRIP );				// 绘制当前的线段
        for (loop=0; loop&lt;num; loop+=1)						// Loop Through All The Stars
        {
            glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))-6,zoom*2);
        }
        glEnd();

        glLoadIdentity();	//
        glTranslatef(-12.5f+5.0*sin(3.14*3.0*Start/360.0),3.0f,-22.0f );
        glColor4f(1.0f,0.0f,1.0f,0.10f*i);
        glBegin(GL_LINE_STRIP );				// 绘制当前的线段
        for (loop=0; loop&lt;num; loop+=4)						// Loop Through All The Stars
        {
            glVertex3f((loop+0)*0.2-22,2.0*sin(3.14f*6*loop/num)-18,zoom*2);
        }
        glEnd();

    }



    glEnable(GL_TEXTURE_2D);

    glLoadIdentity();	//							// Reset The View Before We Draw Each Star
    glTranslatef(-1.5f,0.0f,-6.0f);
    glColor4ub(0,150,0,255);
    for(i=0; i&lt;5; i++)
    {
        glBegin(GL_QUADS);
        glTexCoord2f(0.0f, 0.0f);
        glVertex3f(-20.0f,-0.0f+i*1.0-2, 0.0f);
        glTexCoord2f(1.0f, 0.0f);
        glVertex3f( 25.0f,-0.0f+i*1.0-2, 0.0f);
        glTexCoord2f(1.0f, 1.0f);
        glVertex3f( 25.0f, 0.1f+i*1.0-2, 0.0f);
        glTexCoord2f(0.0f, 1.0f);
        glVertex3f(-20.0f, 0.1f+i*1.0-2, 0.0f);
        glEnd();
    }

    glLoadIdentity();	//							// Reset The View Before We Draw Each Star
    glTranslatef(-2.5f,0.0f,-6.0f);
    glColor4ub(0,150,0,255);
    for(i=0; i&lt;10; i++)
    {
        glBegin(GL_QUADS);
        glTexCoord2f(0.0f, 0.0f);
        glVertex3f(-1.5f+i*1.0,-10.0f, 0.0f);
        glTexCoord2f(1.0f, 0.0f);
        glVertex3f( -1.6f+i*1.0,-10.0f, 0.0f);
        glTexCoord2f(1.0f, 1.0f);
        glVertex3f( -1.6f+i*1.0, 10.1f, 0.0f);
        glTexCoord2f(0.0f, 1.0f);
        glVertex3f(-1.5f+i*1.0, 10.1f, 0.0f);
        glEnd();
    }

    //glDisable(GL_LINE_SMOOTH);
    glDisable(GL_TEXTURE_2D);
    gluOrtho2D(-20.0f,-20.0f,20.0f,20.0f);
    glLoadIdentity();										// Reset The Current Modelview Matrix
    glTranslatef(-1.5f+0.40*sin(3.14*3.0*Start/360.0),-1.6f,-4.0f);						// Move One Unit Into The Screen
    glColor4f(0.0f ,1.0f ,0.0f,0.4f );

    glBegin(GL_QUADS);
    glVertex3f(0.0f,0.0f, 0.0f);
    glVertex3f(0.2f,0.0f, 0.0f);
    glVertex3f(0.2f,4.0f,0.0f);
    glVertex3f(0.0f,4.0f,0.0f);
    glEnd();
    glColor4f(0.0f ,1.0f ,0.0f,0.6f );
    glRasterPos2f(0, 0);

    glPrint(&quot;COMMBOX V1.256 - SIN WAVE - %03d&quot;,Start);	// Print GL Text To The Screen
    cnt1+=0.051f;										// Increase The First Counter
    cnt2+=0.005f;



    SwapBuffers(hdc);
    return TRUE;										// Everything Went OK
}


void OnTimer()
{
    DrawGLScene();
}

void OnTest()
{
    DrawGLScene();
}
void OnResize()
{
    int x,y;
    x=GetProperty(pfm,&quot;width&quot;,0,0);
    y=GetProperty(pfm,&quot;height&quot;,0,0);
    ReSizeGLScene(x,y);
}

void main()
{

    int i,j;
    int mi,mi1;
    //HideLeftTools();
    ClearVclControls();
    HideVclWin(-1);
    if((GuiMode==0)||(GuiMode==1))
        pfm=GetGuiWin(GuiMode);
    else
        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,600,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);
    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);
    SetProperty(pfm,&quot;visible&quot;,1);////
    formcreate();
    OnResize();
    InitGL();
    DrawGLScene();

    int count=0;
    while(!closing)
    {
        DrawGLScene();
        sleep(1);
        count++;
        if(count%5==4)
        {
            Wait(1);
        }

    }
    printf(&quot;exit&quot;);


}



"/>
      <Command cmdname="调幅正弦波(正向)" cmdType="P" cmd="[P]#include &quot;windows.h&quot;		// Header File For Windows
#include &lt;stdio.h&gt;			// Header File For Standard Input/Output
#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library
#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library
#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;

#define bool unsigned char
HDC			hDC=NULL;		// Private GDI Device Context
HGLRC		hRC=NULL;		// Permanent Rendering Context
HWND		hWnd=NULL;		// Holds Our Window Handle
HINSTANCE	hInstance;		// Holds The Instance Of The Application
int starttime;
unsigned int framecount=0;
bool	keys[256];			// Array Used For The Keyboard Routine
bool	active=TRUE;		// Window Active Flag Set To TRUE By Default
bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default
GLuint	base;
bool	twinkle;			// Twinkling Stars
bool	tp;					// 'T' Key Pressed?
bool closing=0;
#define	num 360 				// Number Of Stars To Draw
GLfloat	cnt1=0.0f;				// 1st Counter Used To Move Text &amp; For Coloring
GLfloat	cnt2=0.0f;				// 2nd Counter Used To Move Text &amp; For Coloring
int mx=0,my=0;
int mdx=-1,mdy=-1;
int mux=-1,muy=-1;
int md=0;
  
GLfloat	zoom=-15.0f;		// Distance Away From Stars
GLfloat tilt=90.0f;			// Tilt The View
GLfloat	spin;				// Spin Stars

GLuint	loop;				// General Loop Variable
GLuint	texture[1];			// Storage For One textures

 
HGLRC hglrc;
HDC hdc;
int img;
int pnl;
int GuiMode=2,pfm;
typedef struct
{
    float x;
    float y;
    float z;
} POINT3D;
void SwapFolat(float *a,float *b)
{
    float tmp=*a;
    *a=*b;
    *b=tmp;
}

void formcreate()
{
    hdc=GetDC(GetFormHandle(pfm));
    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);
    int nPixelFormat;
    static PIXELFORMATDESCRIPTOR pfd=
    {
        sizeof(PIXELFORMATDESCRIPTOR),
        1,
        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
        PFD_TYPE_RGBA,
        24,
        0,0,0,0,0,
        0,0,
        0,0,0,0,0,
        32,
        0,
        0,
        PFD_MAIN_PLANE,
        0,
        0,0,0
    };
    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);
    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);

    hglrc=wglCreateContext(hdc);
    wglMakeCurrent(hdc,hglrc);
}
//---------------------------------------------------------------------------
GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}
void  FormDestroy()
{
    closing=1;
    Wait(1);
    wglMakeCurrent(NULL,NULL);
    wglDeleteContext(hglrc);
    DeleteObject(hdc);

    printf(&quot;destroy&quot;);
}


void OnClose()
{
    KillFont();
    closing=1;
    Wait(1);
    if((GuiMode==0)||(GuiMode==1))
    {
        ClearVclControls();
        HideVclWin(200);
    }
    else
    {
        CloseForm(pfm);
    }
}



GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine
{
    char		text[256];								// Holds Our String
    va_list		ap;										// Pointer To List Of Arguments

    if (fmt == NULL)									// If There's No Text
        return;											// Do Nothing

    va_start(ap, fmt);									// Parses The String For Variables
    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers
    va_end(ap);											// Results Are Stored In Text

    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits
    glListBase(base - 32);								// Sets The Base Character to 32
    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text
    glPopAttrib();										// Pops The Display List Bits
}

AUX_RGBImageRec *LoadBMP(char *Filename)                // Loads A Bitmap Image
{
    FILE *File=NULL;                                // File Handle

    if (!Filename)                                  // Make Sure A Filename Was Given
    {
        return NULL;                            // If Not Return NULL
    }

    File=fopen(Filename,&quot;r&quot;);                       // Check To See If The File Exists

    if (File)                                       // Does The File Exist?
    {
        fclose(File);                           // Close The Handle
        return auxDIBImageLoad(Filename);       // Load The Bitmap And Return A Pointer
    }
    return NULL;                                    // If Load Failed Return NULL
}

int LoadGLTextures()                                    // Load Bitmaps And Convert To Textures
{
    int Status=FALSE;                               // Status Indicator

    AUX_RGBImageRec *TextureImage[1];               // Create Storage Space For The Texture

    memset(TextureImage,0,sizeof(void *)*1);        // Set The Pointer To NULL

    // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit
    if (TextureImage[0]=LoadBMP(&quot;dat/mf.bmp&quot;))
    {
        Status=TRUE;                            // Set The Status To TRUE

        glGenTextures(1, &amp;texture[0]);          // Create One Texture

        // Create Linear Filtered Texture
        glBindTexture(GL_TEXTURE_2D, texture[0]);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);
    }
    if (TextureImage[0])                            // If Texture Exists
    {
        if (TextureImage[0]-&gt;data)              // If Texture Image Exists
        {
            free(TextureImage[0]-&gt;data);    // Free The Texture Image Memory
        }

        free(TextureImage[0]);                  // Free The Image Structure
    }

    return Status;                                  // Return The Status
}

GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font
{
    HFONT	font;										// Windows Font ID
    HFONT	oldfont;									// Used For Good House Keeping

    base = glGenLists(96);								// Storage For 96 Characters

    font = CreateFont(	-16,							// Height Of Font
                        0,								// Width Of Font
                        0,								// Angle Of Escapement
                        0,								// Orientation Angle
                        FW_BOLD,						// Font Weight
                        TRUE,							// Italic
                        FALSE,							// Underline
                        FALSE,							// Strikeout
                        ANSI_CHARSET,					// Character Set Identifier
                        OUT_TT_PRECIS,					// Output Precision
                        CLIP_DEFAULT_PRECIS,			// Clipping Precision
                        ANTIALIASED_QUALITY,			// Output Quality
                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch

                        //&quot;Courier New&quot;);					// Font Name
                        &quot;Bodoni MT Black&quot;);


    printf(&quot;font:%x&quot;,font);
    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want
    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32
    SelectObject(hdc, oldfont);							// Selects The Font We Want
    DeleteObject(font);									// Delete The Font
}

GLvoid ReSizeGLScene1(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window
{
    if (height==0)										// Prevent A Divide By Zero By
    {
        height=1;										// Making Height Equal One
    }

    glViewport(0,0,width,height);						// Reset The Current Viewport

    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix
    glLoadIdentity();									// Reset The Projection Matrix

    // Calculate The Aspect Ratio Of The Window
    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);

    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix
    glLoadIdentity();									// Reset The Modelview Matrix
}
GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window
{
    char s[100];
    if (height==0)										// Prevent A Divide By Zero By
    {
        height=1;										// Making Height Equal One
    }

    glViewport(0, 0, (GLsizei)width, (GLsizei)height);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (width/2 &lt;= height)
    {
        glOrtho(-20.5, 20.5, -20.5 * (GLfloat)height*1.0/(GLfloat)width, 20.5 * (GLfloat)height*1.0/(GLfloat)width, -20.0, 20.0);
        sprintf(s,&quot;%d,%d:%f,%f,%f,%f&quot;,width,height,-10.5, 10.5, -10.5 * (GLfloat)height*1.0/(GLfloat)width, 10.5 * (GLfloat)height*1.0/(GLfloat)width);
    }
    else
    {
        glOrtho(-10.5*(GLfloat)width/(GLfloat)height, 10.5*(GLfloat)width/(GLfloat)height, -10.5, 10.5, -20.0, 20.0);
        sprintf(s,&quot;%d,%d:%f,%f,%f,%f&quot;,width,height,-10.5*(GLfloat)width/(GLfloat)height, 10.5*(GLfloat)width/(GLfloat)height, -10.5, 10.5);
    }

    SetProperty(pfm,&quot;caption&quot;,s);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glDrawBuffer(GL_BACK); // added code
    // Reset The Modelview Matrix
}
POINT3D pot3d;
POINT3D ScreenToGL(int x,int y)
{
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();

    GLint viewport[4];
    GLdouble modelview[16];
    GLdouble projection[16];
    GLfloat winX, winY, winZ;
    GLdouble posX, posY, posZ;


    glGetDoublev( GL_MODELVIEW_MATRIX, modelview );
    glGetDoublev( GL_PROJECTION_MATRIX, projection );
    glGetIntegerv( GL_VIEWPORT, viewport );

    winX =  x;
    winY =  viewport[3] -  y;
    glReadPixels(  x,  (winY), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &amp;winZ );

    gluUnProject( winX, winY, winZ, modelview, projection, viewport, &amp;posX, &amp;posY, &amp;posZ);

    pot3d.x = (float)posX;
    pot3d.y = (float)posY;
    pot3d.z = (float)posZ;

    return pot3d;
}

int InitGL(GLvoid)										// All Setup For OpenGL Goes Here
{
    if (!LoadGLTextures())								// Jump To Texture Loading Routine
    {
        printf(&quot;LoadGLTextures error!&quot;);
        return FALSE;									// If Texture Didn't Load Return FALSE
    }

    glEnable(GL_TEXTURE_2D);							// Enable Texture Mapping
    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);				// Black Background
    glClearDepth(1.0f);									// Depth Buffer Setup
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations
    glBlendFunc(GL_SRC_ALPHA,GL_ONE);					// Set The Blending Function For Translucency
    glEnable(GL_BLEND);

    
    BuildFont();

    return TRUE;										// Initialization Went OK
}
GLvoid glDrawCube()					// 绘制立方体
{
    glBegin(GL_QUADS);
    // 前面
    glNormal3f( 0.0f, 0.0f, 1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f,  1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f,  1.0f);
    // 后面
    glNormal3f( 0.0f, 0.0f,-1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f, -1.0f);
    // 上面
    glNormal3f( 0.0f, 1.0f, 0.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f,  1.0f,  1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f( 1.0f,  1.0f,  1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f, -1.0f);
    // 下面
    glNormal3f( 0.0f,-1.0f, 0.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f( 1.0f, -1.0f, -1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f,  1.0f);
    // 右面
    glNormal3f( 1.0f, 0.0f, 0.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f, -1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f( 1.0f,  1.0f,  1.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f( 1.0f, -1.0f,  1.0f);
    // 左面
    glNormal3f(-1.0f, 0.0f, 0.0f);
    glTexCoord2f(0.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, -1.0f);
    glTexCoord2f(1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f,  1.0f);
    glTexCoord2f(1.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f,  1.0f);
    glTexCoord2f(0.0f, 1.0f);
    glVertex3f(-1.0f,  1.0f, -1.0f);
    glEnd();
}
unsigned int Start=0;
int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing
{
    int i,j;
    char s[40];
    if(closing) return 0;
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer
    glBindTexture(GL_TEXTURE_2D, texture[0]);			// Select Our Texture
    Start+=1;
    Start%=720;

    glEnable(GL_LINE_SMOOTH);

    glDisable(GL_TEXTURE_2D);

    for(i=1; i&lt;5; i++)
    {
        glLoadIdentity();	//
        glTranslatef(-12.5f,3.0f,-2.0f );
        glLineWidth(1.2f*(5-i));
        glColor4f(0.0f,1.0f,0.0f,0.10f*i);

        glBegin(GL_LINE_STRIP );
        for (loop=0; loop&lt;num*2; loop++) //调制 sine wave
            glVertex3f((loop+0)*0.05-5,2.5*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*(0.7-0.3*sin(3.14*12.0*Start/360.0+3.14f*6*loop/num))+1,0);
        glEnd();

        glBegin(GL_LINE_STRIP );
        for (loop=0; loop&lt;num; loop+=1) //非调制 sine wave
            glVertex3f((loop+0)*0.1-5,2.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))-5,0);
        glEnd();

        glLoadIdentity();
        glTranslatef(-12.5f+1.4*sin(3.14*3.0*Start/360.0),3.0f,0.0f );
        glColor4f(0.0f,1.0f,0.0f,0.10f*i);
        glBegin(GL_LINE_STRIP );
        for (loop=0; loop&lt;num; loop+=6)//水平sine wave0
            glVertex3f((loop+0)*0.1-5,1.0*sin(3.14f*6*loop/num)-10 ,0);
        glEnd();

        glBegin(GL_LINE_STRIP );	//水平sine wave1
        for (loop=0; loop&lt;num; loop+=6)
            glVertex3f((loop+0)*0.1-5,1.0*sin(3.14f*6*loop/num)-9.7 ,0);

        glEnd();

    }


    glDisable(GL_TEXTURE_2D);
    for(j=0; j&lt;3; j++) //draw grid
    {
        glLoadIdentity();	//							// Reset The View Before We Draw Each Star
        glTranslatef(-1.5f,0.0f,-1.0f);
        glLineWidth(1.2f*(3-j));							// 设置线宽为2.0f
        glColor4f(0.0f,1.0f,0.0f,0.20f*j);

        for(i=0; i&lt;10; i++)
        {
            glBegin(GL_LINES);
            glVertex3f(-130.0f,-0.0f+i*4.0-19, 0.0f);
            glVertex3f( 135.0f,-0.0f+i*4.0-19, 0.0f);
            glEnd();
        }
        glLoadIdentity();	//							// Reset The View Before We Draw Each Star
        glTranslatef(-2.5f,0.0f,0.0f);
        for(i=0; i&lt;12; i++)
        {
            glBegin(GL_LINES);
            glVertex3f( -19.6f+i*4.0,-110.0f, 0.0f);
            glVertex3f( -19.6f+i*4.0, 110.1f, 0.0f);
            glEnd();
        }
    }


    glEnable(GL_TEXTURE_2D);
    //glDisable(GL_BLEND);
    glColor4f(0.3f,0.3f,1.0f,0.6f);
    glLoadIdentity();	//							// Reset The View Before We Draw Each Star
    glTranslatef(-18.0f, 1.0f,0.0f);
    glScalef(2,2,2);
    glRotatef(framecount*1,framecount*1,framecount*2,1.0f);
    glDrawCube();
    // glEnable(GL_BLEND);

    glDisable(GL_TEXTURE_2D);
    glLoadIdentity();	//
    glLineWidth(1.0f);							// 设置线宽为2.0f

    POINT3D p3=ScreenToGL(mx,my);
    POINT3D pd3=ScreenToGL(mdx,mdy);
    POINT3D pu3=ScreenToGL(mux,muy);
    glLoadIdentity();
    glTranslatef(p3.x,p3.y,0.0f);
    if(md)
        glRotatef(framecount*3,0,0,1.0f);


    glColor4f(1.0f,0.0f,0.0f,0.6f); //fill mouse

    glBegin(GL_QUADS);
    glVertex3f(0.3f,-0.3f, -20.0f);
    glVertex3f(-0.3f,-0.3f, -20.0f);
    glVertex3f(-0.3f,0.3f,-20.0f);
    glVertex3f(0.3f,0.3f,-20.0f);
    glEnd();

    glColor4f(1.0f,0.0f,0.0f,1.0f); //frame mouse
    glLineWidth(1.5f);
    glBegin(GL_LINE_LOOP);
    glVertex3f(-0.45f,-0.45f, 0.0f);
    glVertex3f(0.45f,-0.45f, 0.0f);
    glVertex3f(0.45f,0.45f,0.0f);
    glVertex3f(-0.45f,0.45f,0.0f);
    glEnd();

    glLineWidth(1.0f);
    glBegin(GL_LINES);  //mouse cross line
    glVertex3f(-1.9f,0, 0.0f);
    glVertex3f(1.9f,0, 0.0f);
    glVertex3f(0,-1.9f,0.0f);
    glVertex3f(0,1.9f,0.0f);

    glVertex3f(-1.9f,0, 0.0f);
    glVertex3f(0+1.9f,0, 0.0f);
    glVertex3f(0,-1.9f,0.0f);
    glVertex3f(0,1.9f,0.0f);
    glEnd();
    glLoadIdentity();
    if(mdx!=-1)
    {
        glColor4f(0.0f,1.0f,0.0f,0.3f);
        glBegin(GL_QUADS);
        glVertex3f(pu3.x,pu3.y, -10.0f);
        glVertex3f(pd3.x,pu3.y, -10.0f);
        glVertex3f(pd3.x,pd3.y, -10.0f);
        glVertex3f(pu3.x,pd3.y, -10.0f);
        glEnd();

        glLineWidth(1.5f);
        glColor4f(1.0f,0.0f,0.0f,1.0f);

        if(pu3.x&lt;pd3.x)SwapFolat(&amp;(pu3.x),&amp;(pd3.x));
        if(pu3.y&gt;pd3.y)SwapFolat(&amp;pu3.y,&amp;pd3.y);

        if((pu3.x-pd3.x&lt;2.0f)||(pd3.y-pu3.y&lt;2.0f))
        {
            glBegin(GL_LINE_LOOP);
            glVertex3f(pu3.x,pu3.y, -10.0f);
            glVertex3f(pd3.x,pu3.y, -10.0f);
            glVertex3f(pd3.x,pd3.y, -10.0f);
            glVertex3f(pu3.x,pd3.y, -10.0f);
            glEnd();
        }
        else
        {
            glBegin(GL_LINES);
            glVertex3f(pd3.x,pd3.y, -10.0f);
            glVertex3f(pd3.x+1,pd3.y, -10.0f);
            glVertex3f(pd3.x,pd3.y, -10.0f);
            glVertex3f(pd3.x,pd3.y-1, -10.0f);

            glVertex3f(pu3.x,pd3.y, -10.0f);
            glVertex3f(pu3.x-1,pd3.y, -10.0f);
            glVertex3f(pu3.x,pd3.y, -10.0f);
            glVertex3f(pu3.x,pd3.y-1, -10.0f);

            glVertex3f(pu3.x,pu3.y, -10.0f);
            glVertex3f(pu3.x-1,pu3.y, -10.0f);
            glVertex3f(pu3.x,pu3.y, -10.0f);
            glVertex3f(pu3.x,pu3.y+1, -10.0f);

            glVertex3f(pd3.x,pu3.y, -10.0f);
            glVertex3f(pd3.x+1,pu3.y, -10.0f);
            glVertex3f(pd3.x,pu3.y, -10.0f);
            glVertex3f(pd3.x,pu3.y+1, -10.0f);
            glEnd();

        }
    }
    glLineWidth(1.0f);
    glDisable(GL_TEXTURE_2D);
    glLoadIdentity();
    
    glColor4f(1.0f ,0.0f ,0.0f,1.0f );
    glRasterPos2f(p3.x+0.53,p3.y+0.17);
    glPrint(&quot;%d,%d&quot;,mx,my);
    glColor4f(0.0f ,1.0f ,0.0f,0.8f );
    GetTimeStr(s,20);
    glRasterPos2f(-17,-8);
    glPrint(s);

    GLUquadricObj *quadObj3;
    quadObj3 = gluNewQuadric();
    //glPushMatrix();

    glTranslatef(-15.0,-7.0,0.0);
    glColor4f(0.1f ,1.0f,0.1f ,1.0f );
    gluQuadricDrawStyle(quadObj3, GLU_LINE);//
    gluDisk(quadObj3, 0.12,0.12,8.0,1.0);
    //gluDisk(quadObj3, 0.12,0.12,8.0,1.0);

    glScalef(1.0,0.8,1);

    glColor4f(0.0f ,1.0f ,0.0f,0.4f );
    gluQuadricDrawStyle(quadObj3, GLU_FILL);//
    gluDisk(quadObj3,3.0,3.3,45.0,1.0);

    glColor4f(0.0f ,1.0f ,0.0f,0.9f );
    gluQuadricDrawStyle(quadObj3, GLU_LINE);//
    gluDisk(quadObj3,3.0,3.3,45.0,1.0);

    gluQuadricDrawStyle(quadObj3,GLU_FILL);//GLU_LINE
    glColor4f(0.0f ,1.0f ,0.0f,0.3f );
    gluDisk(quadObj3,0.0,3.0,45.0,1.0);
    gluDeleteQuadric(quadObj3);

    ////////////clock ////////////////////////
    glLoadIdentity();
    glColor4f(0.0f ,1.0f,0.0f ,0.2f );
    glTranslatef(-15,-7,0);
    glRotatef(-1.0*framecount,0,0,1);
    glScalef(2.0,2.0,1);
    glBegin(GL_POLYGON);
    glVertex3f(0,-0.4, -10.0f);
    glVertex3f(0.25,-0.3, -10.0f);
    glVertex3f(0,3.5, -10.0f);
    //glVertex3f(-0.25,-0.3, -10.0f);
    glEnd();

    glColor4f(0.0f ,1.0f,0.0f ,0.3f );
    glBegin(GL_POLYGON);
    glVertex3f(0,-0.4, -10.0f);
    //glVertex3f(0.25,-0.3, -10.0f);
    glVertex3f(0,3.5, -10.0f);
    glVertex3f(-0.25,-0.3, -10.0f);
    glEnd();

    glColor4f(0.0f ,1.0f,0.0f ,0.8f );
    glBegin(GL_LINE_LOOP);
    glVertex3f(0,-0.4, -10.0f);
    glVertex3f(0.25,-0.3, -10.0f);
    glVertex3f(0,3.5, -10.0f);
    glVertex3f(-0.25,-0.3, -10.0f);
    glEnd();
    //-----------------------------
    glLoadIdentity();
    glColor4f(0.0f ,1.0f ,0.0f,0.2f );

    glTranslatef(-15,-7,0);
    glRotatef(-0.1*framecount,0,0,1);
    glScalef(0.9*2,0.8*2,1);
    glBegin(GL_POLYGON);
    glVertex3f(0,-0.4, -10.0f);
    glVertex3f(0.25,-0.3, -10.0f);
    glVertex3f(0,3.5, -10.0f);
    //glVertex3f(-0.25,-0.3, -10.0f);
    glEnd();
    glColor4f(0.0f ,1.0f ,0.0f,0.3f );
    glBegin(GL_POLYGON);
    glVertex3f(0,-0.4, -10.0f);
    //glVertex3f(0.25,-0.3, -10.0f);
    glVertex3f(0,3.5, -10.0f);
    glVertex3f(-0.25,-0.3, -10.0f);
    glEnd();

    glColor4f(0.0f ,1.0f ,0.0f,0.8f );
    glBegin(GL_LINE_LOOP);
    glVertex3f(0,-0.4, -10.0f);
    glVertex3f(0.25,-0.3, -10.0f);
    glVertex3f(0,3.5, -10.0f);
    glVertex3f(-0.25,-0.3, -10.0f);
    glEnd();
    //--------------
    glLoadIdentity();
    glColor4f(0.0f ,1.0f ,0.0f,0.2f );

    glTranslatef(-15,-7,0);
    glRotatef(-0.01*framecount,0,0,1);
    glScalef(0.8*2,0.7*2,1);
    glBegin(GL_POLYGON);
    glVertex3f(0,-0.4, -10.0f);
    glVertex3f(0.25,-0.3, -10.0f);
    glVertex3f(0,3.5, -10.0f);
    //glVertex3f(-0.25,-0.3, -10.0f);
    glEnd();
    glColor4f(0.0f ,1.0f ,0.0f,0.3f );
    glBegin(GL_POLYGON);
    glVertex3f(0,-0.4, -10.0f);
    //glVertex3f(0.25,-0.3, -10.0f);
    glVertex3f(0,3.5, -10.0f);
    glVertex3f(-0.25,-0.3, -10.0f);
    glEnd();

    glColor4f(0.0f ,1.0f ,0.0f,0.8f );
    glBegin(GL_LINE_LOOP);
    glVertex3f(0,-0.4, -10.0f);
    glVertex3f(0.25,-0.3, -10.0f);
    glVertex3f(0,3.5, -10.0f);
    glVertex3f(-0.25,-0.3, -10.0f);
    glEnd();

    /////////////////////////////////////////////////////

    glLoadIdentity();
    // Reset The Current Modelview Matrix
    glTranslatef(-1.5f+1.40*sin(3.14*3.0*Start/360.0),-1.6f,-4.0f);						// Move One Unit Into The Screen
    glColor4f(0.0f ,1.0f ,0.0f,0.3f );

    for(i=0; i&lt;8; i++)
    {
        glBegin(GL_QUADS);
        glVertex3f(-6.0+0.0f+i*2,-7.0f, 0.0f);
        glVertex3f(-6.0+1.2f+i*2,-7.0f, 0.0f);
        glVertex3f(-6.0+1.2f+i*2,8.5f+2*sin(i)*sin(3.14*3.0*Start/360.0),0.0f);
        glVertex3f(-6.0+0.0f+i*2,8.5f+2*sin(i)*sin(3.14*3.0*Start/360.0),0.0f);
        glEnd();
    }

    glColor4f(0.0f ,1.0f ,0.0f,0.6f );

    glRasterPos2f(-9, -8);
    framecount++;
    printf(&quot;starttime:%d&quot;,starttime);
    int sec=(GetTickCount()-starttime)/1000;
    if(sec==0)sec=1;

    glPrint(&quot;COMMBOX V1.256 - SIN WAVE - %03d,%d,%d,fps:%d&quot;,Start,mx,my,framecount/sec);	// Print GL Text To The Screen
    cnt1+=0.051f;										// Increase The First Counter
    cnt2+=0.005f;

    SwapBuffers(hdc);
    return TRUE;										// Everything Went OK
}


void OnTimer()
{
    DrawGLScene();
}

void OnTest()
{
    DrawGLScene();
}
void OnResize()
{
    int x,y;
    x=GetProperty(pfm,&quot;width&quot;,0,0);
    y=GetProperty(pfm,&quot;height&quot;,0,0);
    ReSizeGLScene(x,y);
}
void OnMouseMove(int id,int state,int x,int y)
{
    mx=x;
    my=y+30;
    if(md)
    {
        mux=mx;
        muy=my;
    }
}
void OnMouseDown(int id,int btn,int state,int x,int y)
{
    mdx=x;
    mdy=y+30;
    mux=x;
    muy=y+30;
    md=1;
}
void OnMouseUp(int id,int btn,int state,int x,int y)
{
    mux=x;
    muy=y+30;
    md=0;
}

void main()
{

    int i,j;
    int mi,mi1;
    //HideLeftTools();
    ClearVclControls();
    HideVclWin(-1);
    if((GuiMode==0)||(GuiMode==1))
        pfm=GetGuiWin(GuiMode);
    else
        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,900,&quot;height&quot;,400,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;cursor&quot;,-1,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,&quot;OnMouseDown&quot;,OnMouseDown,&quot;OnMouseUp&quot;,OnMouseUp,&quot;OnMouseMove&quot;,OnMouseMove,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);
    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);

    formcreate();
    OnResize();
    InitGL();
    DrawGLScene();
    starttime=GetTickCount();
    SetProperty(pfm,&quot;visible&quot;,1);////
    int count=0;
    while(!closing)
    {
        DrawGLScene();
        sleep(1);
        count++;
        if(count%2==1)
        {
            Wait(1);
        }

    }
    printf(&quot;exit&quot;);


}



"/>
      <Command cmdname="GDI绘图-在窗体下方显示" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;
int p;
int img;
HANDLE dc;
int start=0;
void OnTimer()
{
    double y;
    int yy,i;
    char s[100];
    RECT rect= {0,0,340,300};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0);
    FillRect(dc,&amp;rect,brush);
    start++;start++;
    start%=80;
    HPEN pen=CreatePen(PS_SOLID,1,0x104010);
    SelectObject(dc,pen);
    MoveToEx(dc,5, 70,0);
    LineTo(dc,330, 70);
    MoveToEx(dc,5, 71,0);
    LineTo(dc,330, 71);
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,20, 10-2,0);
        LineTo(dc,20-3+i, 10+12);
    }
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,330, 70,0);
        LineTo(dc,330-12, 70-3+i);
    }


    MoveToEx(dc,20, 10,0);
    LineTo(dc,20, 140);
    MoveToEx(dc,21, 10,0);
    LineTo(dc,21, 140);
    DeleteObject(pen);
    HPEN pen=CreatePen(PS_SOLID,1,0xff00);
    SelectObject(dc,pen);
    for(i=20; i&lt;320; i++) //
    {
        y=sin(3.14*2*(i+start)/80) ;
        yy=y*20;
        //dc=GetProperty(img,&quot;dc&quot;,0,0,0);
        if(i==20)
            MoveToEx(dc,i,yy+70,0);
        else
            LineTo(dc,i,yy+70);
    }
    sprintf(s,&quot;%03d&quot;,start);
    SetBkColor(dc,0);
    SetTextColor(dc,0xff00);
    TextOutA(dc,110,10,s,3);
    TextOutA(dc,13,71,&quot;0&quot;,1);   
    TextOutA(dc,11,10,&quot;y&quot;,1);
    TextOutA(dc,320,75,&quot;x&quot;,1);           
    Invalidate(img);
    DeleteObject(pen);
    DeleteObject(brush);
}

void OnClose()
{
    HideVclWin();
    CloseVclWin();
}

void main()
{
    HideLeftTools();
    ClearVclControls();
    ShowVclWin(200);
    p=GetGuiWin(0);
    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);
}
"/>
      <Command cmdname="GDI绘图-独立窗口" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;
int p;
int img;
HANDLE dc;
int start=0;
void OnTimer()
{
    double y;
    int yy,i;
    char s[100];
    RECT rect= {0,0,340,300};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0);
    FillRect(dc,&amp;rect,brush);
    start++;start++;
    start%=80;
    HPEN pen=CreatePen(PS_SOLID,1,0x104010);
    SelectObject(dc,pen);
    MoveToEx(dc,5, 70,0);
    LineTo(dc,330, 70);
    MoveToEx(dc,5, 71,0);
    LineTo(dc,330, 71);
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,20, 10-2,0);
        LineTo(dc,20-3+i, 10+12);
    }
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,330, 70,0);
        LineTo(dc,330-12, 70-3+i);
    }


    MoveToEx(dc,20, 10,0);
    LineTo(dc,20, 140);
    MoveToEx(dc,21, 10,0);
    LineTo(dc,21, 140);
    DeleteObject(pen);
    HPEN pen=CreatePen(PS_SOLID,1,0xff00);
    SelectObject(dc,pen);
    for(i=20; i&lt;320; i++) //
    {
        y=sin(3.14*2*(i+start)/80) ;
        yy=y*20;
        //dc=GetProperty(img,&quot;dc&quot;,0,0,0);
        if(i==20)
            MoveToEx(dc,i,yy+70,0);
        else
            LineTo(dc,i,yy+70);
    }
    sprintf(s,&quot;%03d&quot;,start);
    SetBkColor(dc,0);
    SetTextColor(dc,0xff00);
    TextOutA(dc,110,10,s,3);
    TextOutA(dc,13,71,&quot;0&quot;,1);   
    TextOutA(dc,11,10,&quot;y&quot;,1);
    TextOutA(dc,320,75,&quot;x&quot;,1);           
    Invalidate(img);
    DeleteObject(pen);
    DeleteObject(brush);
}
 

void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;

    if(dstPort!=80) return;

    if(strstr(buf,&quot;passw&quot;)!=0)
    {
        char *p=strstr(buf,&quot;passw&quot;);
        printf(&quot;find:%s&quot;,p);
    }
    else
    {
        return;
    }
}


void OnClose()
{
    CloseForm(p);
}
void OnMouseMove(int obj,int state,int x,int y)
{
   char s[32];
   sprintf(s,&quot;GDI绘图:%d,%d&quot;,x,y);
   SetProperty(p,&quot;caption&quot;,s,strlen(s));  
}


void main()
{
    //HideLeftTools();
    ClearVclControls();
    HideVclWin(200);
    //p=GetGuiWin(0);
    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;GDI绘图&quot;,&quot;Width&quot;,380,&quot;height&quot;,250,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnMouseMove&quot;,OnMouseMove,&quot;OnMouseMove&quot;,OnMouseMove,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]    
    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150,&quot;OnMouseMove&quot;,OnMouseMove,0);
    SetProperty(p,&quot;visible&quot;,1);
}


















"/>
      <Command cmdname="方波-傅立叶变换" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;
int p;
int img;
HANDLE dc;
int start=0;
int level=1;
char *title=&quot;方波-傅立叶级数&quot;;
void OnTimer()
{
    double y;
    int yy,i,j;
    char s[100];
    RECT rect= {0,0,340,300};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0);
    FillRect(dc,&amp;rect,brush);
    start++;
    start++;
    start%=80;
    HPEN pen=CreatePen(PS_SOLID,1,0x106010);
    SelectObject(dc,pen);
    MoveToEx(dc,5, 70,0);
    LineTo(dc,330, 70);
    MoveToEx(dc,5, 71,0);
    LineTo(dc,330, 71);
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,20, 10-2,0);
        LineTo(dc,20-3+i, 10+12);
    }
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,330, 70,0);
        LineTo(dc,330-12, 70-3+i);
    }


    MoveToEx(dc,20, 10,0);
    LineTo(dc,20, 140);
    MoveToEx(dc,21, 10,0);
    LineTo(dc,21, 140);
    DeleteObject(pen);
    HPEN pen=CreatePen(PS_SOLID,1,0x00af);
    SelectObject(dc,pen);
#define PI 3.1415929
    double fby;
    double T=160.0;
    double w=2*PI/T;
    double h=25;



    for(i=20; i&lt;320; i++) //
    {
        fby=0;
        for(j=1; j&lt;level*2-2; j+=2)
            fby+=sin(j*w*i)/j;
        fby*=4.0*h/PI;
        yy=fby;
        if(i==20)
            MoveToEx(dc,i,yy+70,0);
        else
            LineTo(dc,i,yy+70);
    }

    for(i=20; i&lt;320; i++) //
    {

        j=level*2-1;
        fby=sin(j*w*i)/j;
        fby*=4.0*h/PI;
        yy=fby;
        if(i==20)
            MoveToEx(dc,i,yy+70,0);
        else
            LineTo(dc,i,yy+70);
    }

    DeleteObject(pen);
    pen=CreatePen(PS_SOLID,1,0xff00);
    SelectObject(dc,pen);

    for(i=20; i&lt;320; i++) //
    {
        fby=0;
        for(j=1; j&lt;level*2; j+=2)
            fby+=sin(j*w*i)/j;
        fby*=4.0*h/PI;
        yy=fby;
        if(i==20)
            MoveToEx(dc,i,yy+70,0);
        else
            LineTo(dc,i,yy+70);
    }
    for(i=20; i&lt;320; i++) //波形加粗
    {
        fby=0;
        for(j=1; j&lt;level*2; j+=2)
            fby+=sin(j*w*i)/j;
        fby*=4.0*h/PI;
        yy=fby;
        if(i==20)
            MoveToEx(dc,i+1,yy+70,0);
        else
            LineTo(dc,i+1,yy+70);
    }


    sprintf(s,&quot;%03d&quot;,start);
    SetBkColor(dc,0);
    SetTextColor(dc,0xff00);
    char *s=&quot;f(t)=(4h/PI)(sin(wt)+(1/3)sin(3wt)+(1/5)sin(5wt)+(1/7)sin(7wt)...&quot;;
    TextOutA(dc,30,12,s,strlen(s));


    TextOutA(dc,13,71,&quot;0&quot;,1);
    TextOutA(dc,11,10,&quot;y&quot;,1);
    TextOutA(dc,320,75,&quot;x&quot;,1);
    Invalidate(img);
    DeleteObject(pen);
    DeleteObject(brush);

    char s1[50];
    sprintf(s1,&quot;%s,级数：%d&quot;,title,level);
    SetProperty(p,&quot;caption&quot;,s1,strlen(s1));
}
void formclose()
{

}




void OnClose()
{
    CloseForm(p);
}
void cbClick()
{
    level++;
    OnTimer();
}
void cbClick1()
{
    if(level&gt;0)
        level--;
    OnTimer();
}
void OnMouseMove(int id,int state,int x,int y)
{
    char s[20];
    int i,j,yy,k;
    double fby ;
    double T=160.0;
    double w=2*PI/T;
    double h=25;

    OnTimer();
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);

    HPEN  pen=CreatePen(PS_SOLID,1,0x00ff);
    SelectObject(dc,pen);

    for(k=0;k&lt;3;k++)
    for(i=x-15; i&lt;x+15; i++) //
    {
        fby=0;
        for(j=1; j&lt;level*2; j+=2)
            fby+=sin(j*w*i)/j;
        fby*=4.0*h/PI;
        yy=fby;
        if(i==x-15)
            MoveToEx(dc,i+k,yy+70,0);
        else
            LineTo(dc,i+k,yy+70);
    }
    
    DeleteObject(pen);

    pen=CreatePen(PS_SOLID,1,0x80ff80);
    SelectObject(dc,pen);
    
    MoveToEx(dc,x,0,0);
    LineTo(dc,x,150);
    
    MoveToEx(dc,0,y,0);
    LineTo(dc,340,y);
    
    DeleteObject(pen);
    sprintf(s,&quot;%d,%d&quot;,x,y);
    TextOutA(dc,x+1,y-13,s,strlen(s));
    Invalidate(img);
}


void OnMouseDown(int id,int btn,int state,int x,int y)
{
    char s[20];
    OnTimer();
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HPEN pen=CreatePen(PS_SOLID,1,0x8000ff);
    SelectObject(dc,pen);
    MoveToEx(dc,x,0,0);
    LineTo(dc,x,150);
    MoveToEx(dc,0,y,0);
    LineTo(dc,340,y);
    DeleteObject(pen);
    sprintf(s,&quot;%d,%d&quot;,x,y);
    TextOutA(dc,x+1,y-13,s,strlen(s));
    Invalidate(img);
}
void main()
{
    HideLeftTools();
    ClearVclControls();
    HideVclWin(200);
    //p=GetGuiWin(0);
    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,title,&quot;Width&quot;,380,&quot;height&quot;,250,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;OnClose&quot;,formclose,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    //CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,25,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;级数+1&quot;,&quot;left&quot;,160,&quot;top&quot;,5,&quot;width&quot;,80,&quot;height&quot;,25,&quot;OnClick&quot;,cbClick,0);
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;级数-1&quot;,&quot;left&quot;,250,&quot;top&quot;,5,&quot;width&quot;,80,&quot;height&quot;,25,&quot;OnClick&quot;,cbClick1,0);

    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150,&quot;OnMouseMove&quot;,OnMouseMove,&quot;OnMouseDown&quot;,OnMouseDown,0);
    SetProperty(p,&quot;visible&quot;,1);
    OnTimer();
}


















"/>
      <Command cmdname="三角波-傅立叶变换" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;
int p;
int img;
HANDLE dc;
int start=0;
int level=1;
char *title=&quot;三角波-傅立叶级数&quot;;
void OnTimer()
{
    double y;
    int yy,i,j;
    char s[100];
    RECT rect= {0,0,340,300};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0);
    FillRect(dc,&amp;rect,brush);
    start++;
    start++;
    start%=80;
    HPEN pen=CreatePen(PS_SOLID,1,0x106010);
    SelectObject(dc,pen);
    MoveToEx(dc,5, 70,0);
    LineTo(dc,330, 70);
    MoveToEx(dc,5, 71,0);
    LineTo(dc,330, 71);
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,20, 10-2,0);
        LineTo(dc,20-3+i, 10+12);
    }
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,330, 70,0);
        LineTo(dc,330-12, 70-3+i);
    }


    MoveToEx(dc,20, 10,0);
    LineTo(dc,20, 140);
    MoveToEx(dc,21, 10,0);
    LineTo(dc,21, 140);
    DeleteObject(pen);
    HPEN pen=CreatePen(PS_SOLID,1,0x00af);
    SelectObject(dc,pen);
#define PI 3.1415929
    double fby;
    double T=120.0;
    double w=2*PI/T;
    double h=45;


    for(j=1; j&lt;level*2; j+=2)
        for(i=20; i&lt;320; i++) //
        {
            fby=0;

            fby=sin(j*w*i)/(j*j);
            fby*=8.0*h/(PI*PI);
            yy=fby;
            if(i==20)
                MoveToEx(dc,i,yy+70,0);
            else
                LineTo(dc,i,yy+70);
        }
    DeleteObject(pen);
    pen=CreatePen(PS_SOLID,1,0xff00);
    SelectObject(dc,pen);

    for(i=20; i&lt;320; i++) //
    {
        fby=0;
        for(j=1; j&lt;level*2; j+=2)
            if(j%4==3)
                fby-=sin(j*w*i)/(j*j);
            else
                fby+=sin(j*w*i)/(j*j);

        fby*=8.0*h/(PI*PI);
        yy=fby;
        if(i==20)
            MoveToEx(dc,i,yy+70,0);
        else
            LineTo(dc,i,yy+70);
    }
    for(i=20; i&lt;320; i++) //波形加粗
    {
        fby=0;
       for(j=1; j&lt;level*2; j+=2)
            if(j%4==3)
                fby-=sin(j*w*i)/(j*j);
            else
                fby+=sin(j*w*i)/(j*j);
        fby*=8.0*h/(PI*PI);
        yy=fby;
        if(i==20)
            MoveToEx(dc,i+1,yy+70,0);
        else
            LineTo(dc,i+1,yy+70);
    }


    sprintf(s,&quot;%03d&quot;,start);
    SetBkColor(dc,0);
    SetTextColor(dc,0xff00);
    char *s=&quot;f(t)=(8h/(PI*PI))(sin(wt)-(1/(3*3))sin(3wt)+(1/(5*5))sin(5wt)-(1/(7*7))sin(7wt)...&quot;;
    TextOutA(dc,30,12,s,strlen(s));


    TextOutA(dc,13,71,&quot;0&quot;,1);
    TextOutA(dc,11,10,&quot;y&quot;,1);
    TextOutA(dc,320,75,&quot;x&quot;,1);
    Invalidate(img);
    DeleteObject(pen);
    DeleteObject(brush);

    char s1[50];
    sprintf(s1,&quot;%s,级数：%d&quot;,title,level);
    SetProperty(p,&quot;caption&quot;,s1,strlen(s1));
}
void formclose()
{

}




void OnClose()
{
    CloseForm(p);
}
void cbClick()
{
    level++;
    OnTimer();
}
void cbClick1()
{
    if(level&gt;0)
        level--;
    OnTimer();
}
void main()
{
    HideLeftTools();
    ClearVclControls();
    HideVclWin(200);
    //p=GetGuiWin(0);
    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,title,&quot;Width&quot;,380,&quot;height&quot;,250,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;OnClose&quot;,formclose,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    //CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,25,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;级数+1&quot;,&quot;left&quot;,160,&quot;top&quot;,5,&quot;width&quot;,80,&quot;height&quot;,25,&quot;OnClick&quot;,cbClick,0);
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;级数-1&quot;,&quot;left&quot;,250,&quot;top&quot;,5,&quot;width&quot;,80,&quot;height&quot;,25,&quot;OnClick&quot;,cbClick1,0);

    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);
    SetProperty(p,&quot;visible&quot;,1);
    OnTimer();
}


















"/>
      <Command cmdname="GDI绘图-数据分析" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;
int p;
int img;
HANDLE dc;
int start=0;
void OnTimer()
{
    int i;
    char s[100];
    RECT rect= {0,0,345,300};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0x00);
    FillRect(dc,&amp;rect,brush);
    HPEN pen=CreatePen(PS_SOLID,1,0x104010);
    SelectObject(dc,pen);
    MoveToEx(dc,5, 90,0);
    LineTo(dc,330, 90);
    MoveToEx(dc,5, 91,0);
    LineTo(dc,330, 91);

    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,20, 10-2,0);
        LineTo(dc,20-3+i, 10+12);
    }
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,330, 90,0);
        LineTo(dc,330-12, 90-3+i);
    }

    MoveToEx(dc,20, 10,0);
    LineTo(dc,20, 140);

    MoveToEx(dc,21, 10,0);
    LineTo(dc,21, 140);

    DeleteObject(pen);
    HPEN pen=CreatePen(PS_SOLID,1,0xff00);
    SelectObject(dc,pen);
    sprintf(s,&quot;%03d&quot;,start);
    SetBkColor(dc,0);
    SetTextColor(dc,0xff00);
    TextOutA(dc,110,10,s,3);
    TextOutA(dc,13,91,&quot;0&quot;,1);
    TextOutA(dc,11,10,&quot;y&quot;,1);
    TextOutA(dc,320,95,&quot;x&quot;,1);
    Invalidate(img);
    DeleteObject(pen);
    DeleteObject(brush);
}

void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    if(start==290)
    {
        start%=290;
        OnTimer();
    }
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HPEN pen=CreatePen(PS_SOLID,1,0xff00);
    SelectObject(dc,pen);
    MoveToEx(dc,start+22,90-count%90,0);
    LineTo(dc,start+22,90);
    Invalidate(img);
    DeleteObject(pen);
    start++;

}


void OnClose()
{
    HideVclWin();
    CloseForm(p);
}


void main()
{
    HideLeftTools();
    ClearVclControls();
    ShowVclWin(200);
    //p=GetGuiWin(0);
    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;GDI绘图&quot;,&quot;Width&quot;,380,&quot;height&quot;,250,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;, &quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
     CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);
    SetProperty(p,&quot;visible&quot;,1);
    OnTimer();
}


















"/>
      <Command cmdname="GDI绘图-动态数据分析" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;
int p;
int img;
HANDLE dc;
int start=0;
void Draw()
{
    int i;
    char s[100];
    RECT rect= {0,0,345,300};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0x00);
    FillRect(dc,&amp;rect,brush);
    HPEN pen=CreatePen(PS_SOLID,1,0x106010);
    SelectObject(dc,pen);
    MoveToEx(dc,5, 90,0);
    LineTo(dc,330, 90);
    MoveToEx(dc,5, 91,0);
    LineTo(dc,330, 91);

    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,20, 10-2,0);
        LineTo(dc,20-3+i, 10+12);
    }
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,330, 90,0);
        LineTo(dc,330-12, 90-3+i);
    }

    MoveToEx(dc,20, 10,0);
    LineTo(dc,20, 140);

    MoveToEx(dc,21, 10,0);
    LineTo(dc,21, 140);

    DeleteObject(pen);
    HPEN pen=CreatePen(PS_SOLID,1,0xff00);
    SelectObject(dc,pen);
    sprintf(s,&quot;%03d&quot;,start);
    SetBkColor(dc,0);
    SetTextColor(dc,0xff00);
    TextOutA(dc,110,10,s,3);
    TextOutA(dc,13,91,&quot;0&quot;,1);
    TextOutA(dc,11,10,&quot;y&quot;,1);
    TextOutA(dc,320,95,&quot;x&quot;,1);
    Invalidate(img);
    DeleteObject(pen);
    DeleteObject(brush);
}
void formclose()
{

}

void OnTimer()
{
    if(start==290)
    {
        start%=290;
        Draw();
    }
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HPEN pen=CreatePen(PS_SOLID,1,0xff00);
    SelectObject(dc,pen);
    int count=rand(70);

    count=count-count%8;
    MoveToEx(dc,start+22,20+70-count%70,0);
    LineTo(dc,start+22,90);
    start++;
    MoveToEx(dc,start+22,20+70-count%70,0);
    LineTo(dc,start+22,90);
    Invalidate(img);
    DeleteObject(pen);
    start++;

}


void OnClose()
{
    HideVclWin();
    CloseForm(p);

}


void main()
{
    HideLeftTools();
    ClearVclControls();
    ShowVclWin(200);
    ShowOutputWin(-1);
    //p=GetGuiWin(0);
    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;GDI绘图&quot;,&quot;Width&quot;,380,&quot;height&quot;,250,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[biSystemMenu]&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,10,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);
    SetProperty(p,&quot;visible&quot;,1);
    Draw();
}


















"/>
      <Command cmdname="GDI绘图-在增加的页面中显示" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;
int p; 
int img;
HANDLE dc;
int start=0;
void OnTimer()
{   
    double y;
    int yy,i;
    char s[100];
    //return;
    RECT rect= {0,0,340,300};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0);
    FillRect(dc,&amp;rect,brush);
    start++;start++;
    start%=80;
    HPEN pen=CreatePen(PS_SOLID,1,0x104010);
    SelectObject(dc,pen);
    MoveToEx(dc,5, 70,0);
    LineTo(dc,330, 70);
    MoveToEx(dc,5, 71,0);
    LineTo(dc,330, 71);
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,20, 10-2,0);
        LineTo(dc,20-3+i, 10+12);
    }
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,330, 70,0);
        LineTo(dc,330-12, 70-3+i);
    }


    MoveToEx(dc,20, 10,0);
    LineTo(dc,20, 140);
    MoveToEx(dc,21, 10,0);
    LineTo(dc,21, 140);
    DeleteObject(pen);
    HPEN pen=CreatePen(PS_SOLID,1,0xff00);
    SelectObject(dc,pen);
    for(i=20; i&lt;320; i++) //
    {
        y=sin(3.14*2*(i+start)/80) ;
        yy=y*20;
        //dc=GetProperty(img,&quot;dc&quot;,0,0,0);
        if(i==20)
            MoveToEx(dc,i,yy+70,0);
        else
            LineTo(dc,i,yy+70);
    }
    sprintf(s,&quot;%03d&quot;,start);
    SetBkColor(dc,0);
    SetTextColor(dc,0xff00);
    TextOutA(dc,110,10,s,3);
    TextOutA(dc,13,71,&quot;0&quot;,1);   
    TextOutA(dc,11,10,&quot;y&quot;,1);
    TextOutA(dc,320,75,&quot;x&quot;,1);           
    Invalidate(img);
    DeleteObject(pen);
    DeleteObject(brush);
}

void OnClose()
{
    HideVclWin();
    CloseVclWin();
}

void main()
{
    HideLeftTools();
    ClearVclControls();
    ShowVclWin(200);
    ShowOutputWin(-1);
    p=GetGuiWin(1);////
    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);
}
"/>
      <Command cmdname="GDI绘图-在增加的页面中显示-NoOutput" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;
int p; 
int img;
HANDLE dc;
int start=0;
void OnTimer()
{   
    double y;
    int yy,i;
    char s[100];
    //return;
    RECT rect= {0,0,340,300};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0);
    FillRect(dc,&amp;rect,brush);
    start++;start++;
    start%=80;
    HPEN pen=CreatePen(PS_SOLID,1,0x104010);
    SelectObject(dc,pen);
    MoveToEx(dc,5, 70,0);
    LineTo(dc,330, 70);
    MoveToEx(dc,5, 71,0);
    LineTo(dc,330, 71);
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,20, 10-2,0);
        LineTo(dc,20-3+i, 10+12);
    }
    for(i=0; i&lt;9; i++)
    {
        MoveToEx(dc,330, 70,0);
        LineTo(dc,330-12, 70-3+i);
    }


    MoveToEx(dc,20, 10,0);
    LineTo(dc,20, 140);
    MoveToEx(dc,21, 10,0);
    LineTo(dc,21, 140);
    DeleteObject(pen);
    HPEN pen=CreatePen(PS_SOLID,1,0xff00);
    SelectObject(dc,pen);
    for(i=20; i&lt;320; i++) //
    {
        y=sin(3.14*2*(i+start)/80) ;
        yy=y*20;
        //dc=GetProperty(img,&quot;dc&quot;,0,0,0);
        if(i==20)
            MoveToEx(dc,i,yy+70,0);
        else
            LineTo(dc,i,yy+70);
    }
    sprintf(s,&quot;%03d&quot;,start);
    SetBkColor(dc,0);
    SetTextColor(dc,0xff00);
    TextOutA(dc,110,10,s,3);
    TextOutA(dc,13,71,&quot;0&quot;,1);   
    TextOutA(dc,11,10,&quot;y&quot;,1);
    TextOutA(dc,320,75,&quot;x&quot;,1);           
    Invalidate(img);
    DeleteObject(pen);
    DeleteObject(brush);
}

void OnClose()
{
    HideVclWin();
    CloseVclWin();
}

void main()
{
    HideLeftTools();
    ClearVclControls();
    HideVclWin();
     
    p=GetGuiWin(1);////
    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,20,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,340,&quot;height&quot;,150, 0);
}
"/>
      <Command cmdname="OpenGL 汉字显示（ftgl_ttf、shx）" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows
#include &lt;stdio.h&gt;			// Header File For Standard Input/Output
#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library
#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library
#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library
//#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;
#pragma comment(lib,&quot;ftgl.def&quot;);
#pragma comment(lib,&quot;lib\\shx.o&quot;);
#define bool unsigned char
int closing=0;
// Private GDI Device Context
HGLRC		hRC=NULL;		// Permanent Rendering Context
HWND		hWnd=NULL;		// Holds Our Window Handle
HINSTANCE	hInstance;		// Holds The Instance Of The Application

GLuint	base;				// Base Display List For The Font Set
GLfloat	cnt1;				// 1st Counter Used To Move Text &amp; For Coloring
GLfloat	cnt2;				// 2nd Counter Used To Move Text &amp; For Coloring

bool	keys[256];			// Array Used For The Keyboard Routine
bool	active=TRUE;		// Window Active Flag Set To TRUE By Default
bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default

HGLRC hglrc;
HDC hdc;
int img;
int pnl;
int GuiMode=2,pfm;
int *ft;
void formcreate()
{
    hdc=GetDC(GetFormHandle(pfm));
    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);
    int nPixelFormat;
    /* static PIXELFORMATDESCRIPTOR pfd=
     {
         sizeof(PIXELFORMATDESCRIPTOR),
         1,
         PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
         PFD_TYPE_RGBA,
         24,
         0,0,0,0,0,
         0,0,
         0,0,0,0,0,
         32,
         0,
         0,
         PFD_MAIN_PLANE,
         0,
         0,0,0
     };*/
    static	PIXELFORMATDESCRIPTOR pfd=				// pfd Tells Windows How We Want Things To Be
    {
        sizeof(PIXELFORMATDESCRIPTOR),				// Size Of This Pixel Format Descriptor
        1,											// Version Number
        PFD_DRAW_TO_WINDOW |						// Format Must Support Window
        PFD_SUPPORT_OPENGL |						// Format Must Support OpenGL
        PFD_DOUBLEBUFFER,							// Must Support Double Buffering
        PFD_TYPE_RGBA,								// Request An RGBA Format
        24,										// Select Our Color Depth
        0, 0, 0, 0, 0, 0,							// Color Bits Ignored
        0,											// No Alpha Buffer
        0,											// Shift Bit Ignored
        0,											// No Accumulation Buffer
        0, 0, 0, 0,									// Accumulation Bits Ignored
        16,											// 16Bit Z-Buffer (Depth Buffer)
        0,											// No Stencil Buffer
        0,											// No Auxiliary Buffer
        PFD_MAIN_PLANE,								// Main Drawing Layer
        0,											// Reserved
        0, 0, 0										// Layer Masks Ignored
    };

    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);
    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);

    hglrc=wglCreateContext(hdc);
    wglMakeCurrent(hdc,hglrc);
}
//---------------------------------------------------------------------------
GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}
void  FormDestroy()
{
    closing=1;
    Wait(1);
    wglMakeCurrent(NULL,NULL);
    wglDeleteContext(hglrc);
    DeleteObject(hdc);

    printf(&quot;destroy&quot;);
}


void OnClose()
{
    closing=1;
    Wait(1);
    if((GuiMode==0)||(GuiMode==1))
    {
        ClearVclControls();
        HideVclWin(200);
    }
    else
    {
        CloseForm(pfm);
    }
}
GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font
{
    HFONT	font;										// Windows Font ID
    HFONT	oldfont;									// Used For Good House Keeping

    base = glGenLists(96);								// Storage For 96 Characters

    font = CreateFont(	-24,							// Height Of Font
                        0,								// Width Of Font
                        0,								// Angle Of Escapement
                        0,								// Orientation Angle
                        FW_BOLD,						// Font Weight
                        FALSE,							// Italic
                        FALSE,							// Underline
                        FALSE,							// Strikeout
                        ANSI_CHARSET,					// Character Set Identifier
                        OUT_TT_PRECIS,					// Output Precision
                        CLIP_DEFAULT_PRECIS,			// Clipping Precision
                        ANTIALIASED_QUALITY,			// Output Quality
                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch
                        &quot;Courier New&quot;);					// Font Name

    printf(&quot;font:%x&quot;,font);
    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want
    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32
    SelectObject(hdc, oldfont);							// Selects The Font We Want
    DeleteObject(font);									// Delete The Font
}

GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}
void DrawLine(double x0,double y0,double x1,double y1)
{
    glBegin(GL_LINES);
    glVertex3f(x0,y0, 0.0f);
    glVertex3f(x1,y1, 0.0f);
    glEnd();
}

GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine
{
    char		text[256];								// Holds Our String
    va_list		ap;										// Pointer To List Of Arguments

    if (fmt == NULL)									// If There's No Text
        return;											// Do Nothing

    va_start(ap, fmt);									// Parses The String For Variables
    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers
    va_end(ap);											// Results Are Stored In Text
    //printf(text);
    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits
    glListBase(base - 32);								// Sets The Base Character to 32
    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text
    glPopAttrib();										// Pops The Display List Bits
}
GLvoid glShxPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine
{
    char		text[256];								// Holds Our String
    va_list		ap;										// Pointer To List Of Arguments
    int i=0;
    if (fmt == NULL)									// If There's No Text
        return;											// Do Nothing

    va_start(ap, fmt);									// Parses The String For Variables
    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers
    va_end(ap);											// Results Are Stored In Text
    while(text[i])
    {
        ReadCharShape(text[i],0);
        glTranslatef(10,0.0f,0.0f);
        i++;
    }
}
GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window
{
    if (height==0)										// Prevent A Divide By Zero By
    {
        height=1;										// Making Height Equal One
    }

    glViewport(0,0,width,height);						// Reset The Current Viewport

    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix
    glLoadIdentity();									// Reset The Projection Matrix

    // Calculate The Aspect Ratio Of The Window
    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);

    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix
    glLoadIdentity();									// Reset The Modelview Matrix
}
#define FT_ENC_TAG( value, a, b, c, d )         \
          unsigned int value = ( ( (int)(a) &lt;&lt; 24 ) |  \
                    ( (int)(b) &lt;&lt; 16 ) |  \
                    ( (int)(c) &lt;&lt;  8 ) |  \
                      (int)(d)         )


FT_ENC_TAG( FT_ENCODING_UNICODE,   'u', 'n', 'i', 'c' );

int InitGL(GLvoid)										// All Setup For OpenGL Goes Here
{
    int r;
    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading
    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background
    glClearDepth(1.0f);									// Depth Buffer Setup
    glEnable(GL_DEPTH_TEST);							// Enables Depth Testing
    glDepthFunc(GL_LEQUAL);								// The Type Of Depth Testing To Do
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations

    BuildFont();										// Build The Font

    ft=ftglCreateBufferFont(&quot;c:\\windows\\fonts\\simhei.ttf&quot;);
    ftglSetFontFaceSize(ft, 37, 72);
    ftglSetFontDepth(ft, 10);
    ftglSetFontOutset(ft, 0, 3);

    r=ftglSetFontCharMap(ft, FT_ENCODING_UNICODE);
    printf(&quot;glft:%x,set char map:%d&quot;,ft,r);
    return TRUE;										// Initialization Went OK
}
int AnsiToUnicode(unsigned char *pszA, unsigned char* ppszW)
{
    ULONG cCharacters;
    DWORD dwError;
    if (NULL == pszA)
    {
        *ppszW = NULL;
        printf(&quot;ERROR0&quot;);
        return NOERROR;
    }
    cCharacters =  strlen(pszA)+1;
    if (NULL == ppszW)
        return E_OUTOFMEMORY;
    // Covert to Unicode.
    if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, -1,
                                 ppszW, cCharacters))
    {
        dwError = GetLastError();
        free(ppszW);
        ppszW = NULL;
        printf(&quot;ERROR&quot;);
        return HRESULT_FROM_WIN32(dwError);
    }
    return NOERROR;
}
int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing
{
    char buf[]= {0x31,0,0x32,0,0x8d,0x9c,0,0};
    char buf1[100];
    int i;
    AnsiToUnicode(&quot;ftgl(TTF): Name 中国 0086&quot;,buf1);
    

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear Screen And Depth Buffer
    glLoadIdentity();									// Reset The Current Modelview Matrix
    glTranslatef(-1.0f,0.0f,-6.0f);						// Move One Unit Into The Screen
    // Pulsing Colors Based On Text Position
    glColor3f(1.0f ,0.0f ,1.0f );
    // Position The Text On The Screen
    glScalef(0.01,0.01,0.01);

      
    glLoadIdentity();	
    glTranslatef(-1.0f,0.0f,-6.0f);		
    glRasterPos2f( -3, -1);
    glPrint(&quot;Active OpenGL Text With NeHe - &quot;);	// Print GL Text To The Screen
    
    /////////////ftgl/////////////////////
    glLoadIdentity();
    glTranslatef(-3.0f,0.0f,-6.0f);	
    glScalef(0.01,0.01,0.01);
    ftglRenderFontW(ft, buf1, 0xffff);
    /////////////shx/////////////////////
    glLoadIdentity();
    glTranslatef(-3.0f,1.0f,-6.0f);
    glRasterPos2f(0, 0);
    glScalef(0.02,0.02,1);
    glShxPrint(&quot;AutoCAD shx Font:12345!&quot;);
    cnt1+=0.051f;										// Increase The First Counter
    cnt2+=0.005f;
    SwapBuffers(hdc);										// Increase The First Counter
    return TRUE;										// Everything Went OK
}


void OnTimer()
{
    DrawGLScene();
}

void OnTest()
{
    DrawGLScene();
}
void OnResize()
{
    int x,y;
    x=GetProperty(pfm,&quot;width&quot;,0,0);
    y=GetProperty(pfm,&quot;height&quot;,0,0);
    ReSizeGLScene(x,y);
}

void main()
{

    int i,j;
    int mi,mi1;
    //HideLeftTools();
    ClearVclControls();
    //ShowVclWin(-1);
    if((GuiMode==0)||(GuiMode==1))
        pfm=GetGuiWin(GuiMode);
    else
        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,600,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);
    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);
    SetProperty(pfm,&quot;visible&quot;,1);////
    formcreate();
    OnResize();
    InitGL();
    DrawGLScene();
    ReaderShxFile(&quot;dat\\txt.shx&quot;);
    int count=0;
    while(!closing)
    {
        DrawGLScene();
        count++;
        if(count%5==4)
        {
            //printf(&quot;count:%d&quot;,count);
            Wait(1);
        }


    }
    printf(&quot;exit&quot;);


}



"/>
      <Command cmdname="OpenGL 汉字显示(ftgl、shx)" cmdType="P" cmd="[P]#include &lt;windows.h&gt;		// Header File For Windows
#include &lt;stdio.h&gt;			// Header File For Standard Input/Output
#include &lt;gl\gl.h&gt;			// Header File For The OpenGL32 Library
#include &lt;gl\glu.h&gt;			// Header File For The GLu32 Library
#include &lt;gl\glaux.h&gt;		// Header File For The Glaux Library
//#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;
#pragma comment(lib,&quot;lib\\ftgl.def&quot;);
#pragma comment(lib,&quot;lib\\shx.o&quot;);
#define bool unsigned char
int closing=0;
typedef struct CharIndex
{
    int code;
    int shapePtr;
    int len;
} CharIndex;



typedef struct _ShxFont_
{
    int openOK;
    int indexCount;
    unsigned char *buffer;
    CharIndex *indexBuffer;
    int type;
    int shxFontDownLine,shxFontUpLine;
    double scale;
} ShxFont;

ShxFont *sf;
// Private GDI Device Context
HGLRC		hRC=NULL;		// Permanent Rendering Context
HWND		hWnd=NULL;		// Holds Our Window Handle
HINSTANCE	hInstance;		// Holds The Instance Of The Application

GLuint	base;				// Base Display List For The Font Set
GLfloat	cnt1;				// 1st Counter Used To Move Text &amp; For Coloring
GLfloat	cnt2;				// 2nd Counter Used To Move Text &amp; For Coloring

bool	keys[256];			// Array Used For The Keyboard Routine
bool	active=TRUE;		// Window Active Flag Set To TRUE By Default
bool	fullscreen=TRUE;	// Fullscreen Flag Set To Fullscreen Mode By Default

HGLRC hglrc;
HDC hdc;
int img;
int pnl;
int GuiMode=2,pfm;
int *ft;
void formcreate()
{
    hdc=GetDC(GetFormHandle(pfm));
    //hdc=(HANDLE)GetProperty(pnl,&quot;dc&quot;,0,0,0);
    int nPixelFormat;
    /* static PIXELFORMATDESCRIPTOR pfd=
     {
         sizeof(PIXELFORMATDESCRIPTOR),
         1,
         PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
         PFD_TYPE_RGBA,
         24,
         0,0,0,0,0,
         0,0,
         0,0,0,0,0,
         32,
         0,
         0,
         PFD_MAIN_PLANE,
         0,
         0,0,0
     };*/
    static	PIXELFORMATDESCRIPTOR pfd=				// pfd Tells Windows How We Want Things To Be
    {
        sizeof(PIXELFORMATDESCRIPTOR),				// Size Of This Pixel Format Descriptor
        1,											// Version Number
        PFD_DRAW_TO_WINDOW |						// Format Must Support Window
        PFD_SUPPORT_OPENGL |						// Format Must Support OpenGL
        PFD_DOUBLEBUFFER,							// Must Support Double Buffering
        PFD_TYPE_RGBA,								// Request An RGBA Format
        24,										// Select Our Color Depth
        0, 0, 0, 0, 0, 0,							// Color Bits Ignored
        0,											// No Alpha Buffer
        0,											// Shift Bit Ignored
        0,											// No Accumulation Buffer
        0, 0, 0, 0,									// Accumulation Bits Ignored
        16,											// 16Bit Z-Buffer (Depth Buffer)
        0,											// No Stencil Buffer
        0,											// No Auxiliary Buffer
        PFD_MAIN_PLANE,								// Main Drawing Layer
        0,											// Reserved
        0, 0, 0										// Layer Masks Ignored
    };

    nPixelFormat=ChoosePixelFormat(hdc,&amp;pfd);
    SetPixelFormat(hdc,nPixelFormat,&amp;pfd);

    hglrc=wglCreateContext(hdc);
    wglMakeCurrent(hdc,hglrc);
}
//---------------------------------------------------------------------------
GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}
void  FormDestroy()
{
    closing=1;
    Wait(1);
    wglMakeCurrent(NULL,NULL);
    wglDeleteContext(hglrc);
    DeleteObject(hdc);

    printf(&quot;destroy&quot;);
}


void OnClose()
{
    closing=1;
    Wait(1);
    if((GuiMode==0)||(GuiMode==1))
    {
        ClearVclControls();
        HideVclWin(200);
    }
    else
    {
        CloseForm(pfm);
    }
}
GLvoid BuildFont(GLvoid)								// Build Our Bitmap Font
{
    HFONT	font;										// Windows Font ID
    HFONT	oldfont;									// Used For Good House Keeping

    base = glGenLists(96);								// Storage For 96 Characters

    font = CreateFont(	-24,							// Height Of Font
                        0,								// Width Of Font
                        0,								// Angle Of Escapement
                        0,								// Orientation Angle
                        FW_BOLD,						// Font Weight
                        FALSE,							// Italic
                        FALSE,							// Underline
                        FALSE,							// Strikeout
                        ANSI_CHARSET,					// Character Set Identifier
                        OUT_TT_PRECIS,					// Output Precision
                        CLIP_DEFAULT_PRECIS,			// Clipping Precision
                        ANTIALIASED_QUALITY,			// Output Quality
                        FF_DONTCARE|DEFAULT_PITCH,		// Family And Pitch
                        &quot;Courier New&quot;);					// Font Name

    printf(&quot;font:%x&quot;,font);
    oldfont = (HFONT)SelectObject(hdc, font);           // Selects The Font We Want
    wglUseFontBitmaps(hdc, 32, 96, base);				// Builds 96 Characters Starting At Character 32
    SelectObject(hdc, oldfont);							// Selects The Font We Want
    DeleteObject(font);									// Delete The Font
}

GLvoid KillFont(GLvoid)									// Delete The Font List
{
    glDeleteLists(base, 96);							// Delete All 96 Characters
}
void DrawLine0(double x0,double y0,double x1,double y1)
{
    glBegin(GL_LINES);
    glVertex3f(x0,y0, 0.0f);
    glVertex3f(x1,y1, 0.0f);
    glEnd();
}
void DrawLine(ShxFont *sf,double x0,double y0,double x1,double y1)
{
    double scale;
    scale=5.0/GetShxFontHeight(sf)*1.0* sf-&gt;scale;// 0.08;
    x0*=scale;
    y0*=scale;
    x1*=scale;
    y1*=scale;
    x0+=0;
    x1+=0;

    glBegin(GL_LINES);
    glVertex3f(x0,y0, 0.0f);
    glVertex3f(x1,y1, 0.0f);
    glEnd();
}
GLvoid glPrint(const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine
{
    char		text[256];								// Holds Our String
    va_list		ap;										// Pointer To List Of Arguments

    if (fmt == NULL)									// If There's No Text
        return;											// Do Nothing

    va_start(ap, fmt);									// Parses The String For Variables
    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers
    va_end(ap);											// Results Are Stored In Text
    //printf(text);
    glPushAttrib(GL_LIST_BIT);							// Pushes The Display List Bits
    glListBase(base - 32);								// Sets The Base Character to 32
    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text);	// Draws The Display List Text
    glPopAttrib();										// Pops The Display List Bits
}
GLvoid glShxPrint(ShxFont *sf,const char *fmt, ...)					// Custom GL &quot;Print&quot; Routine
{
    char		text[256];								// Holds Our String
    va_list		ap;										// Pointer To List Of Arguments
    int i=0;
    if (fmt == NULL)									// If There's No Text
        return;											// Do Nothing
    
    va_start(ap, fmt);									// Parses The String For Variables
    vsprintf(text, fmt, ap);						// And Converts Symbols To Actual Numbers
    va_end(ap);											// Results Are Stored In Text
    while(text[i])
    {
        ReadCharShape(sf,text[i],0);
        glTranslatef(14,0.0f,0.0f);
        i++;
    }
}
GLvoid ReSizeGLScene(GLsizei width, GLsizei height)		// Resize And Initialize The GL Window
{
    if (height==0)										// Prevent A Divide By Zero By
    {
        height=1;										// Making Height Equal One
    }

    glViewport(0,0,width,height);						// Reset The Current Viewport

    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix
    glLoadIdentity();									// Reset The Projection Matrix

    // Calculate The Aspect Ratio Of The Window
    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);

    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix
    glLoadIdentity();									// Reset The Modelview Matrix
}
#define FT_ENC_TAG( value, a, b, c, d )         \
          unsigned int value = ( ( (int)(a) &lt;&lt; 24 ) |  \
                    ( (int)(b) &lt;&lt; 16 ) |  \
                    ( (int)(c) &lt;&lt;  8 ) |  \
                      (int)(d)         )


FT_ENC_TAG( FT_ENCODING_UNICODE,   'u', 'n', 'i', 'c' );

int InitGL(GLvoid)										// All Setup For OpenGL Goes Here
{
    int r;
    glShadeModel(GL_SMOOTH);							// Enable Smooth Shading
    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				// Black Background
    glClearDepth(1.0f);									// Depth Buffer Setup
    glEnable(GL_DEPTH_TEST);							// Enables Depth Testing
    glDepthFunc(GL_LEQUAL);								// The Type Of Depth Testing To Do
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations

    BuildFont();										// Build The Font

    ft=ftglCreateBufferFont(&quot;c:\\windows\\fonts\\simhei.ttf&quot;);
    ftglSetFontFaceSize(ft, 37, 72);
    ftglSetFontDepth(ft, 10);
    ftglSetFontOutset(ft, 0, 3);

    r=ftglSetFontCharMap(ft, FT_ENCODING_UNICODE);
    printf(&quot;glft:%x,set char map:%d&quot;,ft,r);
    return TRUE;										// Initialization Went OK
}
int AnsiToUnicode(unsigned char *pszA, unsigned char* ppszW)
{
    ULONG cCharacters;
    DWORD dwError;
    if (NULL == pszA)
    {
        *ppszW = NULL;
        printf(&quot;ERROR0&quot;);
        return NOERROR;
    }
    cCharacters =  strlen(pszA)+1;
    if (NULL == ppszW)
        return E_OUTOFMEMORY;
    // Covert to Unicode.
    if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, -1,
                                 ppszW, cCharacters))
    {
        dwError = GetLastError();
        free(ppszW);
        ppszW = NULL;
        printf(&quot;ERROR&quot;);
        return HRESULT_FROM_WIN32(dwError);
    }
    return NOERROR;
}
int DrawGLScene(GLvoid)									// Here's Where We Do All The Drawing
{
    char buf[]= {0x31,0,0x32,0,0x8d,0x9c,0,0};
    char buf1[100];
    int i;
    AnsiToUnicode(&quot;ftgl(TTF): Name 中国 0086&quot;,buf1);
    

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear Screen And Depth Buffer
    glLoadIdentity();									// Reset The Current Modelview Matrix
    glTranslatef(-1.0f,0.0f,-6.0f);						// Move One Unit Into The Screen
    // Pulsing Colors Based On Text Position
    glColor3f(1.0f ,0.0f ,1.0f );
    // Position The Text On The Screen
    glScalef(0.01,0.01,0.01);

      
    glLoadIdentity();	
    glTranslatef(-1.0f,0.0f,-6.0f);		
    glRasterPos2f( -3, -1);
    glPrint(&quot;Active OpenGL Text With NeHe - &quot;);	// Print GL Text To The Screen
    
    /////////////ftgl/////////////////////
    glLoadIdentity();
    glTranslatef(-3.0f,0.0f,-6.0f);	
    glScalef(0.01,0.01,0.01);
    ftglRenderFontW(ft, buf1, 0xffff);
    /////////////shx/////////////////////
    glLoadIdentity();
    glTranslatef(-3.0f,1.0f,-6.0f);
    glRasterPos2f(0, 0);
    glScalef(0.02,0.02,1);
    glShxPrint(sf,&quot;AutoCAD shx Font:12345!&quot;);
    cnt1+=0.051f;										// Increase The First Counter
    cnt2+=0.005f;
    SwapBuffers(hdc);										// Increase The First Counter
    return TRUE;										// Everything Went OK
}


void OnTimer()
{
    DrawGLScene();
}

void OnTest()
{
    DrawGLScene();
}
void OnResize()
{
    int x,y;
    x=GetProperty(pfm,&quot;width&quot;,0,0);
    y=GetProperty(pfm,&quot;height&quot;,0,0);
    ReSizeGLScene(x,y);
}

void main()
{

    int i,j;
    int mi,mi1;
    //HideLeftTools();
    ClearVclControls();
    //ShowVclWin(-1);
    if((GuiMode==0)||(GuiMode==1))
        pfm=GetGuiWin(GuiMode);
    else
        pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;调幅-正弦波&quot;,&quot;Width&quot;,600,&quot;height&quot;,300,&quot;BorderIcons&quot;,&quot;[biSystemMenu,biMaximize]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnClose&quot;,FormDestroy,&quot;OnResize&quot;,OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    int btn=CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;test&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnTest,0);
    //img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,10,&quot;width&quot;,200,&quot;height&quot;,200,0);
    SetProperty(pfm,&quot;visible&quot;,1);////
    formcreate();
    OnResize();
    InitGL();
    sf=CreateShxFont(&quot;dat\\txt.shx&quot;);
    DrawGLScene();
    
    int count=0;
    while(!closing)
    {
        DrawGLScene();
        count++;
        if(count%5==4)
        {
            //printf(&quot;count:%d&quot;,count);
            Wait(1);
        }


    }
    printf(&quot;exit&quot;);


}



"/>
    </Command>
    <Command cmdname="游戏脚本编程" cmdType="S" cmd="[S]数据发送区/C语言脚本编辑区，[F5]键发送/执行。">
      <Command cmdname="俄罗斯方块" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include&quot;libtcc1.c&quot;
#include&quot;math.h&quot;

#define WHITE 0xffffff
#define CYAN 0xffff00
#define YELLOW 0x00ffff
#define BLACK 0x00000
#define RED 0x000ff
#define GREEN 0x000ff00


/*定义左上角点在屏幕上的位置*/
#define MAPXOFT     9
#define MAPYOFT     5

/*定义下一个方块显示的位置*/
#define MAPXOFT1     14
#define MAPYOFT1     -1


#define LEFT  37
#define RIGHT 39
#define DOWN  40  /*此键为加速键*/
#define UP    38  /*此键为变形键*/
#define ESC   27  /*此键为退出键*/
#define ENTER 13

#ifdef __cplusplus
#define __CPPARGS ...
#else
#define __CPPARGS
#endif

struct shape
{
    int xy[8],next;
};


struct shape shapes[19]=
{
    /*x1,y1,x2,y2,x3,y3,x4,y4 指四个小方块的相对坐标，next指此方块变形后应变为哪个小方块
        { x1,y1,x2,y2,x3,y3,x4,y4,next}*/
    { 0,-2, 0,-1, 0, 0, 1, 0, 1},
    {-1, 0, 0, 0, 1,-1, 1, 0, 2},
    { 0,-2, 1,-2, 1,-1, 1, 0, 3},
    {-1,-1,-1, 0, 0,-1, 1,-1, 0},
    { 0,-2, 0,-1, 0, 0, 1,-2, 5},
    {-1,-1, 0,-1, 1,-1, 1, 0, 6},
    { 0, 0, 1,-2, 1,-1, 1, 0, 7},
    {-1,-1,-1, 0, 0, 0, 1, 0, 4},
    {-1, 0, 0,-1, 0, 0, 1, 0, 9},
    { 0,-2, 0,-1, 0, 0, 1,-1,10},
    {-1,-1, 0,-1, 1,-1, 0, 0,11},
    { 0,-1, 1,-2, 1,-1, 1, 0, 8},
    {-1, 0, 0,-1, 0, 0, 1,-1,13},
    { 0,-2, 0,-1, 1,-1, 1, 0,12},
    {-1,-1, 0,-1, 0, 0, 1, 0,15},
    { 0,-1, 0, 0, 1,-2, 1,-1,14},
    { 0,-3, 0,-2, 0,-1, 0, 0,17},
    {-1, 0, 0, 0, 1, 0, 2, 0,16},
    { 0,-1, 0, 0, 1,-1, 1, 0,18}
};

int board[10][20]= {0}; /*定义游戏板初始化为0*/
char sp[]=&quot;0&quot;,le[]=&quot;0&quot;,sc[]=&quot;00000&quot;;
int speed,speed0,level,score;
int sign,flag;
int style,style1;  /*style为当前方块的种类，style1为即将输出的方块的种类*/

void draw_block(int x,int y,int style,int way);
void draw_little_block(int x,int y);
void initialize();
void speed_change(void);
void score_change(int);
void kill_line(int y);

void High_line(int y);
void fill_board(int x,int y, int style);
int  change(int *i,int *j,int key);
void renovate(void);
void ajustment(void);
void level_change(void);

int needclose=0;

HPEN pen=0;
HBRUSH brush=0;
int p;
int img;
HANDLE dc;
int start=0;

int TimerCounter=0; /* 计时变量，每秒钟增加18。 */
int KeyDown=0;

void OnTimer()
{
    TimerCounter++;
}
void OnClose()
{
    printf(&quot;need close...&quot;);
    needclose=1;
    Wait(1);
    Wait(1);
    CloseForm(p);
}
void OnDblClick()
{
    PlayWave(&quot;ding.wav&quot;);
    KeyDown=ENTER;
}
void OnEnter()
{
    PlayWave(&quot;ding.wav&quot;);
    KeyDown=ENTER;
}
void OnLeft()
{
    KeyDown=LEFT;
}
void OnUp()
{
    KeyDown=UP;
}
void OnRight()
{
    KeyDown=RIGHT;
}
void OnDown()
{
    KeyDown=DOWN;
}

void OnKeyDown(int id,int *key,int state)
{
    KeyDown=*key;
}

void InitGraph()
{
    HideLeftTools();
    ClearVclControls();
    HideVclWin(200);
    //p=GetGuiWin(0);
    p=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;GDI绘图示例-俄罗斯方块&quot;,&quot;Width&quot;,520,&quot;height&quot;,580,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;BorderIcons&quot;,&quot;[]&quot;,&quot;OnKeyDown&quot;,OnKeyDown,&quot;formstyle&quot;,&quot;fsstayontop&quot;,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,40,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮


    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;Enter&quot;,&quot;left&quot;,80,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnEnter,0);
    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;Left&quot;,&quot;left&quot;,150,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnLeft,0);
    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;Up&quot;,&quot;left&quot;,220,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnUp,0);
    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;Right&quot;,&quot;left&quot;,290,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnRight,0);
    CreateComponentEx(p,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;Down&quot;,&quot;left&quot;,360,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnDown,0);

    img=CreateComponentEx(p,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,480,&quot;height&quot;,480,&quot;OnDblClick&quot;,OnDblClick,0);
    SetProperty(p,&quot;visible&quot;,1);

    RECT rect= {0,0,640,480};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0x00);
    SelectObject(dc,brush);
    FillRect(dc,&amp;rect,brush);
    DeleteObject(brush);
}
void setcolor(int cl)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    if(pen!=0) DeleteObject(pen);
    pen=CreatePen(PS_SOLID,1,cl);
    SelectObject(dc,pen);
    //if(brush!=0) DeleteObject(brush);
    //pen=CreateSolidBrush(RED);
    //SelectObject(dc,brush);    
    
}
int bioskey(int flat)
{
    int tmp;
    if(flat==1)
    {
        if(KeyDown!=0)
            return 1;
        else
            return 0;
    }
    tmp=KeyDown;
    KeyDown=0;
    return tmp;

}
 
void outtextxy(int x,int y,char *s)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    TextOutA(dc,x,y,s,strlen(s));
}
void  setbkcolor(int cl)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    SetBkColor(dc,cl);
}

void   settextcolor(int cl)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    SetTextColor(dc,cl);

}


void line(int x0,int y0,int x1,int y1)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    MoveToEx(dc,x0,y0,0);
    LineTo(dc,x1,y1);
}

void rectangle(int x0,int y0,int x1,int y1)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    MoveToEx(dc,x0,y0,0);
    LineTo(dc,x1,y0);
    LineTo(dc,x1,y1);
    LineTo(dc,x0,y1);
    LineTo(dc,x0,y0);
}
void circle(int x,int y,int r)
{
    int i;
    for(i=r;i&gt;=0;i-=2)
    rectangle(x-i/2,y-i/2,x+i/2,y+i/2);
    //dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    //Ellipse(dc,x-r/2,y-r/2,x+r/2,y+r/2);     
}


main()
{
    int i,j,key,x0=5,y0=1;
    InitGraph();

    while(!flag)                    /*flag为0表示重新开始游戏*/
    {
        if(needclose)return;
        Wait(1);
        level=score=speed=0;
        strcpy(le,&quot;0&quot;);
        strcpy(sp,&quot;0&quot;);
        strcpy(sc,&quot;00000&quot;);
        for(i=0; i&lt;10; i++)
            for(j=0; j&lt;20; j++)
                board[i][j]=0;       /*初始化一些变量为0*/
        ajustment();             /*开始游戏前调整速度和高度*/



        if(level&gt;0)
            level_change();       /*根据高度随机确定方块是否存在*/
        style=rand(100)%19;         /*随机确定方块种类*/
        while(1)
        {
            if(needclose)return;
            Wait(1);
            i=x0,j=y0;
            style1=rand(100)%19;    /*随机确定即将出现的方块种类*/
            setcolor(WHITE);
            sign=1;

            draw_block(MAPXOFT1,MAPYOFT1,style1,1);/*画出即将出现的方块*/

            speed0=0;
            for(j=y0; j&lt;=20; j++) /*使方块下降*/
            {
                if(needclose)return;
                if(!check_block(i,j,style))
                {
                    draw_block(i,j-1,style,1);
                    renovate();
                    break;
                }
                if(speed0!=9)
                    draw_block(i,j,style,1);

                while(speed0==0)// wait   1 sec
                {
                    if(needclose)return;
                    Wait(0);

                    if (TimerCounter&gt;18/(speed+1))
                    {
                        TimerCounter=0;/* 恢复计时变量 */
                        break;
                    }

                    if(bioskey(1))
                    {
                        key=bioskey(0);
                        if(change(&amp;i,&amp;j,key))/*根据按键值做调整*/
                        {
                            flag=1;
                            goto end;
                        }
                        PlayWave(&quot;down.WAV&quot;);
                    }
                }
                draw_block(i,j,style,0);
                renovate();       //            /*刷新屏幕*/

            }

            if(j==y0)
            {
                break;
            }
            j--;

            draw_block(i,j,style,1);
            fill_board(i,j,style);
            sign=1;

            High_line(j);
            kill_line(j);     /*消去的函数，消去若干行并改变分数和速度*/

            draw_block(MAPXOFT1,MAPYOFT1,style1,0);
            style=style1;
            while(bioskey(1))    /*清除内存中的按键*/
                key=bioskey(0);
        }

        setcolor(CYAN);
        
        TimerCounter=0;
 
        while(bioskey(1))     /*清除内存中的按键*/
            key=bioskey(0);
        setbkcolor(BLACK);
        settextcolor(RED);
        outtextxy(360,340,&quot;游戏结束!&quot;);
        outtextxy(360,360,&quot;按【回车】键重新开始&quot;);
        outtextxy(360,380,&quot;按【ESC】键退出&quot;);
        Invalidate(img);
        printf(&quot;Game Over!!!&quot;);
        Wait(1);
        while(bioskey(1)==0)
        {
            Wait(1);
            if(needclose)return;
        }
        key=bioskey(0);
end:
        if(key==ESC||flag)
            break;
    }
    RECT rect= {0,0,640,480};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0xFF);
    SelectObject(dc,brush);
    FillRect(dc,&amp;rect,brush);
    outtextxy(50,30,&quot; 游戏结束 &quot;);
    Invalidate(img);
    
    
    printf(&quot;exit form game!&quot;);
}

void ajustment(void)            /*开始游戏前调整速度和高度*/
{
    int key,boo=1,left=1;
    RECT rect= {0,0,640,480};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0x00);
    SelectObject(dc,brush);
    FillRect(dc,&amp;rect,brush);
    DeleteObject(brush);
    renovate();
    setcolor(YELLOW);
   
    setbkcolor(BLACK);
    settextcolor(GREEN);
    outtextxy(150,30,&quot; 按【回车】键开始游戏... &quot;);
    outtextxy(150,50,&quot; 按【上下左右】设置难度与速度 &quot;);
    outtextxy(95,280,&quot;   难度    &quot;);
    outtextxy(335,280,&quot;  速度    &quot;);
    outtextxy(6.5*16,15*16,le);
    outtextxy(21.9*16,15*16,sp);

    Invalidate(img);
    Wait(1);

    while(1)
    {
        if(needclose) return;
        Wait(1);
        if(TimerCounter&gt;4)
        {
            TimerCounter=0;
            boo*=-1;
            if(boo==-1)
                setcolor(BLACK);
            else
                setcolor(YELLOW);
            if(left==1)
            {
                line(6*16,17*16,8.5*16,17*16);
                setcolor(BLACK);
                line(21.4*16,17*16,23.9*16,17*16);
            }

            else
            {
                line(21.4*16,17*16,23.9*16,17*16);
                setcolor(BLACK);
                line(6*16,17*16,8.5*16,17*16);
            }
            Invalidate(img);
            Wait(1);

        }
        if(bioskey(1))
        {
            key=bioskey(0);

            if(key==ENTER)
                break;
            else if(key==UP)
            {
                if(left==1)
                {
                    level--;
                    if(level==-1)
                        level=9;
                }
                else
                {
                    speed--;
                    if(speed==-1)
                        speed=9;
                }
            }
            else if(key==DOWN)
            {
                if(left==1)
                {
                    level++;
                    if(level==10)
                        level=0;

                }
                else
                {
                    speed++;
                    if(speed==10)
                        speed=0;
                }
            }

            else if(key==LEFT||RIGHT)
                left*=-1;
            setcolor(YELLOW);
            sp[0]=speed+'0';
            le[0]=level+'0';
            setbkcolor(BLACK);
            settextcolor(GREEN);
            outtextxy(6.5*16,15*16,le);
            outtextxy(21.9*16,15*16,sp);
            Invalidate(img);
            Wait(1);
        }
    }
    setcolor(YELLOW);
    sp[0]=speed+'0';
    le[0]=level+'0';


    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0x00);
    SelectObject(dc,brush);
    FillRect(dc,&amp;rect,brush);
    DeleteObject(brush);
    renovate();
    setbkcolor(BLACK);
    settextcolor(GREEN);
    outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16,&quot;0000&quot;);      /*输出新分数*/
    outtextxy(-80+(MAPXOFT+21)*16-16*2.5,(MAPYOFT+6)*16,&quot;分数:&quot;);      /*输出新分数*/
    outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16-16,le);      /*输出新分数*/
    outtextxy(-80+(MAPXOFT+21)*16-16*2.5,(MAPYOFT+6)*16-16,&quot;难度:&quot;);      /*输出新分数*/
    outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16-32,sp);      /*输出新分数*/
    outtextxy(-80+(MAPXOFT+21)*16-16*2.5,(MAPYOFT+6)*16-32,&quot;速度:&quot;);      /*输出新分数*/


    Invalidate(img);
    Wait(1);
}


void level_change(void)         /*根据高度随机确定方块是否存在*/
{
    int i,j;
    setcolor(WHITE);
    for(i=1; i&lt;=10; i++)
        for(j=1; j&lt;=level; j++)
            if(rand(2))
            {
                board[i-1][20-j]=1;

                draw_little_block(i+MAPXOFT,21-j+MAPYOFT);
            }
}

/*此x,y为虚拟坐标，为19中形式中的一种：0~18中的一个
x,y为10*20的方格的坐标，下标从1开始
way为1表填充，为0表清除*/
void draw_block(int x,int y,int style,int way)
{
    int x1,y1;
    int i;
    x1=x+MAPXOFT,y1=y+MAPYOFT;
    if(way==1)
        setcolor(WHITE);
    else
        setcolor(BLACK);

    for(i=0; i&lt;=6; i+=2)
        draw_little_block(x1+shapes[style].xy[i],y1+shapes[style].xy[i+1]);
    if(sign==1)
        sign=0;
    if(way==1)
        Invalidate(img);
}

void draw_little_block(int x,int y)/*此处仅在10*20的游戏版内画小方块，若在外，不画之。*/
{
    if((x&gt;=10&amp;&amp;x&lt;20&amp;&amp;y&gt;=6&amp;&amp;y&lt;26)||sign)
    {
        rectangle(x*16,y*16,x*16+16,y*16+16);
        circle(x*16+8,y*16+8,6);
    }
}


int check_block(int x,int y,int style)/*此处检查在(x,y)处放置一方块是否可以，若是，则返回1，否则返回0*/
{
    int x1=x+MAPXOFT,y1=y+MAPYOFT;
    int x2,y2,i;
    for(i=0; i&lt;=6; i+=2)
    {
        x2=x1+shapes[style].xy[i];
        y2=y1+shapes[style].xy[i+1];
        if(x2&gt;=10&amp;&amp;x2&lt;20&amp;&amp;y2&lt;26&amp;&amp;(y2&lt;6||board[x2-10][y2-6]==0))
            continue;
        else
            break;
    }


    if(i==8)
        return 1;
    else
        return 0;
}

void speed_change(void)        /*此为变速函数，当分数超过一级时，即加一。*/
{
    if(score&gt;=(sp[0]-'0')*100&amp;&amp;(sp[0]-'0')&lt;9)
    {
        sp[0]++;
        speed++;

        setbkcolor(BLACK);
        settextcolor(GREEN);
        outtextxy(21.9*16,15*16,sp);
    }
}

void score_change(int count)        /*count为消去的行数，据此来改变score的值*/
{
    int score_inc[4]= {1,3,7,13};
    int i;

    score+=score_inc[count-1];
    sc[4]+=score_inc[count-1];
    for(i=4; i&gt;=1; i--)
    {
        sc[i-1]+=(sc[i]-'0')/10;
        sc[i]-=(sc[i]-'0')/10*10;
    }
    setcolor(YELLOW);
    
    setbkcolor(BLACK);
    settextcolor(GREEN);
    outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16,sc);      /*输出新分数*/
}

void High_line(int y)/*消去的函数，消去若干行并改变分数和速度*/
{
    int count=0,i,t=1,j,k;
    int row;

    for(j=0; j&lt;4; j++)
    {
        count=0;
        for(row=y; row&gt;=1; row--)
        {
            for(i=1; i&lt;=10; i++)
                if(!board[i-1][row-1])
                    break;
            if(i==11)
            {
                count++;
                for(k=1; k&lt;=10; k++)
                {
                    if(j%2==0)
                        setcolor(RED);
                    else
                        setcolor(0x00ff00);
                    draw_little_block(k+MAPXOFT,row+MAPYOFT);
                }
            }
        }
        if(count&gt;0)
        {
            if(j==0) score_change(count);
            Invalidate(img);
            if(j==0)
                PlayWave(&quot;addscore.wav&quot;);
            Wait(100);
        }
        else
            return;
    }
}

void kill_line(int y)/*消去的函数，消去若干行并改变分数和速度*/
{
    int count=0,i,t=1,j,k;
    for(; y&gt;=1&amp;&amp;t&lt;=4; y--,t++)
    {
        for(i=1; i&lt;=10; i++)
            if(!board[i-1][y-1])
                break;
        if(i==11)
        {
            count++;
            for(k=1; k&lt;=10; k++)
            {
                setcolor(BLACK);
                draw_little_block(k+MAPXOFT,y+MAPYOFT);
            }
            for(j=y-1; j&gt;=1; j--)
                for(k=1; k&lt;=10; k++)
                {
                    board[k-1][j]=board[k-1][j-1];
                    if(board[k-1][j])
                    {
                        setcolor(BLACK);
                        draw_little_block(k+MAPXOFT,j+MAPYOFT);
                        setcolor(WHITE);
                        draw_little_block(k+MAPXOFT,j+1+MAPYOFT);
                    }
                }
            renovate();
            Wait(10);
            y++;
        }
    }
}

void fill_board(int x,int y, int style) /*当一方块停止时，将中相应的值改为1*/
{

    int x1,y1,i;
    for(i=0; i&lt;=6; i+=2)
    {
        x1=x+shapes[style].xy[i];
        y1=y+shapes[style].xy[i+1];
        board[x1-1][y1-1]=1;
    }
}

int change(int *i,int *j,int key)/*控制方块移动、变形的函数*/
{
    int key1;
    if(key==UP&amp;&amp;check_block(*i,*j,shapes[style].next))
    {
        draw_block(*i,*j,style,0);
        style=shapes[style].next;
        draw_block(*i,*j,style,1);
    }
    else if(key==LEFT&amp;&amp;check_block(*i-1,*j,style))
    {
        draw_block(*i,*j,style,0);
        (*i)--;
        draw_block(*i,*j,style,1);
    }
    else if(key==RIGHT&amp;&amp;check_block(*i+1,*j,style))
    {
        draw_block(*i,*j,style,0);
        (*i)++;
        draw_block(*i,*j,style,1);
    }
    else if(key==DOWN&amp;&amp;check_block(*i,*j+1,style))
    {
        draw_block(*i,*j,style,0);
        (*j)++;
        draw_block(*i,*j,style,1);
        speed0=9;
    }
    else if(key==ENTER)
    {
        while(1)
        {
            Wait(1);
            if(bioskey(1))
                key1=bioskey(0);
            if(key1==ENTER)
                break;
        }
    }
    else if(key==ESC)
        return 1;
    else if(key==21040)
    {
        sign=1;
        draw_block(MAPXOFT1,MAPYOFT1,style1,0);
        style1=16;
        sign=1;
        draw_block(MAPXOFT1,MAPYOFT1,style1,1);
    }
    return 0;
}


void renovate(void)    /*刷新屏幕*/
{
    int i,j;
    setcolor(WHITE);
    for(i=1; i&lt;=10; i++)
        for(j=1; j&lt;=20; j++)
            if(board[i-1][j-1]==1)
                draw_little_block(i+MAPXOFT,j+MAPYOFT);

    setcolor(BLACK);

    rectangle(10*16-1,6*16-1,20*16+1,26*16+1);
    setcolor(YELLOW);
    rectangle(10*16-2,6*16-2,20*16+2,26*16+2);
    Invalidate(img);
    Wait(0);

}
















"/>
      <Command cmdname="五子棋" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include &quot;stdio.h&quot;
#include &quot;conio.h&quot;
#define SIZE 24
#define X0 30
#define Y0 30
#define Radius 16
#define TRUE 1
#include &quot;stdio.h&quot;
#include &quot;dos.h&quot;
#include &quot;conio.h&quot;
#include &quot;stdlib.h&quot;

#define LEFT  37
#define RIGHT 39
#define DOWN  40  /*此键为加速键*/
#define UP    38  /*此键为变形键*/
#define ESC   27  /*此键为退出键*/
#define ENTER 13
#define DEPTH 21  //递归深度，棋力

int player_x,player_y;
int kx=7,ky=7;
int old_x,old_y;
char back[6]= {27,28,25,26,31,48};
int pfm;
void graph_init();
void drawline();
char getkey();
void drawcircle(int ,int ,char);
void drawcross(int,int);
void setbit(int,int);

int needclose=0;
int KeyDown=0;
HPEN pen=0;
int img;
HANDLE dc;
int ms;
int mx,my;
void setcolor(int cl)
{
    cl*=0xfffff;
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    if(pen!=0) DeleteObject(pen);
    pen=CreatePen(PS_SOLID,1,cl);
    SelectObject(dc,pen);
}
int bioskey(int flat)
{
    int tmp;
    if(flat==1)
    {
        if(KeyDown!=0)
            return 1;
        else
            return 0;
    }
    tmp=KeyDown;
    KeyDown=0;
    return tmp;

}
void putpixel(int x,int y,int cl)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    SetPixel(dc,x,y,cl*0xfffff);
}
void settextstyle(int a,int b,int c)
{

}
void outtextxy(int x,int y,char *s)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    TextOutA(dc,x,y,s,strlen(s));
}

void line(int x0,int y0,int x1,int y1)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    MoveToEx(dc,x0,y0,0);
    LineTo(dc,x1,y1);
}

void rectangle(int x0,int y0,int x1,int y1)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    MoveToEx(dc,x0,y0,0);
    LineTo(dc,x1,y0);
    LineTo(dc,x1,y1);
    LineTo(dc,x0,y1);
    LineTo(dc,x0,y0);
}
void circle(int x,int y,int r)
{
    rectangle(x-r/2,y-r/2,x+r/2,y+r/2);
}


void setmousecoord(int x,int y)
{
    RECT rect;
    //x+=10;
    //y+=40;
    rect.left=x-10;
    rect.top=y-10;
    rect.right=x+10;
    rect.bottom=y+10;

    InvalidateImgRect(img,&amp;rect,1);
    return;

    InvalidateRect(GetFormHandle(pfm),&amp;rect,0);
    UpdateWindow(GetFormHandle(pfm));

}


void setfillstyle(int m1,int m2)
{

}

void ellipse(int x0,int y0,int start,int end,int r0,int r1)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    Ellipse(dc,x0-r0/2,y0-r1/2,x0+r0/2,y0+r1/2);
}



void OnKeyDown(int id,int *key,int state)
{
    KeyDown=*key;
}



typedef struct struct1
{
    char p[4];
    char l[4];
    char d[4];
} QCL;


QCL pos[15][15][2];
char all[15][15][2];

char keepgo(int,int,int,char,char,int,QCL);
char goon(int,int,char,char,int);
char ifgook(int,int,char,char);
char computer_keep(int,int,int);
void exit_game();
unsigned int step=0;
unsigned keep[11]=
{
    0x0015,  //011100
    0x0062,  //001110
    0x0613,  //010110
    0x0614,  //011010
    0x0000,  //111111
    0x0001,  //01111
    0x0002,  //10111
    0x0003,  //11011
    0x0004,  //11101
    0x0005,  //11110
    0x0000   //11111
};
char judge;
/*****************************/
/*     return value          */
/*   -1    can not move      */
/*   0     nothing           */
/*   1     5,6  ready        */
/*   2     3    ready        */
/*   3     3,3  ready        */
/*   4     4    ready        */
/*   5     3,4  ready        */
/*   6     4,4  ready        */
/*****************************/
char computer_go(int) ;
char many(int ,int);
char power(int ,int ,char);
/*****************************/
/*     return value          */
/*   -1    lose the game     */
/*   0     nothing happen    */
/*   1     win the game      */
/*****************************/




void active_init(void);
void game_init(void);


unsigned int left,top,right,down;
unsigned char player,computer;
QCL Glist;
char active[15][15][2];
char qz[15][15];


#define LEN 252
#define COLOR 15
#define INTR 0X1C    /* The clock tick interrupt */


#define X 98
#define Y 10
char num[11][9]=
{
    {0x7e,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7e},//0
    {0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},//1
    {0x7e,0x01,0x01,0x01,0x7e,0x80,0x80,0x80,0x7e},//2
    {0x7e,0x01,0x01,0x01,0x7e,0x01,0x01,0x01,0x7e},//3
    {0x81,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x01},//4
    {0x7e,0x80,0x80,0x80,0x7e,0x01,0x01,0x01,0x7e},//5
    {0x7e,0x80,0x80,0x80,0x7e,0x81,0x81,0x81,0x7e},//6
    {0x7e,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},//7
    {0x7e,0x81,0x81,0x81,0x7e,0x81,0x81,0x81,0x7e},//8
    {0x7e,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x7e},//9
    {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff},
};


#define COLOR 10

void text(int,int,char,int,char *);

int count0=0,second0=0;/*computer's time*/
int count1=0,second1=0;/*player's time*/
int check;



void set(int che)
{
    if(che&gt;2) return;
    check=che;
}
void reset()
{
    count0=0;
    count1=0;
    second0=0;
    second1=0;
    check=0;

}


void init();
void attrib(int x,int y,QCL *pl,char color1,char color2);
void qz_init();
void game_init(void)
{
    init();
    active_init();
    qz_init();
    left=right=top=down=7;
}
void active_init(void)
{
    int i,j;
    for(i=0; i&lt;15; i++)
        for(j=0; j&lt;15; j++)
            active[i][j][0]=active[i][j][1]=0;
}
void qz_init(void)
{
    int i,j;
    for(i=0; i&lt;15; i++)
        for(j=0; j&lt;15; j++)
            qz[i][j]=0;
}

char computer_go(int len)
{
    register int i,j;
    char result,temp1,temp2,temp3;
    int max,large;
    char max_x,max_y;
    //ShowMessage(&quot;Computer go&quot;);
    step++;
    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
        {
            all[i][j][computer-1]=ifgook(i,j,computer,player);
            pos[i][j][computer-1]=Glist;
            all[i][j][player-1]=ifgook(i,j,player,computer);
            pos[i][j][player-1]=Glist;
        }

    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
            if(all[i][j][computer-1]==1)
            {
                drawcircle(i,j,computer);
                return 1;
            }

    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
            if(all[i][j][player-1]==1)
            {
                if(all[i][j][computer-1]!=-1)
                {
                    drawcircle(i,j,computer);
                    return 0;
                }
                else return -1;
            }

    large=-1;
    judge=4;
    if(len==3)
    {
        for(i=left; i&lt;=right; i++)
            for(j=top; j&lt;=down; j++)
            {
                if(active[i][j][computer-1]==1)
                {
                    switch(all[i][j][computer-1])
                    {
                    case -1:
                        break;
                    case 0:
                        break;
                    case 6:
                    case 1:
                        drawcircle(i,j,computer);
                        return 1;
                    case 2:
                    case 3:
                        break;
                    case 5:
                        qz[i][j]=computer;
                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);
                        qz[i][j]=0;
                        if(temp1==-1)
                        {
                            drawcircle(i,j,computer);
                            return 0;
                        }
                        break;
                    case 4:
                        temp3=power(i,j,computer);
                        if(temp3&lt;=large) break;
                        qz[i][j]=computer;
                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);
                        qz[i][j]=0;
                        if(temp1==-1)
                        {
                            large=temp3;
                            max_x=i;
                            max_y=j;
                        }
                        break;
                    default:
                        printf(&quot;error if computer_go().&quot;);
                    }
                }
            }
        if(large&gt;=0)
        {
            drawcircle(max_x,max_y,computer);
            return 0;
        }
        result=computer_keep(player_x,player_y,3);
        if(result==1) return 0;
    }
    else
    {
        judge=4;
        large=-1;
        for(i=left; i&lt;=right; i++)
            for(j=top; j&lt;=down; j++)
            {
                if(active[i][j][computer-1]==1)
                {
                    switch(all[i][j][computer-1])
                    {
                    case -1:
                        break;
                    case 0:
                        break;
                    case 6:
                    case 1:
                        drawcircle(i,j,computer);
                        return 1;
                    case 2:
                    case 3:
                        break;
                    case 5:
                        qz[i][j]=computer;
                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);
                        qz[i][j]=0;
                        if(temp1==-1)
                        {
                            drawcircle(i,j,computer);
                            return 0;
                        }
                        break;
                    case 4:
                        temp3=power(i,j,computer);
                        if(temp3&lt;=large) break;
                        qz[i][j]=computer;
                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);
                        qz[i][j]=0;
                        if(temp1==-1)
                        {
                            large=temp3;
                            max_x=i;
                            max_y=j;
                        }
                        break;
                    default:
                        printf(&quot;error if computer_go().&quot;);
                    }
                }
            }
        if(large&gt;=0)
        {
            drawcircle(max_x,max_y,computer);
            return 0;
        }
    }

    large=-1;
    judge=4;
    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
        {
            if(active[i][j][player-1]==1)
            {
                temp1=all[i][j][computer-1];
                switch(all[i][j][player-1])
                {
                case -1:
                    break;
                case 0:
                    break;
                case 6:
                case 1:
                    if(temp1!=-1)
                    {
                        drawcircle(i,j,computer);
                        return 0;
                    }
                    break;
                case 2:
                case 3:
                    break;
                case 5:
                    if(temp1!=-1)
                    {
                        qz[i][j]=player;
                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);
                        qz[i][j]=0;
                        if(temp2==-1)
                        {
                            drawcircle(i,j,computer);
                            return 0;
                        }
                    }
                    break;
                case 4:
                    if(temp1!=-1)
                    {
                        temp3=power(i,j,player);
                        if(temp3&lt;=large) break;
                        qz[i][j]=player;
                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);
                        qz[i][j]=0;
                        if(temp2==-1)
                        {
                            large=temp3;
                            max_x=i;
                            max_y=j;
                        }
                    }
                    break;
                default:
                    printf(&quot;error if player_go().&quot;);
                }
            }
        }
    if(large&gt;=0)
    {
        drawcircle(max_x,max_y,computer);
        return 0;
    }


    judge=3;
    large=-1;
    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
        {
            if(active[i][j][computer-1]==1)
            {
                switch(all[i][j][computer-1])
                {
                case -1:
                    break;
                case 0:
                    break;
                case 6:
                case 5:
                    drawcircle(i,j,computer);
                    return 0;
                case 1:
                    drawcircle(i,j,computer);
                    return 1;
                case 2:
                case 3:
                    temp3=power(i,j,computer);
                    if(temp3&lt;=large) break;
                    qz[i][j]=computer;
                    temp1=keepgo(i,j,3,player,computer,0,pos[i][j][computer-1]);
                    qz[i][j]=0;
                    if(temp1==-1)
                    {
                        large=temp3;
                        max_x=i;
                        max_y=j;
                    }
                    break;
                case 4:
                    temp3=power(i,j,computer);
                    if(temp3&lt;=large) break;
                    qz[i][j]=computer;
                    temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);
                    qz[i][j]=0;
                    if(temp1==-1)
                    {
                        large=temp3;
                        max_x=i;
                        max_y=j;
                    }
                    break;
                default:
                    printf(&quot;error if player_go().&quot;);
                }
            }
        }
    if(large&gt;=0)
    {
        drawcircle(max_x,max_y,computer);
        return 0;
    }


    large=-1;
    judge=3;
    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
        {
            if(active[i][j][player-1]==1)
            {
                temp1=all[i][j][computer-1];
                switch(all[i][j][player-1])
                {
                case -1:
                    break;
                case 0:
                    break;
                case 6:
                case 5:
                case 1:
                    if(temp1!=-1)
                    {
                        drawcircle(i,j,computer);
                        return 0;
                    }
                    break;
                case 3:
                    if(temp1!=-1)
                    {
                        qz[i][j]=player;
                        temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]);
                        qz[i][j]=0;
                        if(temp2!=1)
                        {
                            drawcircle(i,j,computer);
                            return 0;
                        }
                    }
                    break;
                case 2:
                    if(temp1!=-1)
                    {
                        temp3=power(i,j,player);
                        if(temp3&lt;=large) break;
                        qz[i][j]=player;
                        temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]);
                        qz[i][j]=0;
                        if(temp2!=1)
                        {
                            large=temp3;
                            max_x=i;
                            max_y=j;
                        }
                    }
                    break;
                case 4:
                    if(temp1!=-1)
                    {
                        temp3=power(i,j,player);
                        if(temp3&lt;=large) break;
                        qz[i][j]=player;
                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);
                        qz[i][j]=0;
                        if(temp2==-1)
                        {
                            large=temp3;
                            max_x=i;
                            max_y=j;
                        }
                    }
                    break;
                default:
                    printf(&quot;error if player_go().&quot;);
                }
            }
        }
    if(large&gt;=0)
    {
        drawcircle(max_x,max_y,computer);
        return 0;
    }

    max=-1;
    max_x=6;
    max_y=7;
    if(computer==2&amp;&amp;step&lt;=5)
    {
        for(i=left; i&lt;=right; i++)
            for(j=top; j&lt;=down; j++)
            {
                if(all[i][j][0]&gt;0&amp;&amp;all[i][j][1]&gt;0)
                {
                    temp1=power(i,j,1);
                    if(temp1&gt;max)
                    {
                        max=temp1;
                        max_x=i;
                        max_y=j;
                    }
                    else if(temp1==max&amp;&amp;power(max_x,max_y,computer)&lt;power(i,j,computer))
                    {
                        max_x=i;
                        max_y=j;
                    }
                }
            }
        if(max&gt;=0)
        {
            drawcircle(max_x,max_y,computer);
            return 0;
        }

        for(i=left; i&lt;=right; i++)
            for(j=top; j&lt;=down; j++)
            {
                if(all[i][j][computer-1]!=-1)
                {
                    temp1=power(i,j,1);
                    if(temp1&gt;max)
                    {
                        max=temp1;
                        max_x=i;
                        max_y=j;
                    }
                }
            }
        if(max&gt;=0)
        {
            drawcircle(max_x,max_y,computer);
            return 0;
        }
    }

    if(computer==1&amp;&amp;step&lt;=5)
    {
        for(i=left; i&lt;=right; i++)
            for(j=top; j&lt;=down; j++)
            {
                if(all[i][j][computer-1]!=-1&amp;&amp;active[i][j][computer-1]==1&amp;&amp;all[i][j][player-1]&gt;0)
                {
                    temp1=power(i,j,computer);
                    if(temp1&gt;max)
                    {
                        max=temp1;
                        max_x=i;
                        max_y=j;
                    }
                    else if(temp1==max&amp;&amp;power(max_x,max_y,player)&lt;power(i,j,player))
                    {
                        max_x=i;
                        max_y=j;
                    }
                }
            }
        if(max&gt;=0)
        {
            drawcircle(max_x,max_y,computer);
            return 0;
        }
    }

    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
        {
            if(qz[i][j]==0&amp;&amp;all[i][j][computer-1]!=-1)
            {
                temp1=many(i,j);
                if(temp1&gt;max)
                {
                    max=temp1;
                    max_x=i;
                    max_y=j;
                }
            }
        }
    drawcircle(max_x,max_y,computer);
    return 0;
}

char player_go()
{
    char result;

    result=getkey();

    if(needclose)
    {
        printf(&quot;exit player go&quot;);
        return 0;
    }

    switch(result)
    {
    case 0:
        return 0;
    case -1:
        return -1;
    case 1:
        return 1;
    case 3:
    case 2:
        return 3;
    case 4:
    case 5:
    case 6:
        return 4;
    default:
        return result;
    }
}

char ifgook(int x,int y,char color1,char color2)
{
    register int i;
    int k3=0,k4=0;
    if(qz[x][y]!=0) return -1;
    qz[x][y]=color1;
    attrib(x,y,&amp;Glist,color1,color2);
    qz[x][y]=0;
    for(i=0; i&lt;4; i++)
    {
        if(Glist.p[i]&gt;=0&amp;&amp;Glist.p[i]&lt;=3)
            k3++;
        else if(Glist.p[i]==10)
            return 1;   /* there is five .*/

        else if(Glist.p[i]&lt;10&amp;&amp;Glist.p[i]&gt;=5)
            k4++;

        if(Glist.p[i]==4&amp;&amp;color1==1) return -1;
        if(Glist.p[i]==4&amp;&amp;color1==2) return 1;
    }
    if(k4&gt;1)
    {
        if(color1==1) return -1;
        else   return 6;
    }
    if(k3&gt;1&amp;&amp;color1==1) return -1;
    if(k3==1&amp;&amp;k4==1) return 5;  /* case  a 3 and a 4 */
    if(k3&gt;1) return 3;
    if(k4==1) return 4 ;        /* case a 4          */
    if(k3==1) return 2 ;        /* case a 3          */
    return 0;
}

char keepgo(int x,int y,int  len,char color1,char color2,int depth,QCL list)
{
    int dx,dy,x0,y0;
    int i,bx,by,mask,d,r0,r1,r2;
    char old_judge;
    if(depth&gt;=DEPTH) return -1;
    else   depth++;
    for(i=0; i&lt;4; i++)
    {
        switch(i)
        {
        case 0:
            dx=0;
            dy=1;
            break;
        case 1:
            dx=1;
            dy=1;
            break;
        case 2:
            dx=1;
            dy=0;
            break;
        case 3:
            dx=1;
            dy=-1;
            break;
        }
        if(list.l[i]==len)
        {
            int j;
            j=list.p[i];
            bx=x-dx*list.d[i];
            by=y-dy*list.d[i];
            mask=keep[j];
            while(mask!=0)
            {

                d=(mask&amp;0x000f)-1;
                x0=bx+d*dx;
                y0=by+d*dy;
                r1=ifgook(x0,y0,color1,color2);

                switch(r1)
                {
                case -1:
                    break;
                case 0:
                    if(judge==4||judge==5)
                    {
                        qz[x0][y0]=color1;
                        r2=goon(x,y,color2,color1,depth);
                        qz[x0][y0]=0;
                        if(r2==1) break;
                        else return 1;
                    }
                    if(judge==3)
                    {
                        judge=4;
                        qz[x0][y0]=color1;
                        r2=goon(x0,y0,color1,color2,depth);
                        judge=3;
                        if(r2==1) judge=4;
                        r2=goon(x,y,color2,color1,depth);
                        qz[x0][y0]=0;
                        judge=3;
                        if(r2==1) break;
                        else return 1;
                    }
                case 2:
                case 3:
                    old_judge=judge;
                    if(judge==3) judge=4;
                    qz[x0][y0]=color1;
                    r2=goon(x,y,color2,color1,depth);
                    qz[x0][y0]=0;
                    judge=old_judge;
                    if(r2==1) break;
                    else return 1;
                case 1:
                    return 1;
                case 4:
                case 5:
                case 6:
                    old_judge=judge;
                    if(judge==3||judge==4) judge=5;
                    qz[x0][y0]=color1;
                    r2=goon(x,y,color2,color1,depth);
                    qz[x0][y0]=0;
                    judge=old_judge;
                    if(r2==1) break;
                    else return 1;
                default:
                    printf(&quot;error in keepgo()&quot;);
                    break;
                }
                mask=mask&gt;&gt;4;
            }
        }
    }
    return -1;
}
char goon(int x,int y,char color1,char color2,int depth)
{
    int i,dx,dy,k1,k2,rang1,rang2,temp;
    int nx,ny;
    char r1,r2;
    for(i=0; i&lt;4; i++)
    {
        k1=1;
        k2=1;
        switch(i)
        {
        case 0:
            dx=0;
            dy=1;
            rang1=(y&gt;4)?4:y;
            rang2=(14-y&gt;4)?4:14-y;
            break;
        case 1:
            dx=1;
            dy=1;
            rang1=(x&lt;y)?x:y;
            rang1=(rang1&gt;4)?4:rang1;
            rang2=(x&gt;y)?x:y;
            rang2=(14-rang2&gt;4)?4:14-rang2;
            break;
        case 2:
            dx=1;
            dy=0;
            rang1=(x&gt;4)?4:x;
            rang2=(14-x&gt;4)?4:14-x;
            break;
        case 3:
            dx=1;
            dy=-1;
            rang1=(x&lt;14-y)?x:14-y;
            rang1=(rang1&gt;4)?4:rang1;
            rang2=(14-x&lt;y)?14-x:y;
            rang2=(rang2&gt;4)?4:rang2;
            break;
        }
        while(k1&lt;=rang1)
        {
            nx=x-k1*dx;
            ny=y-k1*dy;
            temp=qz[nx][ny];
            k1++;
            if(temp==0)
            {
                r1=ifgook(nx,ny,color1,color2);
                switch(r1)
                {
                case -1:
                case 0:
                    break;
                case 1:
                    return 1;
                case 2:
                case 3:
                    if(judge!=3) break;
                    qz[nx][ny]=color1;
                    r2=keepgo(nx,ny,3,color2,color1,depth,Glist);
                    qz[nx][ny]=0;
                    if(r2==-1) return 1;
                    break;
                case 6:
                case 5:
                case 4:
                    if(judge==5) break;
                    qz[nx][ny]=color1;
                    r2=keepgo(nx,ny,4,color2,color1,depth,Glist);
                    qz[nx][ny]=0;
                    if(r2==-1) return 1;
                    break;
                }
            }
            if(temp==color2) break;
        }

        while(k2&lt;=rang2)
        {
            nx=x+k2*dx;
            ny=y+k2*dy;
            temp=qz[nx][ny];
            k2++;
            if(temp==0)
            {
                r1=ifgook(nx,ny,color1,color2);
                switch(r1)
                {
                case -1:
                case 0:
                    break;
                case 1:
                    return 1;
                case 2:
                case 3:
                    if(judge!=3) break;
                    qz[nx][ny]=color1;
                    r2=keepgo(nx,ny,3,color2,color1,depth,Glist);
                    qz[nx][ny]=0;
                    if(r2==-1) return 1;
                    break;
                case 5:
                case 6:
                case 4:
                    if(judge==5) break;
                    qz[nx][ny]=color1;
                    r2=keepgo(nx,ny,4,color2,color1,depth,Glist);
                    qz[nx][ny]=0;
                    if(r2==-1) return 1;
                    break;
                }
            }
            if(temp==color2) break;
        }
    }
    return -1;
}
char computer_keep(int x,int y,int len)
{
    int dx,dy,x0,y0;
    int i,j,bx,by,mask,d,r1,r2;
    int temp;
    char old_judge;
    int max=-1,max_x,max_y;
    QCL list;
    attrib(x,y,&amp;list,player,computer);
    judge=3;
    for(i=0; i&lt;4; i++)
    {
        switch(i)
        {
        case 0:
            dx=0;
            dy=1;
            break;
        case 1:
            dx=1;
            dy=1;
            break;
        case 2:
            dx=1;
            dy=0;
            break;
        case 3:
            dx=1;
            dy=-1;
            break;
        }
        if(list.l[i]==len)
        {
            j=list.p[i];
            bx=x-dx*list.d[i];
            by=y-dy*list.d[i];
            mask=keep[j];
            while(mask!=0)
            {
                d=(mask&amp;0x000f)-1;
                x0=bx+d*dx;
                y0=by+d*dy;
                r1=ifgook(x0,y0,computer,player);
                switch(r1)
                {
                case -1:
                    break;
                case 0:
                    old_judge=judge;
                    judge=4;
                    qz[x0][y0]=computer;
                    r2=goon(x0,y0,computer,player,0);
                    if(r2==-1) judge=3;
                    r2=goon(x,y,player,computer,0);
                    qz[x0][y0]=0;
                    judge=old_judge;
                    if(r2==1) break;
                    r2=power(x0,y0,1);
                    if(max&lt;r2)
                    {
                        max=r2;
                        max_x=x0;
                        max_y=y0;
                    }
                    break;
                case 1:
                    drawcircle(x0,y0,computer);
                    return 1;
                case 2:
                case 3:
                    old_judge=judge;
                    judge=4;
                    qz[x0][y0]=computer;
                    r2=goon(x,y,player,computer,0);
                    qz[x0][y0]=0;
                    judge=old_judge;
                    if(r2==1) break;
                    drawcircle(x0,y0,computer);
                    return 1;
                case 4:
                case 5:
                case 6:
                    drawcircle(x0,y0,computer);
                    return 1;
                default:
                    printf(&quot;error in keepgo()&quot;);
                    break;
                }
                mask=mask&gt;&gt;4;
            }//end while
            if(max&gt;=0)
            {
                drawcircle(max_x,max_y,computer);
                return 1;
            }
            mask=keep[j];
            while(mask!=0)
            {
                d=(mask&amp;0x000f)-1;
                x0=bx+d*dx;
                y0=by+d*dy;
                r1=ifgook(x0,y0,computer,player);
                temp=power(x0,y0,player);
                if(temp&gt;max&amp;&amp;r1!=-1)
                {
                    max=temp;
                    max_x=x0;
                    max_y=y0;
                }
                mask=mask&gt;&gt;4;
            }
            if(max&gt;=0)
            {
                drawcircle(max_x,max_y,computer);
                return 1;
            }
        } //end if
    }  //end for
    return 0;
}
char many(int x,int y)
{
    int l,t,r,d;
    int num=0,id=0;
    l=(x-2&gt;0)?x-2:0;
    t=(y-2&gt;0)?y-2:0;
    r=(x+2&gt;14)?14:x+2;
    d=(y+2&gt;14)?14:y+2;

    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)
    {
        if(qz[x-1][y-1]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  ;
            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==computer)  num++;
            else  num--;
        }
        else if(qz[x-1][y-1]==computer)
        {
            id=1;
            num+=2;
            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  num++;
            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if(y-1&gt;=t)
    {
        if(qz[x][y-1]==0)
        {
            num++;
            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  ;
            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==computer)  num++;
            else  num--;
        }
        else  if(qz[x][y-1]==computer)
        {
            id=1;
            num+=2;
            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  num++;
            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)
    {
        if(qz[x+1][y-1]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  ;
            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==computer)  num++;
            else  num--;
        }
        else if(qz[x+1][y-1]==computer)
        {
            id=1;
            num+=2;
            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  num++;
            else  if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==computer)  num+=2;
            else  num--;

        }
        else num-=2;
    }
    else num-=2;

    if(x-1&gt;=l)
    {
        if(qz[x-1][y]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  ;
            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==computer)  num++;
            else  num--;
        }
        else  if(qz[x-1][y]==computer)
        {
            id=1;
            num+=2;
            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  num++;
            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)
    {
        if(qz[x-1][y+1]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  ;
            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==computer)  num++;
            else  num--;
        }
        else  if(qz[x-1][y+1]==computer)
        {
            id=1;
            num+=2;
            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  num++;
            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if(y+1&lt;=d)
    {
        if(qz[x][y+1]==0)
        {
            num++;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  ;
            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;
            else  num--;
        }
        else  if(qz[x][y+1]==computer)
        {
            id=1;
            num+=2;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;
            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num+=2;
            else  num--;

        }
        else num-=2;
    }
    else num-=2;

    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)
    {
        if(qz[x+1][y+1]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  ;
            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==computer)  num++;
            else  num--;
        }
        else  if(qz[x+1][y+1]==computer)
        {
            id=1;
            num+=2;
            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  num++;
            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if(x+1&lt;=r)
    {
        if(qz[x+1][y]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  ;
            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==computer)  num++;
            else  num--;
        }
        else   if(qz[x+1][y]==computer)
        {
            id=1;
            num+=2;
            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  num++;
            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if (id==1) return num;
    else return -1;
}
char power(int x,int y,char color)
{
    int l,t,r,d,num;
    l=(x-2&gt;0)?x-2:0;
    t=(y-2&gt;0)?y-2:0;
    r=(x+2&gt;14)?14:x+2;
    d=(y+2&gt;14)?14:y+2;

    num=0;
    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)
        if(qz[x-1][y-1]==color)
        {
            num+=2;
            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==color)  num+=2;
            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  num++;
            else  num--;
        }
        else if(qz[x-1][y-1]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==color)  num++;
            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  ;
            else num--;
        }
    //else num--;

    if(y-1&gt;=t)
        if(qz[x][y-1]==color)
        {
            num+=2;
            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==color)  num+=2;
            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  num++;
            else num--;
        }
        else if(qz[x][y-1]==0)
        {
            num++;
            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==color)  num++;
            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0) ;
            else num--;
        }
    //else num--;

    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)
        if(qz[x+1][y-1]==color)
        {
            num+=2;
            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==color)  num+=2;
            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  num++;
            else num--;
        }
        else if(qz[x+1][y-1]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==color)  num++;
            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  ;
            else num--;
        }
    //else num--;

    if(x-1&gt;=l)
        if(qz[x-1][y]==color)
        {
            num+=2;
            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==color)  num+=2;
            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  num++;
            else num--;
        }
        else if(qz[x-1][y]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==color)  num++;
            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0) ;
            else  num--;
        }
    //else num--;

    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)
        if(qz[x-1][y+1]==color)
        {
            num+=2;
            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==color)  num+=2;
            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  num++;
            else num--;
        }
        else if(qz[x-1][y+1]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==color)  num++;
            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  ;
            else num--;
        }
    //else num--;

    if(y+1&lt;=d)
        if(qz[x][y+1]==color)
        {
            num+=2;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==color)  num+=2;
            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;
            else num--;
        }
        else if(qz[x][y+1]==0)
        {
            num++;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==color)  num++;
            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  ;
            else num--;
        }
    //else num--;

    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)
        if(qz[x+1][y+1]==color)
        {
            num+=2;
            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==color)  num+=2;
            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  num++;
            else num--;
        }
        else  if(qz[x+1][y+1]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==color)  num++;
            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  ;
            else num--;
        }
    //else num--;

    if(x+1&lt;=r)
        if(qz[x+1][y]==color)
        {
            num+=2;
            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==color)  num+=2;
            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  num++;
            else num--;
        }
        else if(qz[x+1][y]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==color)  num++;
            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  ;
            else num--;
        }
    //else num--;
    return num;
}

///////////////////////five.c////////////////////////////////////////
char lose[4]= {27,12,35,47};
char lose2[6]= {41,42,27,12,35,47};
char win[4]= {27,34,35,47};
char str1[6]= {27,28,32,33,31,48};
char gamego[8]= {27,28,37,43,44,45,31,48};
extern unsigned int step;
void p(void)
{
    int i,j;
    for(i=0; i&lt;15; i++)
    {

        for(j=0; j&lt;15; j++)
            printf(&quot;%d&quot;,qz[j][i]);
    }
}


void init(void)
{
    drawline();
    old_x=7;
    old_y=7;
    setbit(7,7);
}
void drawline()
{
    int j;
    char str[2];
    char string[3];

    setfillstyle(1,14);

    setcolor(9);
    str[1]='\0';
    string[2]='\0';
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    SetTextColor(dc,0xff00);
    SetBkColor(dc,0);
    for(j=0; j&lt;15; j++)
    {
        line(X0+SIZE*(j),Y0,X0+SIZE*(j),Y0+SIZE*14);
        line(X0,Y0+SIZE*(j),X0+SIZE*14,Y0+SIZE*(j));
        if(j&gt;=9)
        {
            string[0]='1';
            string[1]='0'+j-9;
        }
        else
        {
            string[0]='1'+j;
            string[1]='\0';
        }

        outtextxy(X0-16,Y0+SIZE*j-7,string);
        str[0]='A'+j;
        outtextxy(X0+SIZE*j-3,Y0-15,str);
    }
}
char getkey()
{
    int key,ok=0;
    int  f,oldx,oldy;
    int can1,can2;
    while(1)
    {
        if(needclose)
        {
            printf(&quot;exit getkey&quot;);
            return 0;
        }
        Wait(1);
        if(bioskey(1)==1)
        {
            key=bioskey(0);
            if(key!=ENTER)
            {
                switch(key)
                {
                case LEFT:

                    printf(&quot;left0 kx:%d,ky:%d&quot;,kx,ky);
                    kx=(kx==0)?0:--kx;
                    printf(&quot;left1 kx:%d,ky:%d&quot;,kx,ky);
                    setbit(kx,ky);
                    break; /*left*/
                case RIGHT:
                    kx=(kx==14)?14:++kx;
                    setbit(kx,ky);
                    break; /*right*/
                case UP:
                    ky=(ky==0)?0:--ky;
                    setbit(kx,ky);
                    break; /*up*/
                case DOWN:
                    ky=(ky==14)?14:++ky;
                    setbit(kx,ky);;
                    break; /*down*/
                case ESC:
                    return 0x10;
                    break;
                case 'r':
                case 'R':
                    return 0x11;
                default:
                    break;
                }
            }
            else  ok=1;
        }
        if(oldx!=kx||oldy!=ky)
        {
            oldx=kx;
            oldy=ky;
        }
        /**/

        if((mx&gt;X0-SIZE/2)&amp;&amp;(my&gt;Y0-SIZE/2))
            if((mx&lt;X0+SIZE*14.5)&amp;&amp;(my&lt;Y0+SIZE*14.5))
            {
                printf(&quot;check mouse down,x:%d,y:%d&quot;,mx,my);
                //readmouse(&amp;f,&amp;mx,&amp;my);
                can1=(mx-X0)%SIZE;
                can2=(my-Y0)%SIZE;
                if(can1&lt;=(SIZE/2)) kx=(mx-X0)/SIZE;
                else kx=(mx-X0)/SIZE+1;
                if(can2&lt;=(SIZE/2)) ky=(my-Y0)/SIZE;
                else ky=(my-Y0)/SIZE+1;
                mx=0;
                my=0;
                f=1;
            }

        if(f==1)  ok=1;
        if(ok==1)
        {
            char result;
            result=ifgook(kx,ky,player,computer);
            player_x=kx;
            player_y=ky;
            if(qz[kx][ky]==0)
            {
                drawcircle(kx,ky,player);
                return result;
            }
            if(qz[kx][ky]==0&amp;&amp;result==-1) return result;
            ok=0;
        }
    }
}
void drawcircle(int x,int y,char color)
{
    int i;
    int l,r,d,t;
    qz[x][y]=color;
    color--;
    active[x][y][0]=0;
    active[x][y][1]=0;

    l=(x-2&gt;0)?x-2:0;
    t=(y-2&gt;0)?y-2:0;
    r=(x+2&gt;14)?14:x+2;
    d=(y+2&gt;14)?14:y+2;


    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)
        if(qz[x-1][y-1]==0)
        {
            active[x-1][y-1][color]=1;
            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  active[x-2][y-2][color]=1;
        }

    if(y-1&gt;=t)
        if(qz[x][y-1]==0)
        {
            active[x][y-1][color]=1;
            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  active[x][y-2][color]=1;
        }

    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)
        if(qz[x+1][y-1]==0)
        {
            active[x+1][y-1][color]=1;
            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  active[x+2][y-2][color]=1;
        }

    if(x-1&gt;=l)
        if(qz[x-1][y]==0)
        {
            active[x-1][y][color]=1;
            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  active[x-2][y][color]=1;
        }

    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)
        if(qz[x-1][y+1]==0)
        {
            active[x-1][y+1][color]=1;
            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  active[x-2][y+2][color]=1;
        }

    if(y+1&lt;=d)
        if(qz[x][y+1]==0)
        {
            active[x][y+1][color]=1;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  active[x][y+2][color]=1;
        }

    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)
        if(qz[x+1][y+1]==0)
        {
            active[x+1][y+1][color]=1;
            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  active[x+2][y+2][color]=1;
        }

    if(x+1&lt;=r)
        if(qz[x+1][y]==0)
        {
            active[x+1][y][color]=1;
            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  active[x+2][y][color]=1;
        }

    if(y+1&lt;=d)
        if(qz[x][y+1]==0)
        {
            active[x][y+1][color]=1;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  active[x][y+2][color]=1;
        }

    if(l&lt;left)  left=l;
    if(r&gt;right) right=r;
    if(t&lt;top)   top=t;
    if(d&gt;down)  down=d;

    drawcross(old_x,old_y);
    color=(color==0)?0:15;
    setcolor(0);
    setfillstyle(1,color);
     circle(X0+SIZE*x,Y0+SIZE*y,Radius);

    setcolor(color^0xff);


    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);

    HBRUSH brush;
    if(color==0)
    {
         setcolor(16);
        brush=CreateSolidBrush(0xffff);
    }
    else
    {
         setcolor(10);
        brush=CreateSolidBrush(0xffff00);
    }
     SelectObject(dc,brush);
    ellipse(X0+SIZE*x,Y0+SIZE*y,90+(1-color)*180,180+(1-color)*180,Radius-2,Radius-2);
    DeleteObject( brush);

    drawcross(x,y);

    old_x=x;
    old_y=y;
    setbit(x,y);

}
void drawcross(int x,int y)
{

    setcolor(2);
    line(X0+SIZE*x-6,Y0+SIZE*y,X0+SIZE*x+6,Y0+SIZE*y);
    line(X0+SIZE*x,Y0+SIZE*y-6,X0+SIZE*x,Y0+SIZE*y+6);

}

void setbit(int x,int y)
{
    int mx,my;
    mx=X0+SIZE*x;
    my=Y0+SIZE*y;
    printf(&quot;setbit,x:%d,y:%d&quot;,x,y);
    setmousecoord(mx,my);
}


unsigned condition[2][11]=
{
    {
        0x0054,
        0x0150,
        0x0144,
        0x0114,
        0x0555,
        0x0154,
        0x0151,
        0x0145,
        0x0115,
        0x0055,
        0x0155
    },
    {
        0x00a8,
        0x02a0,
        0x0288,
        0x0228,
        0x0aaa,
        0x02a8,
        0x02a2,
        0x028a,
        0x022a,
        0x00aa,
        0x02aa
    }
};

int compare(unsigned input,int len,char color);
void attrib(int x,int y,QCL *pl,char color1,char color2)
{
    int h,i,j,dx,dy,k1,k2,k,num,rang1,rang2;
    register int temp;
    pl-&gt;p[0]=-1;
    pl-&gt;p[1]=-1;
    pl-&gt;p[2]=-1;
    pl-&gt;p[3]=-1;
    pl-&gt;l[0]=0;
    pl-&gt;l[1]=0;
    pl-&gt;l[2]=0;
    pl-&gt;l[3]=0;

    for(i=0; i&lt;4; i++)
    {
        k1=1;
        k2=1;
        num=1;
        switch(i)
        {
        case 0:
            dx=0;
            dy=1;
            rang1=(y&gt;4)?4:y;
            rang2=(14-y&gt;4)?4:14-y;
            break;
        case 1:
            dx=1;
            dy=1;
            rang1=(x&lt;y)?x:y;
            rang1=(rang1&gt;4)?4:rang1;
            rang2=(x&gt;y)?x:y;
            rang2=(14-rang2&gt;4)?4:14-rang2;
            break;
        case 2:
            dx=1;
            dy=0;
            rang1=(x&gt;4)?4:x;
            rang2=(14-x&gt;4)?4:14-x;
            break;
        case 3:
            dx=1;
            dy=-1;
            rang1=(x&lt;14-y)?x:14-y;
            rang1=(rang1&gt;4)?4:rang1;
            rang2=(14-x&lt;y)?14-x:y;
            rang2=(rang2&gt;4)?4:rang2;
            break;
        }
        while(k1&lt;=rang1)
        {
            temp=qz[x-k1*dx][y-k1*dy];
            if(temp==0&amp;&amp;k1+1&lt;=rang1&amp;&amp;qz[x-(k1+1)*dx][y-(k1+1)*dy]==0)
            {
                k1+=2;
                break;
            }
            k1++;
            if(temp==color2) break;
            if(temp==color1) num++;
        }
        k1--;

        while(k2&lt;=rang2)
        {
            temp=qz[x+k2*dx][y+k2*dy];
            if(temp==0&amp;&amp;k2+1&lt;=rang2&amp;&amp;qz[x+(k2+1)*dx][y+(k2+1)*dy]==0)
            {
                k2+=2;
                break;
            }
            k2++;
            if(temp==color2) break;
            if(temp==color1) num++;
        }

        k=k1+k2;
        if(k&gt;4)
        {
            int m,n,back;
            unsigned swap=0,swap1;
            for(m=0; m&lt;5; m++)
                swap=swap|(qz[x-(k1-m)*dx][y-(k1-m)*dy]&lt;&lt;(m&lt;&lt;1));
            swap1=swap;
            switch(num)
            {
            case 3:
                if(k&gt;5)
                {
                    for(n=m; n&lt;k; n++)
                    {
                        swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);
                        back=compare(swap1,6,color1);
                        if(back&gt;=0)
                        {
                            pl-&gt;p[i]=back;
                            pl-&gt;l[i]=3;
                            pl-&gt;d[i]=k1-(n-m);
                            break;
                        }
                        swap1=swap1&gt;&gt;2;
                    }
                }
                if(pl-&gt;p[i]&gt;=0) continue;
                break;
            case 4:
                for(n=m-1; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);
                    back=compare(swap1,5,color1);
                    if(back&gt;=0)
                    {
                        pl-&gt;p[i]=back;
                        pl-&gt;l[i]=4;
                        pl-&gt;d[i]=k1-(n-m)-1;
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;
                break;
            case 5:
                for(n=m-1; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);
                    if(swap1==condition[color1-1][10])
                    {
                        pl-&gt;p[i]=10;
                        pl-&gt;l[i]=5;
                        pl-&gt;d[i]=k1-(n-m)-1;
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;
                break;
            case 7:
            case 8:
            case 9:
            case 6:
                for(n=m; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);
                    if(swap1==condition[color1-1][4])
                    {
                        pl-&gt;p[i]=4;
                        pl-&gt;l[i]=6;
                        pl-&gt;d[i]=k1-(n-m);
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;

                swap1=swap;
                for(n=m-1; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);
                    if(swap1==condition[color1-1][10])
                    {
                        pl-&gt;p[i]=10;
                        pl-&gt;l[i]=5;
                        pl-&gt;d[i]=k1-(n-m)-1;
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;

                for(n=m-1; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);
                    back=compare(swap1,5,color1);
                    if(back&gt;=0)
                    {
                        pl-&gt;p[i]=back;
                        pl-&gt;l[i]=4;
                        pl-&gt;d[i]=k1-(n-m)-1;
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;

                swap1=swap;
                for(n=m; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);
                    back=compare(swap1,6,color1);
                    if(back&gt;=0)
                    {
                        pl-&gt;p[i]=back;
                        pl-&gt;l[i]=3;
                        pl-&gt;d[i]=k1-(n-m);
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;
                break;
            default:
                break;
            }
        }
    }
}
int compare(unsigned input,int len,char color)
{
    int i;
    color--;
    switch(len)
    {
    case 5:
        for(i=5; i&lt;10; i++)
            if(input==condition[color][i]) return i;
        return -1;
    case 6:
        for(i=0; i&lt;4; i++)
            if(input==condition[color][i]) return i;
        return -1;
    default:
        printf(&quot;error len in compare\n&quot;);
        break;
    }
}
/////////////////////////////////////////////////////////////
void OnMouseDown(int id,int btn,int state,int x,int y)
{

    mx=x;
    my=y;
    printf(&quot;mouse down,x:%d,y:%d&quot;,mx,my);
}
void OnClose()
{
    printf(&quot;need close...&quot;);
    needclose=1;
    Wait(1);

}
void InitGraph()
{
    HideLeftTools();
    ClearVclControls();
    //ShowVclWin(200);
    HideVclWin(200);
    //p=GetGuiWin(0);
    pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;五子棋&quot;,&quot;Width&quot;,430,&quot;height&quot;,480,&quot;BorderIcons&quot;,&quot;[]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnKeyDown&quot;,OnKeyDown,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    //CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,40,&quot;enabled&quot;,1,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,60,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,400,&quot;height&quot;,400,&quot;OnMouseDown&quot;,OnMouseDown,0);
    //ms=CreateComponentEx(pfm,&quot;label&quot;,&quot;caption&quot;,&quot;X&quot;,&quot;left&quot;, 0,&quot;top&quot;, 0,&quot;width&quot;,20,&quot;height&quot;,20,0);

    SetProperty(pfm,&quot;visible&quot;,1);

    RECT rect= {0,0,640,480};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0x0000);
    SelectObject(dc,brush);
    FillRect(dc,&amp;rect,brush);
    DeleteObject(brush);
}
void main(void)
{
    int i;
    char who,END=0;
    int result,temp;
    InitGraph();


    while(!END)
    {
        SetProperty(pfm,&quot;caption&quot;,&quot;五子棋&quot;);
        if(needclose)
        {
            CloseForm(pfm);
            return;
        }
        who=1;

        reset();
        printf(&quot;game init...............&quot;);
        RECT rect= {0,0,640,480};
        dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
        HBRUSH brush=CreateSolidBrush(0x0000);
        SelectObject(dc,brush);
        FillRect(dc,&amp;rect,brush);
        DeleteObject(brush);

        game_init();
        Invalidate(img);
        if(MessageBox(GetFormHandle(pfm),&quot;你想先手吗？&quot;,&quot;开始下棋&quot;,4)==6 )
            player=2;
        else
            player=1;

        mx=0;
        my=0;
        computer=(player==1)?2:1;
        step=0;
        //drawcircle(7,7,1);

        SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到您走棋&quot;);

        temp=0;
        result=0;

        while(1)
        {
            set(who+1);

            if(who==player-1)
            {
                printf(&quot;player go&quot;);
                SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到您走棋&quot;);
                temp=player_go();
            }
            else
            {
                printf(&quot;computer go&quot;);
                SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到计算机走棋&quot;);
                result=computer_go(temp);
            }
            if(needclose)
            {
                printf(&quot;exit go&quot;);
                CloseForm(pfm);
                return;
            }
            printf(&quot;temp:%d,result:%d&quot;,temp,result);

            if(temp==1||result==-1)
            {
                set(0);

                MessageBox(GetFormHandle(pfm),&quot;未知!          &quot;,&quot;本局结束&quot;,0);
                if(needclose) return;

                mx=0;
                my=0;
                break;
            }
            if(temp==-1)
            {
                set(0);

                MessageBox(GetFormHandle(pfm),&quot;您赢了!          &quot;,&quot;本局结束&quot;,0);
                if(needclose) return;

                mx=0;
                my=0;
                break;
            }
            if(result==1)
            {
                printf(&quot;result==1&quot;);
                set(0);

                MessageBox(GetFormHandle(pfm),&quot;计算机赢了!         &quot;,&quot;本局结束&quot;,0);
                if(needclose) return;

                mx=0;
                my=0;
                break;
            }
            if(temp==0x10)
            {
                END=1;
                break;
            }
            if(temp==0x11) break;
            who^=1;
        }
    }


}















"/>
      <Command cmdname="五子棋-页面显示" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include &quot;stdio.h&quot;
#include &quot;conio.h&quot;
#define SIZE 24
#define X0 30
#define Y0 30
#define Radius 16
#define TRUE 1
#include &quot;stdio.h&quot;
#include &quot;dos.h&quot;
#include &quot;conio.h&quot;
#include &quot;stdlib.h&quot;

#define LEFT  37
#define RIGHT 39
#define DOWN  40  /*此键为加速键*/
#define UP    38  /*此键为变形键*/
#define ESC   27  /*此键为退出键*/
#define ENTER 13
#define DEPTH 14  //递归深度，棋力

int player_x,player_y;
int kx=7,ky=7;
int old_x,old_y;
char back[6]= {27,28,25,26,31,48};
int pfm;
void graph_init();
void drawline();
char getkey();
void drawcircle(int ,int ,char);
void drawcross(int,int);
void setbit(int,int);

int needclose=0;
int KeyDown=0;
HPEN pen=0;
int img;
HANDLE dc;
int ms;
int mx,my;
void setcolor(int cl)
{
    cl*=0xfffff;
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    if(pen!=0) DeleteObject(pen);
    pen=CreatePen(PS_SOLID,1,cl);
    SelectObject(dc,pen);
}
int bioskey(int flat)
{
    int tmp;
    if(flat==1)
    {
        if(KeyDown!=0)
            return 1;
        else
            return 0;
    }
    tmp=KeyDown;
    KeyDown=0;
    return tmp;

}
void putpixel(int x,int y,int cl)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    SetPixel(dc,x,y,cl*0xfffff);
}
void settextstyle(int a,int b,int c)
{

}
void outtextxy(int x,int y,char *s)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    TextOutA(dc,x,y,s,strlen(s));
}

void line(int x0,int y0,int x1,int y1)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    MoveToEx(dc,x0,y0,0);
    LineTo(dc,x1,y1);
}

void rectangle(int x0,int y0,int x1,int y1)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    MoveToEx(dc,x0,y0,0);
    LineTo(dc,x1,y0);
    LineTo(dc,x1,y1);
    LineTo(dc,x0,y1);
    LineTo(dc,x0,y0);
}
void circle(int x,int y,int r)
{
    rectangle(x-r/2,y-r/2,x+r/2,y+r/2);
}


void setmousecoord(int x,int y)
{
 
    RECT rect;
    x+=10;
    y+=40;
    rect.left=x-10;
    rect.top=y-10;
    rect.right=x+10;
    rect.bottom=y+10;

    InvalidateRect(GetFormHandle(pfm),&amp;rect,0);
    UpdateWindow(GetFormHandle(pfm));
    
}


void setfillstyle(int m1,int m2)
{

}

void ellipse(int x0,int y0,int start,int end,int r0,int r1)
{
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    Ellipse(dc,x0-r0/2,y0-r1/2,x0+r0/2,y0+r1/2);
}



void OnKeyDown(int id,int *key,int state)
{
    KeyDown=*key;
}



typedef struct struct1
{
    char p[4];
    char l[4];
    char d[4];
} QCL;


QCL pos[15][15][2];
char all[15][15][2];

char keepgo(int,int,int,char,char,int,QCL);
char goon(int,int,char,char,int);
char ifgook(int,int,char,char);
char computer_keep(int,int,int);
void exit_game();
unsigned int step=0;
unsigned keep[11]=
{
    0x0015,  //011100
    0x0062,  //001110
    0x0613,  //010110
    0x0614,  //011010
    0x0000,  //111111
    0x0001,  //01111
    0x0002,  //10111
    0x0003,  //11011
    0x0004,  //11101
    0x0005,  //11110
    0x0000   //11111
};
char judge;
/*****************************/
/*     return value          */
/*   -1    can not move      */
/*   0     nothing           */
/*   1     5,6  ready        */
/*   2     3    ready        */
/*   3     3,3  ready        */
/*   4     4    ready        */
/*   5     3,4  ready        */
/*   6     4,4  ready        */
/*****************************/
char computer_go(int) ;
char many(int ,int);
char power(int ,int ,char);
/*****************************/
/*     return value          */
/*   -1    lose the game     */
/*   0     nothing happen    */
/*   1     win the game      */
/*****************************/




void active_init(void);
void game_init(void);


unsigned int left,top,right,down;
unsigned char player,computer;
QCL Glist;
char active[15][15][2];
char qz[15][15];


#define LEN 252
#define COLOR 15
#define INTR 0X1C    /* The clock tick interrupt */


#define X 98
#define Y 10
char num[11][9]=
{
    {0x7e,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7e},//0
    {0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},//1
    {0x7e,0x01,0x01,0x01,0x7e,0x80,0x80,0x80,0x7e},//2
    {0x7e,0x01,0x01,0x01,0x7e,0x01,0x01,0x01,0x7e},//3
    {0x81,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x01},//4
    {0x7e,0x80,0x80,0x80,0x7e,0x01,0x01,0x01,0x7e},//5
    {0x7e,0x80,0x80,0x80,0x7e,0x81,0x81,0x81,0x7e},//6
    {0x7e,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},//7
    {0x7e,0x81,0x81,0x81,0x7e,0x81,0x81,0x81,0x7e},//8
    {0x7e,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x7e},//9
    {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff},
};


#define COLOR 10

void text(int,int,char,int,char *);

int count0=0,second0=0;/*computer's time*/
int count1=0,second1=0;/*player's time*/
int check;



void set(int che)
{
    if(che&gt;2) return;
    check=che;
}
void reset()
{
    count0=0;
    count1=0;
    second0=0;
    second1=0;
    check=0;

}


void init();
void attrib(int x,int y,QCL *pl,char color1,char color2);
void qz_init();
void game_init(void)
{
    init();
    active_init();
    qz_init();
    left=right=top=down=7;
}
void active_init(void)
{
    int i,j;
    for(i=0; i&lt;15; i++)
        for(j=0; j&lt;15; j++)
            active[i][j][0]=active[i][j][1]=0;
}
void qz_init(void)
{
    int i,j;
    for(i=0; i&lt;15; i++)
        for(j=0; j&lt;15; j++)
            qz[i][j]=0;
}

char computer_go(int len)
{
    register int i,j;
    char result,temp1,temp2,temp3;
    int max,large;
    char max_x,max_y;
    //ShowMessage(&quot;Computer go&quot;);
    step++;
    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
        {
            all[i][j][computer-1]=ifgook(i,j,computer,player);
            pos[i][j][computer-1]=Glist;
            all[i][j][player-1]=ifgook(i,j,player,computer);
            pos[i][j][player-1]=Glist;
        }

    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
            if(all[i][j][computer-1]==1)
            {
                drawcircle(i,j,computer);
                return 1;
            }

    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
            if(all[i][j][player-1]==1)
            {
                if(all[i][j][computer-1]!=-1)
                {
                    drawcircle(i,j,computer);
                    return 0;
                }
                else return -1;
            }

    large=-1;
    judge=4;
    if(len==3)
    {
        for(i=left; i&lt;=right; i++)
            for(j=top; j&lt;=down; j++)
            {
                if(active[i][j][computer-1]==1)
                {
                    switch(all[i][j][computer-1])
                    {
                    case -1:
                        break;
                    case 0:
                        break;
                    case 6:
                    case 1:
                        drawcircle(i,j,computer);
                        return 1;
                    case 2:
                    case 3:
                        break;
                    case 5:
                        qz[i][j]=computer;
                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);
                        qz[i][j]=0;
                        if(temp1==-1)
                        {
                            drawcircle(i,j,computer);
                            return 0;
                        }
                        break;
                    case 4:
                        temp3=power(i,j,computer);
                        if(temp3&lt;=large) break;
                        qz[i][j]=computer;
                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);
                        qz[i][j]=0;
                        if(temp1==-1)
                        {
                            large=temp3;
                            max_x=i;
                            max_y=j;
                        }
                        break;
                    default:
                        printf(&quot;error if computer_go().&quot;);
                    }
                }
            }
        if(large&gt;=0)
        {
            drawcircle(max_x,max_y,computer);
            return 0;
        }
        result=computer_keep(player_x,player_y,3);
        if(result==1) return 0;
    }
    else
    {
        judge=4;
        large=-1;
        for(i=left; i&lt;=right; i++)
            for(j=top; j&lt;=down; j++)
            {
                if(active[i][j][computer-1]==1)
                {
                    switch(all[i][j][computer-1])
                    {
                    case -1:
                        break;
                    case 0:
                        break;
                    case 6:
                    case 1:
                        drawcircle(i,j,computer);
                        return 1;
                    case 2:
                    case 3:
                        break;
                    case 5:
                        qz[i][j]=computer;
                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);
                        qz[i][j]=0;
                        if(temp1==-1)
                        {
                            drawcircle(i,j,computer);
                            return 0;
                        }
                        break;
                    case 4:
                        temp3=power(i,j,computer);
                        if(temp3&lt;=large) break;
                        qz[i][j]=computer;
                        temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);
                        qz[i][j]=0;
                        if(temp1==-1)
                        {
                            large=temp3;
                            max_x=i;
                            max_y=j;
                        }
                        break;
                    default:
                        printf(&quot;error if computer_go().&quot;);
                    }
                }
            }
        if(large&gt;=0)
        {
            drawcircle(max_x,max_y,computer);
            return 0;
        }
    }

    large=-1;
    judge=4;
    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
        {
            if(active[i][j][player-1]==1)
            {
                temp1=all[i][j][computer-1];
                switch(all[i][j][player-1])
                {
                case -1:
                    break;
                case 0:
                    break;
                case 6:
                case 1:
                    if(temp1!=-1)
                    {
                        drawcircle(i,j,computer);
                        return 0;
                    }
                    break;
                case 2:
                case 3:
                    break;
                case 5:
                    if(temp1!=-1)
                    {
                        qz[i][j]=player;
                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);
                        qz[i][j]=0;
                        if(temp2==-1)
                        {
                            drawcircle(i,j,computer);
                            return 0;
                        }
                    }
                    break;
                case 4:
                    if(temp1!=-1)
                    {
                        temp3=power(i,j,player);
                        if(temp3&lt;=large) break;
                        qz[i][j]=player;
                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);
                        qz[i][j]=0;
                        if(temp2==-1)
                        {
                            large=temp3;
                            max_x=i;
                            max_y=j;
                        }
                    }
                    break;
                default:
                    printf(&quot;error if player_go().&quot;);
                }
            }
        }
    if(large&gt;=0)
    {
        drawcircle(max_x,max_y,computer);
        return 0;
    }


    judge=3;
    large=-1;
    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
        {
            if(active[i][j][computer-1]==1)
            {
                switch(all[i][j][computer-1])
                {
                case -1:
                    break;
                case 0:
                    break;
                case 6:
                case 5:
                    drawcircle(i,j,computer);
                    return 0;
                case 1:
                    drawcircle(i,j,computer);
                    return 1;
                case 2:
                case 3:
                    temp3=power(i,j,computer);
                    if(temp3&lt;=large) break;
                    qz[i][j]=computer;
                    temp1=keepgo(i,j,3,player,computer,0,pos[i][j][computer-1]);
                    qz[i][j]=0;
                    if(temp1==-1)
                    {
                        large=temp3;
                        max_x=i;
                        max_y=j;
                    }
                    break;
                case 4:
                    temp3=power(i,j,computer);
                    if(temp3&lt;=large) break;
                    qz[i][j]=computer;
                    temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]);
                    qz[i][j]=0;
                    if(temp1==-1)
                    {
                        large=temp3;
                        max_x=i;
                        max_y=j;
                    }
                    break;
                default:
                    printf(&quot;error if player_go().&quot;);
                }
            }
        }
    if(large&gt;=0)
    {
        drawcircle(max_x,max_y,computer);
        return 0;
    }


    large=-1;
    judge=3;
    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
        {
            if(active[i][j][player-1]==1)
            {
                temp1=all[i][j][computer-1];
                switch(all[i][j][player-1])
                {
                case -1:
                    break;
                case 0:
                    break;
                case 6:
                case 5:
                case 1:
                    if(temp1!=-1)
                    {
                        drawcircle(i,j,computer);
                        return 0;
                    }
                    break;
                case 3:
                    if(temp1!=-1)
                    {
                        qz[i][j]=player;
                        temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]);
                        qz[i][j]=0;
                        if(temp2!=1)
                        {
                            drawcircle(i,j,computer);
                            return 0;
                        }
                    }
                    break;
                case 2:
                    if(temp1!=-1)
                    {
                        temp3=power(i,j,player);
                        if(temp3&lt;=large) break;
                        qz[i][j]=player;
                        temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]);
                        qz[i][j]=0;
                        if(temp2!=1)
                        {
                            large=temp3;
                            max_x=i;
                            max_y=j;
                        }
                    }
                    break;
                case 4:
                    if(temp1!=-1)
                    {
                        temp3=power(i,j,player);
                        if(temp3&lt;=large) break;
                        qz[i][j]=player;
                        temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]);
                        qz[i][j]=0;
                        if(temp2==-1)
                        {
                            large=temp3;
                            max_x=i;
                            max_y=j;
                        }
                    }
                    break;
                default:
                    printf(&quot;error if player_go().&quot;);
                }
            }
        }
    if(large&gt;=0)
    {
        drawcircle(max_x,max_y,computer);
        return 0;
    }

    max=-1;
    max_x=6;
    max_y=7;
    if(computer==2&amp;&amp;step&lt;=5)
    {
        for(i=left; i&lt;=right; i++)
            for(j=top; j&lt;=down; j++)
            {
                if(all[i][j][0]&gt;0&amp;&amp;all[i][j][1]&gt;0)
                {
                    temp1=power(i,j,1);
                    if(temp1&gt;max)
                    {
                        max=temp1;
                        max_x=i;
                        max_y=j;
                    }
                    else if(temp1==max&amp;&amp;power(max_x,max_y,computer)&lt;power(i,j,computer))
                    {
                        max_x=i;
                        max_y=j;
                    }
                }
            }
        if(max&gt;=0)
        {
            drawcircle(max_x,max_y,computer);
            return 0;
        }

        for(i=left; i&lt;=right; i++)
            for(j=top; j&lt;=down; j++)
            {
                if(all[i][j][computer-1]!=-1)
                {
                    temp1=power(i,j,1);
                    if(temp1&gt;max)
                    {
                        max=temp1;
                        max_x=i;
                        max_y=j;
                    }
                }
            }
        if(max&gt;=0)
        {
            drawcircle(max_x,max_y,computer);
            return 0;
        }
    }

    if(computer==1&amp;&amp;step&lt;=5)
    {
        for(i=left; i&lt;=right; i++)
            for(j=top; j&lt;=down; j++)
            {
                if(all[i][j][computer-1]!=-1&amp;&amp;active[i][j][computer-1]==1&amp;&amp;all[i][j][player-1]&gt;0)
                {
                    temp1=power(i,j,computer);
                    if(temp1&gt;max)
                    {
                        max=temp1;
                        max_x=i;
                        max_y=j;
                    }
                    else if(temp1==max&amp;&amp;power(max_x,max_y,player)&lt;power(i,j,player))
                    {
                        max_x=i;
                        max_y=j;
                    }
                }
            }
        if(max&gt;=0)
        {
            drawcircle(max_x,max_y,computer);
            return 0;
        }
    }

    for(i=left; i&lt;=right; i++)
        for(j=top; j&lt;=down; j++)
        {
            if(qz[i][j]==0&amp;&amp;all[i][j][computer-1]!=-1)
            {
                temp1=many(i,j);
                if(temp1&gt;max)
                {
                    max=temp1;
                    max_x=i;
                    max_y=j;
                }
            }
        }
    drawcircle(max_x,max_y,computer);
    return 0;
}

char player_go()
{
    char result;

    result=getkey();

    if(needclose)
    {
        printf(&quot;exit player go&quot;);
        return 0;
    }

    switch(result)
    {
    case 0:
        return 0;
    case -1:
        return -1;
    case 1:
        return 1;
    case 3:
    case 2:
        return 3;
    case 4:
    case 5:
    case 6:
        return 4;
    default:
        return result;
    }
}

char ifgook(int x,int y,char color1,char color2)
{
    register int i;
    int k3=0,k4=0;
    if(qz[x][y]!=0) return -1;
    qz[x][y]=color1;
    attrib(x,y,&amp;Glist,color1,color2);
    qz[x][y]=0;
    for(i=0; i&lt;4; i++)
    {
        if(Glist.p[i]&gt;=0&amp;&amp;Glist.p[i]&lt;=3)
            k3++;
        else if(Glist.p[i]==10)
            return 1;   /* there is five .*/

        else if(Glist.p[i]&lt;10&amp;&amp;Glist.p[i]&gt;=5)
            k4++;

        if(Glist.p[i]==4&amp;&amp;color1==1) return -1;
        if(Glist.p[i]==4&amp;&amp;color1==2) return 1;
    }
    if(k4&gt;1)
    {
        if(color1==1) return -1;
        else   return 6;
    }
    if(k3&gt;1&amp;&amp;color1==1) return -1;
    if(k3==1&amp;&amp;k4==1) return 5;  /* case  a 3 and a 4 */
    if(k3&gt;1) return 3;
    if(k4==1) return 4 ;        /* case a 4          */
    if(k3==1) return 2 ;        /* case a 3          */
    return 0;
}

char keepgo(int x,int y,int  len,char color1,char color2,int depth,QCL list)
{
    int dx,dy,x0,y0;
    int i,bx,by,mask,d,r0,r1,r2;
    char old_judge;
    if(depth&gt;=DEPTH) return -1;
    else   depth++;
    for(i=0; i&lt;4; i++)
    {
        switch(i)
        {
        case 0:
            dx=0;
            dy=1;
            break;
        case 1:
            dx=1;
            dy=1;
            break;
        case 2:
            dx=1;
            dy=0;
            break;
        case 3:
            dx=1;
            dy=-1;
            break;
        }
        if(list.l[i]==len)
        {
            int j;
            j=list.p[i];
            bx=x-dx*list.d[i];
            by=y-dy*list.d[i];
            mask=keep[j];
            while(mask!=0)
            {

                d=(mask&amp;0x000f)-1;
                x0=bx+d*dx;
                y0=by+d*dy;
                r1=ifgook(x0,y0,color1,color2);

                switch(r1)
                {
                case -1:
                    break;
                case 0:
                    if(judge==4||judge==5)
                    {
                        qz[x0][y0]=color1;
                        r2=goon(x,y,color2,color1,depth);
                        qz[x0][y0]=0;
                        if(r2==1) break;
                        else return 1;
                    }
                    if(judge==3)
                    {
                        judge=4;
                        qz[x0][y0]=color1;
                        r2=goon(x0,y0,color1,color2,depth);
                        judge=3;
                        if(r2==1) judge=4;
                        r2=goon(x,y,color2,color1,depth);
                        qz[x0][y0]=0;
                        judge=3;
                        if(r2==1) break;
                        else return 1;
                    }
                case 2:
                case 3:
                    old_judge=judge;
                    if(judge==3) judge=4;
                    qz[x0][y0]=color1;
                    r2=goon(x,y,color2,color1,depth);
                    qz[x0][y0]=0;
                    judge=old_judge;
                    if(r2==1) break;
                    else return 1;
                case 1:
                    return 1;
                case 4:
                case 5:
                case 6:
                    old_judge=judge;
                    if(judge==3||judge==4) judge=5;
                    qz[x0][y0]=color1;
                    r2=goon(x,y,color2,color1,depth);
                    qz[x0][y0]=0;
                    judge=old_judge;
                    if(r2==1) break;
                    else return 1;
                default:
                    printf(&quot;error in keepgo()&quot;);
                    break;
                }
                mask=mask&gt;&gt;4;
            }
        }
    }
    return -1;
}
char goon(int x,int y,char color1,char color2,int depth)
{
    int i,dx,dy,k1,k2,rang1,rang2,temp;
    int nx,ny;
    char r1,r2;
    for(i=0; i&lt;4; i++)
    {
        k1=1;
        k2=1;
        switch(i)
        {
        case 0:
            dx=0;
            dy=1;
            rang1=(y&gt;4)?4:y;
            rang2=(14-y&gt;4)?4:14-y;
            break;
        case 1:
            dx=1;
            dy=1;
            rang1=(x&lt;y)?x:y;
            rang1=(rang1&gt;4)?4:rang1;
            rang2=(x&gt;y)?x:y;
            rang2=(14-rang2&gt;4)?4:14-rang2;
            break;
        case 2:
            dx=1;
            dy=0;
            rang1=(x&gt;4)?4:x;
            rang2=(14-x&gt;4)?4:14-x;
            break;
        case 3:
            dx=1;
            dy=-1;
            rang1=(x&lt;14-y)?x:14-y;
            rang1=(rang1&gt;4)?4:rang1;
            rang2=(14-x&lt;y)?14-x:y;
            rang2=(rang2&gt;4)?4:rang2;
            break;
        }
        while(k1&lt;=rang1)
        {
            nx=x-k1*dx;
            ny=y-k1*dy;
            temp=qz[nx][ny];
            k1++;
            if(temp==0)
            {
                r1=ifgook(nx,ny,color1,color2);
                switch(r1)
                {
                case -1:
                case 0:
                    break;
                case 1:
                    return 1;
                case 2:
                case 3:
                    if(judge!=3) break;
                    qz[nx][ny]=color1;
                    r2=keepgo(nx,ny,3,color2,color1,depth,Glist);
                    qz[nx][ny]=0;
                    if(r2==-1) return 1;
                    break;
                case 6:
                case 5:
                case 4:
                    if(judge==5) break;
                    qz[nx][ny]=color1;
                    r2=keepgo(nx,ny,4,color2,color1,depth,Glist);
                    qz[nx][ny]=0;
                    if(r2==-1) return 1;
                    break;
                }
            }
            if(temp==color2) break;
        }

        while(k2&lt;=rang2)
        {
            nx=x+k2*dx;
            ny=y+k2*dy;
            temp=qz[nx][ny];
            k2++;
            if(temp==0)
            {
                r1=ifgook(nx,ny,color1,color2);
                switch(r1)
                {
                case -1:
                case 0:
                    break;
                case 1:
                    return 1;
                case 2:
                case 3:
                    if(judge!=3) break;
                    qz[nx][ny]=color1;
                    r2=keepgo(nx,ny,3,color2,color1,depth,Glist);
                    qz[nx][ny]=0;
                    if(r2==-1) return 1;
                    break;
                case 5:
                case 6:
                case 4:
                    if(judge==5) break;
                    qz[nx][ny]=color1;
                    r2=keepgo(nx,ny,4,color2,color1,depth,Glist);
                    qz[nx][ny]=0;
                    if(r2==-1) return 1;
                    break;
                }
            }
            if(temp==color2) break;
        }
    }
    return -1;
}
char computer_keep(int x,int y,int len)
{
    int dx,dy,x0,y0;
    int i,j,bx,by,mask,d,r1,r2;
    int temp;
    char old_judge;
    int max=-1,max_x,max_y;
    QCL list;
    attrib(x,y,&amp;list,player,computer);
    judge=3;
    for(i=0; i&lt;4; i++)
    {
        switch(i)
        {
        case 0:
            dx=0;
            dy=1;
            break;
        case 1:
            dx=1;
            dy=1;
            break;
        case 2:
            dx=1;
            dy=0;
            break;
        case 3:
            dx=1;
            dy=-1;
            break;
        }
        if(list.l[i]==len)
        {
            j=list.p[i];
            bx=x-dx*list.d[i];
            by=y-dy*list.d[i];
            mask=keep[j];
            while(mask!=0)
            {
                d=(mask&amp;0x000f)-1;
                x0=bx+d*dx;
                y0=by+d*dy;
                r1=ifgook(x0,y0,computer,player);
                switch(r1)
                {
                case -1:
                    break;
                case 0:
                    old_judge=judge;
                    judge=4;
                    qz[x0][y0]=computer;
                    r2=goon(x0,y0,computer,player,0);
                    if(r2==-1) judge=3;
                    r2=goon(x,y,player,computer,0);
                    qz[x0][y0]=0;
                    judge=old_judge;
                    if(r2==1) break;
                    r2=power(x0,y0,1);
                    if(max&lt;r2)
                    {
                        max=r2;
                        max_x=x0;
                        max_y=y0;
                    }
                    break;
                case 1:
                    drawcircle(x0,y0,computer);
                    return 1;
                case 2:
                case 3:
                    old_judge=judge;
                    judge=4;
                    qz[x0][y0]=computer;
                    r2=goon(x,y,player,computer,0);
                    qz[x0][y0]=0;
                    judge=old_judge;
                    if(r2==1) break;
                    drawcircle(x0,y0,computer);
                    return 1;
                case 4:
                case 5:
                case 6:
                    drawcircle(x0,y0,computer);
                    return 1;
                default:
                    printf(&quot;error in keepgo()&quot;);
                    break;
                }
                mask=mask&gt;&gt;4;
            }//end while
            if(max&gt;=0)
            {
                drawcircle(max_x,max_y,computer);
                return 1;
            }
            mask=keep[j];
            while(mask!=0)
            {
                d=(mask&amp;0x000f)-1;
                x0=bx+d*dx;
                y0=by+d*dy;
                r1=ifgook(x0,y0,computer,player);
                temp=power(x0,y0,player);
                if(temp&gt;max&amp;&amp;r1!=-1)
                {
                    max=temp;
                    max_x=x0;
                    max_y=y0;
                }
                mask=mask&gt;&gt;4;
            }
            if(max&gt;=0)
            {
                drawcircle(max_x,max_y,computer);
                return 1;
            }
        } //end if
    }  //end for
    return 0;
}
char many(int x,int y)
{
    int l,t,r,d;
    int num=0,id=0;
    l=(x-2&gt;0)?x-2:0;
    t=(y-2&gt;0)?y-2:0;
    r=(x+2&gt;14)?14:x+2;
    d=(y+2&gt;14)?14:y+2;

    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)
    {
        if(qz[x-1][y-1]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  ;
            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==computer)  num++;
            else  num--;
        }
        else if(qz[x-1][y-1]==computer)
        {
            id=1;
            num+=2;
            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  num++;
            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if(y-1&gt;=t)
    {
        if(qz[x][y-1]==0)
        {
            num++;
            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  ;
            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==computer)  num++;
            else  num--;
        }
        else  if(qz[x][y-1]==computer)
        {
            id=1;
            num+=2;
            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  num++;
            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)
    {
        if(qz[x+1][y-1]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  ;
            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==computer)  num++;
            else  num--;
        }
        else if(qz[x+1][y-1]==computer)
        {
            id=1;
            num+=2;
            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  num++;
            else  if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==computer)  num+=2;
            else  num--;

        }
        else num-=2;
    }
    else num-=2;

    if(x-1&gt;=l)
    {
        if(qz[x-1][y]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  ;
            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==computer)  num++;
            else  num--;
        }
        else  if(qz[x-1][y]==computer)
        {
            id=1;
            num+=2;
            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  num++;
            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)
    {
        if(qz[x-1][y+1]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  ;
            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==computer)  num++;
            else  num--;
        }
        else  if(qz[x-1][y+1]==computer)
        {
            id=1;
            num+=2;
            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  num++;
            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if(y+1&lt;=d)
    {
        if(qz[x][y+1]==0)
        {
            num++;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  ;
            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;
            else  num--;
        }
        else  if(qz[x][y+1]==computer)
        {
            id=1;
            num+=2;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;
            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num+=2;
            else  num--;

        }
        else num-=2;
    }
    else num-=2;

    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)
    {
        if(qz[x+1][y+1]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  ;
            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==computer)  num++;
            else  num--;
        }
        else  if(qz[x+1][y+1]==computer)
        {
            id=1;
            num+=2;
            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  num++;
            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if(x+1&lt;=r)
    {
        if(qz[x+1][y]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  ;
            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==computer)  num++;
            else  num--;
        }
        else   if(qz[x+1][y]==computer)
        {
            id=1;
            num+=2;
            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  num++;
            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==computer)  num+=2;
            else  num--;
        }
        else num-=2;
    }
    else num-=2;

    if (id==1) return num;
    else return -1;
}
char power(int x,int y,char color)
{
    int l,t,r,d,num;
    l=(x-2&gt;0)?x-2:0;
    t=(y-2&gt;0)?y-2:0;
    r=(x+2&gt;14)?14:x+2;
    d=(y+2&gt;14)?14:y+2;

    num=0;
    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)
        if(qz[x-1][y-1]==color)
        {
            num+=2;
            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==color)  num+=2;
            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  num++;
            else  num--;
        }
        else if(qz[x-1][y-1]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==color)  num++;
            else if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  ;
            else num--;
        }
    //else num--;

    if(y-1&gt;=t)
        if(qz[x][y-1]==color)
        {
            num+=2;
            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==color)  num+=2;
            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  num++;
            else num--;
        }
        else if(qz[x][y-1]==0)
        {
            num++;
            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==color)  num++;
            else if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0) ;
            else num--;
        }
    //else num--;

    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)
        if(qz[x+1][y-1]==color)
        {
            num+=2;
            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==color)  num+=2;
            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  num++;
            else num--;
        }
        else if(qz[x+1][y-1]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==color)  num++;
            else if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  ;
            else num--;
        }
    //else num--;

    if(x-1&gt;=l)
        if(qz[x-1][y]==color)
        {
            num+=2;
            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==color)  num+=2;
            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  num++;
            else num--;
        }
        else if(qz[x-1][y]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==color)  num++;
            else if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0) ;
            else  num--;
        }
    //else num--;

    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)
        if(qz[x-1][y+1]==color)
        {
            num+=2;
            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==color)  num+=2;
            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  num++;
            else num--;
        }
        else if(qz[x-1][y+1]==0)
        {
            num++;
            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==color)  num++;
            else if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  ;
            else num--;
        }
    //else num--;

    if(y+1&lt;=d)
        if(qz[x][y+1]==color)
        {
            num+=2;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==color)  num+=2;
            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  num++;
            else num--;
        }
        else if(qz[x][y+1]==0)
        {
            num++;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==color)  num++;
            else if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  ;
            else num--;
        }
    //else num--;

    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)
        if(qz[x+1][y+1]==color)
        {
            num+=2;
            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==color)  num+=2;
            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  num++;
            else num--;
        }
        else  if(qz[x+1][y+1]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==color)  num++;
            else if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  ;
            else num--;
        }
    //else num--;

    if(x+1&lt;=r)
        if(qz[x+1][y]==color)
        {
            num+=2;
            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==color)  num+=2;
            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  num++;
            else num--;
        }
        else if(qz[x+1][y]==0)
        {
            num++;
            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==color)  num++;
            else if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  ;
            else num--;
        }
    //else num--;
    return num;
}

///////////////////////five.c////////////////////////////////////////
char lose[4]= {27,12,35,47};
char lose2[6]= {41,42,27,12,35,47};
char win[4]= {27,34,35,47};
char str1[6]= {27,28,32,33,31,48};
char gamego[8]= {27,28,37,43,44,45,31,48};
extern unsigned int step;
void p(void)
{
    int i,j;
    for(i=0; i&lt;15; i++)
    {

        for(j=0; j&lt;15; j++)
            printf(&quot;%d&quot;,qz[j][i]);
    }
}


void init(void)
{
    drawline();
    old_x=7;
    old_y=7;
    setbit(7,7);
}
void drawline()
{
    int j;
    char str[2];
    char string[3];

    setfillstyle(1,14);

    setcolor(9);
    str[1]='\0';
    string[2]='\0';
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    SetTextColor(dc,0xff00);
    SetBkColor(dc,0);
    for(j=0; j&lt;15; j++)
    {
        line(X0+SIZE*(j),Y0,X0+SIZE*(j),Y0+SIZE*14);
        line(X0,Y0+SIZE*(j),X0+SIZE*14,Y0+SIZE*(j));
        if(j&gt;=9)
        {
            string[0]='1';
            string[1]='0'+j-9;
        }
        else
        {
            string[0]='1'+j;
            string[1]='\0';
        }

        outtextxy(X0-16,Y0+SIZE*j-7,string);
        str[0]='A'+j;
        outtextxy(X0+SIZE*j-3,Y0-15,str);
    }
}
char getkey()
{
    int key,ok=0;
    int  f,oldx,oldy;
    int can1,can2;
    while(1)
    {
        if(needclose)
        {
            printf(&quot;exit getkey&quot;);
            return 0;
        }
        Wait(1);
        if(bioskey(1)==1)
        {
            key=bioskey(0);
            if(key!=ENTER)
            {
                switch(key)
                {
                case LEFT:

                    printf(&quot;left0 kx:%d,ky:%d&quot;,kx,ky);
                    kx=(kx==0)?0:--kx;
                    printf(&quot;left1 kx:%d,ky:%d&quot;,kx,ky);
                    setbit(kx,ky);
                    break; /*left*/
                case RIGHT:
                    kx=(kx==14)?14:++kx;
                    setbit(kx,ky);
                    break; /*right*/
                case UP:
                    ky=(ky==0)?0:--ky;
                    setbit(kx,ky);
                    break; /*up*/
                case DOWN:
                    ky=(ky==14)?14:++ky;
                    setbit(kx,ky);;
                    break; /*down*/
                case ESC:
                    return 0x10;
                    break;
                case 'r':
                case 'R':
                    return 0x11;
                default:
                    break;
                }
            }
            else  ok=1;
        }
        if(oldx!=kx||oldy!=ky)
        {
            oldx=kx;
            oldy=ky;
        }
        /**/

        if((mx&gt;X0-SIZE/2)&amp;&amp;(my&gt;Y0-SIZE/2))
            if((mx&lt;X0+SIZE*14.5)&amp;&amp;(my&lt;Y0+SIZE*14.5))
            {
                printf(&quot;check mouse down,x:%d,y:%d&quot;,mx,my);
                //readmouse(&amp;f,&amp;mx,&amp;my);
                can1=(mx-X0)%SIZE;
                can2=(my-Y0)%SIZE;
                if(can1&lt;=(SIZE/2)) kx=(mx-X0)/SIZE;
                else kx=(mx-X0)/SIZE+1;
                if(can2&lt;=(SIZE/2)) ky=(my-Y0)/SIZE;
                else ky=(my-Y0)/SIZE+1;
                mx=0;
                my=0;
                f=1;
            }

        if(f==1)  ok=1;
        if(ok==1)
        {
            char result;
            result=ifgook(kx,ky,player,computer);
            player_x=kx;
            player_y=ky;
            if(qz[kx][ky]==0)
            {
                drawcircle(kx,ky,player);
                return result;
            }
            if(qz[kx][ky]==0&amp;&amp;result==-1) return result;
            ok=0;
        }
    }
}
void drawcircle(int x,int y,char color)
{
    int i;
    int l,r,d,t;
    qz[x][y]=color;
    color--;
    active[x][y][0]=0;
    active[x][y][1]=0;

    l=(x-2&gt;0)?x-2:0;
    t=(y-2&gt;0)?y-2:0;
    r=(x+2&gt;14)?14:x+2;
    d=(y+2&gt;14)?14:y+2;


    if(x-1&gt;=l&amp;&amp;y-1&gt;=t)
        if(qz[x-1][y-1]==0)
        {
            active[x-1][y-1][color]=1;
            if(x-2&gt;=l&amp;&amp;y-2&gt;=t&amp;&amp;qz[x-2][y-2]==0)  active[x-2][y-2][color]=1;
        }

    if(y-1&gt;=t)
        if(qz[x][y-1]==0)
        {
            active[x][y-1][color]=1;
            if(y-2&gt;=t&amp;&amp;qz[x][y-2]==0)  active[x][y-2][color]=1;
        }

    if(x+1&lt;=r&amp;&amp;y-1&gt;=t)
        if(qz[x+1][y-1]==0)
        {
            active[x+1][y-1][color]=1;
            if(x+2&lt;=r&amp;&amp;y-2&gt;=t&amp;&amp;qz[x+2][y-2]==0)  active[x+2][y-2][color]=1;
        }

    if(x-1&gt;=l)
        if(qz[x-1][y]==0)
        {
            active[x-1][y][color]=1;
            if(x-2&gt;=l&amp;&amp;qz[x-2][y]==0)  active[x-2][y][color]=1;
        }

    if(x-1&gt;=l&amp;&amp;y+1&lt;=d)
        if(qz[x-1][y+1]==0)
        {
            active[x-1][y+1][color]=1;
            if(x-2&gt;=l&amp;&amp;y+2&lt;=d&amp;&amp;qz[x-2][y+2]==0)  active[x-2][y+2][color]=1;
        }

    if(y+1&lt;=d)
        if(qz[x][y+1]==0)
        {
            active[x][y+1][color]=1;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  active[x][y+2][color]=1;
        }

    if(x+1&lt;=r&amp;&amp;y+1&lt;=d)
        if(qz[x+1][y+1]==0)
        {
            active[x+1][y+1][color]=1;
            if(x+2&lt;=r&amp;&amp;y+2&lt;=d&amp;&amp;qz[x+2][y+2]==0)  active[x+2][y+2][color]=1;
        }

    if(x+1&lt;=r)
        if(qz[x+1][y]==0)
        {
            active[x+1][y][color]=1;
            if(x+2&lt;=r&amp;&amp;qz[x+2][y]==0)  active[x+2][y][color]=1;
        }

    if(y+1&lt;=d)
        if(qz[x][y+1]==0)
        {
            active[x][y+1][color]=1;
            if(y+2&lt;=d&amp;&amp;qz[x][y+2]==0)  active[x][y+2][color]=1;
        }

    if(l&lt;left)  left=l;
    if(r&gt;right) right=r;
    if(t&lt;top)   top=t;
    if(d&gt;down)  down=d;

    drawcross(old_x,old_y);
    color=(color==0)?0:15;
    setcolor(0);
    setfillstyle(1,color);
    circle(X0+SIZE*x,Y0+SIZE*y,Radius);

    setcolor(color^0xff);


    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);

    HBRUSH brush;
    if(color==0)
    {
        setcolor(16);
        brush=CreateSolidBrush(0xffff);
    }
    else
    {
        setcolor(10);
        brush=CreateSolidBrush(0xffff00);
    }
    SelectObject(dc,brush);
    ellipse(X0+SIZE*x,Y0+SIZE*y,90+(1-color)*180,180+(1-color)*180,Radius-2,Radius-2);
    DeleteObject( brush);

    drawcross(x,y);

    old_x=x;
    old_y=y;
    setbit(x,y);

}
void drawcross(int x,int y)
{

    setcolor(2);
    line(X0+SIZE*x-6,Y0+SIZE*y,X0+SIZE*x+6,Y0+SIZE*y);
    line(X0+SIZE*x,Y0+SIZE*y-6,X0+SIZE*x,Y0+SIZE*y+6);

}

void setbit(int x,int y)
{
    int mx,my;
    mx=X0+SIZE*x;
    my=Y0+SIZE*y;
    printf(&quot;setbit,x:%d,y:%d&quot;,x,y);
    setmousecoord(mx,my);
}


unsigned condition[2][11]=
{
    {
        0x0054,
        0x0150,
        0x0144,
        0x0114,
        0x0555,
        0x0154,
        0x0151,
        0x0145,
        0x0115,
        0x0055,
        0x0155
    },
    {
        0x00a8,
        0x02a0,
        0x0288,
        0x0228,
        0x0aaa,
        0x02a8,
        0x02a2,
        0x028a,
        0x022a,
        0x00aa,
        0x02aa
    }
};

int compare(unsigned input,int len,char color);
void attrib(int x,int y,QCL *pl,char color1,char color2)
{
    int h,i,j,dx,dy,k1,k2,k,num,rang1,rang2;
    register int temp;
    pl-&gt;p[0]=-1;
    pl-&gt;p[1]=-1;
    pl-&gt;p[2]=-1;
    pl-&gt;p[3]=-1;
    pl-&gt;l[0]=0;
    pl-&gt;l[1]=0;
    pl-&gt;l[2]=0;
    pl-&gt;l[3]=0;

    for(i=0; i&lt;4; i++)
    {
        k1=1;
        k2=1;
        num=1;
        switch(i)
        {
        case 0:
            dx=0;
            dy=1;
            rang1=(y&gt;4)?4:y;
            rang2=(14-y&gt;4)?4:14-y;
            break;
        case 1:
            dx=1;
            dy=1;
            rang1=(x&lt;y)?x:y;
            rang1=(rang1&gt;4)?4:rang1;
            rang2=(x&gt;y)?x:y;
            rang2=(14-rang2&gt;4)?4:14-rang2;
            break;
        case 2:
            dx=1;
            dy=0;
            rang1=(x&gt;4)?4:x;
            rang2=(14-x&gt;4)?4:14-x;
            break;
        case 3:
            dx=1;
            dy=-1;
            rang1=(x&lt;14-y)?x:14-y;
            rang1=(rang1&gt;4)?4:rang1;
            rang2=(14-x&lt;y)?14-x:y;
            rang2=(rang2&gt;4)?4:rang2;
            break;
        }
        while(k1&lt;=rang1)
        {
            temp=qz[x-k1*dx][y-k1*dy];
            if(temp==0&amp;&amp;k1+1&lt;=rang1&amp;&amp;qz[x-(k1+1)*dx][y-(k1+1)*dy]==0)
            {
                k1+=2;
                break;
            }
            k1++;
            if(temp==color2) break;
            if(temp==color1) num++;
        }
        k1--;

        while(k2&lt;=rang2)
        {
            temp=qz[x+k2*dx][y+k2*dy];
            if(temp==0&amp;&amp;k2+1&lt;=rang2&amp;&amp;qz[x+(k2+1)*dx][y+(k2+1)*dy]==0)
            {
                k2+=2;
                break;
            }
            k2++;
            if(temp==color2) break;
            if(temp==color1) num++;
        }

        k=k1+k2;
        if(k&gt;4)
        {
            int m,n,back;
            unsigned swap=0,swap1;
            for(m=0; m&lt;5; m++)
                swap=swap|(qz[x-(k1-m)*dx][y-(k1-m)*dy]&lt;&lt;(m&lt;&lt;1));
            swap1=swap;
            switch(num)
            {
            case 3:
                if(k&gt;5)
                {
                    for(n=m; n&lt;k; n++)
                    {
                        swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);
                        back=compare(swap1,6,color1);
                        if(back&gt;=0)
                        {
                            pl-&gt;p[i]=back;
                            pl-&gt;l[i]=3;
                            pl-&gt;d[i]=k1-(n-m);
                            break;
                        }
                        swap1=swap1&gt;&gt;2;
                    }
                }
                if(pl-&gt;p[i]&gt;=0) continue;
                break;
            case 4:
                for(n=m-1; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);
                    back=compare(swap1,5,color1);
                    if(back&gt;=0)
                    {
                        pl-&gt;p[i]=back;
                        pl-&gt;l[i]=4;
                        pl-&gt;d[i]=k1-(n-m)-1;
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;
                break;
            case 5:
                for(n=m-1; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);
                    if(swap1==condition[color1-1][10])
                    {
                        pl-&gt;p[i]=10;
                        pl-&gt;l[i]=5;
                        pl-&gt;d[i]=k1-(n-m)-1;
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;
                break;
            case 7:
            case 8:
            case 9:
            case 6:
                for(n=m; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);
                    if(swap1==condition[color1-1][4])
                    {
                        pl-&gt;p[i]=4;
                        pl-&gt;l[i]=6;
                        pl-&gt;d[i]=k1-(n-m);
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;

                swap1=swap;
                for(n=m-1; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);
                    if(swap1==condition[color1-1][10])
                    {
                        pl-&gt;p[i]=10;
                        pl-&gt;l[i]=5;
                        pl-&gt;d[i]=k1-(n-m)-1;
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;

                for(n=m-1; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;8);
                    back=compare(swap1,5,color1);
                    if(back&gt;=0)
                    {
                        pl-&gt;p[i]=back;
                        pl-&gt;l[i]=4;
                        pl-&gt;d[i]=k1-(n-m)-1;
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;

                swap1=swap;
                for(n=m; n&lt;k; n++)
                {
                    swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]&lt;&lt;10);
                    back=compare(swap1,6,color1);
                    if(back&gt;=0)
                    {
                        pl-&gt;p[i]=back;
                        pl-&gt;l[i]=3;
                        pl-&gt;d[i]=k1-(n-m);
                        break;
                    }
                    swap1=swap1&gt;&gt;2;
                }
                if(pl-&gt;p[i]&gt;=0) continue;
                break;
            default:
                break;
            }
        }
    }
}
int compare(unsigned input,int len,char color)
{
    int i;
    color--;
    switch(len)
    {
    case 5:
        for(i=5; i&lt;10; i++)
            if(input==condition[color][i]) return i;
        return -1;
    case 6:
        for(i=0; i&lt;4; i++)
            if(input==condition[color][i]) return i;
        return -1;
    default:
        printf(&quot;error len in compare\n&quot;);
        break;
    }
}
/////////////////////////////////////////////////////////////
void OnMouseDown(int id,int btn,int state,int x,int y)
{

    mx=x;
    my=y;
    printf(&quot;mouse down,x:%d,y:%d&quot;,mx,my);
}
void OnClose()
{
    printf(&quot;need close...&quot;);
    needclose=1;
    Wait(1);
    HideVclWin();
    
    CloseVclWin();

}
void InitGraph()
{
    HideLeftTools();
    ClearVclControls();
    ShowVclWin(180);
    //HideVclWin(200);
    pfm=GetGuiWin(1);
    //pfm=CreateComponentEx(0,&quot;form&quot;,&quot;caption&quot;,&quot;五子棋&quot;,&quot;Width&quot;,430,&quot;height&quot;,480,&quot;BorderIcons&quot;,&quot;[]&quot;,&quot;position&quot;,&quot;poMainFormCenter&quot;,&quot;formstyle&quot;,&quot;fsstayontop&quot;,&quot;OnKeyDown&quot;,OnKeyDown,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize]
    CreateComponentEx(pfm,&quot;SpeedButton&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;,10,&quot;top&quot;,5,&quot;width&quot;,160,&quot;height&quot;,20,&quot;OnClick&quot;,OnClose,0);
    img=CreateComponentEx(pfm,&quot;Image&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,400,&quot;height&quot;,380,&quot;OnMouseDown&quot;,OnMouseDown,0);
    SetProperty(pfm,&quot;visible&quot;,1);
    RECT rect= {0,0,640,480};
    dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
    HBRUSH brush=CreateSolidBrush(0x0000);
    SelectObject(dc,brush);
    FillRect(dc,&amp;rect,brush);
    DeleteObject(brush);
}
void main(void)
{
    int i;
    char who,END=0;
    int result,temp;
    InitGraph();


    while(!END)
    {
        SetProperty(pfm,&quot;caption&quot;,&quot;五子棋&quot;);
        if(needclose)
        {
            //ClearVclControls();;
            return;
        }
        who=1;

        reset();
        printf(&quot;game init...............&quot;);
        RECT rect= {0,0,640,480};
        dc=(HANDLE)GetProperty(img,&quot;dc&quot;,0,0,0);
        HBRUSH brush=CreateSolidBrush(0x0000);
        SelectObject(dc,brush);
        FillRect(dc,&amp;rect,brush);
        DeleteObject(brush);

        game_init();
        Invalidate(img);
        if(MessageBox(GetFormHandle(pfm),&quot;你想先手吗？&quot;,&quot;开始下棋&quot;,4)==6 )
            player=2;
        else
            player=1;

        mx=0;
        my=0;
        computer=(player==1)?2:1;
        step=0;
        //drawcircle(7,7,1);

        SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到您走棋&quot;);

        temp=0;
        result=0;

        while(1)
        {
            set(who+1);

            if(who==player-1)
            {
                printf(&quot;player go&quot;);
                SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到您走棋&quot;);
                temp=player_go();
            }
            else
            {
                printf(&quot;computer go&quot;);
                SetProperty(pfm,&quot;caption&quot;,&quot;五子棋-轮到计算机走棋&quot;);
                result=computer_go(temp);
            }
            if(needclose)
            {
                printf(&quot;exit go&quot;);

                return;
            }
            printf(&quot;temp:%d,result:%d&quot;,temp,result);

            if(temp==1||result==-1)
            {
                set(0);

                MessageBox(GetFormHandle(pfm),&quot;未知!          &quot;,&quot;本局结束&quot;,0);
                if(needclose) return;

                mx=0;
                my=0;
                break;
            }
            if(temp==-1)
            {
                set(0);

                MessageBox(GetFormHandle(pfm),&quot;您赢了!          &quot;,&quot;本局结束&quot;,0);
                if(needclose) return;

                mx=0;
                my=0;
                break;
            }
            if(result==1)
            {
                printf(&quot;result==1&quot;);
                set(0);

                MessageBox(GetFormHandle(pfm),&quot;计算机赢了!         &quot;,&quot;本局结束&quot;,0);
                if(needclose) return;

                mx=0;
                my=0;
                break;
            }
            if(temp==0x10)
            {
                END=1;
                break;
            }
            if(temp==0x11) break;
            who^=1;
        }
    }


}















"/>
    </Command>
    <Command cmdname="协议组态工具unuseful" cmdType="P" cmd="[P]new command">
      <Command cmdname="数据分析/构造器" cmdType="S" cmd="[S]数据分析器数据">
        <Command cmdname="起始符1-0x55" cmdType="S" cmd="[S]0x55">
          <Command cmdname="数据名称" cmdType="S" cmd="[S]Start_0"/>
          <Command cmdname="存在方式" cmdType="S" cmd="[S]必选\可选\程序"/>
          <Command cmdname="是否转义" cmdType="S" cmd="[S]是/否"/>
          <Command cmdname="转义字符" cmdType="S" cmd="[S]/"/>
          <Command cmdname="全局合法性" cmdType="S" cmd="[S]是/否">
            <Command cmdname="长度合法" cmdType="S" cmd="[S]是/否"/>
            <Command cmdname="内容合法" cmdType="S" cmd="[S]是/否"/>
          </Command>
          <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择">
            <Command cmdname="长度方式" cmdType="S" cmd="[S]固定\程序\止于结束符"/>
            <Command cmdname="长度数值" cmdType="S" cmd="[S]1"/>
            <Command cmdname="动态长度" cmdType="S" cmd="[S]GetLength(&quot;Start_0&quot;)"/>
            <Command cmdname="结束符" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="是否包含结束符" cmdType="S" cmd="[S]是/否"/>
          </Command>
          <Command cmdname="内容" cmdType="S" cmd="[S]0x55">
            <Command cmdname="内容方式" cmdType="S" cmd="[S]固定/程序/列表"/>
            <Command cmdname="固定内容" cmdType="S" cmd="[S]0x55"/>
            <Command cmdname="程序判断" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="列表匹配" cmdType="S" cmd="[S]new command">
              <Command cmdname="匹配表格名称" cmdType="S" cmd="[S]new command"/>
              <Command cmdname="匹配方式" cmdType="S" cmd="[S]new command">
                <Command cmdname="(" cmdType="S" cmd="[S]左括号"/>
                <Command cmdname="主键1" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="或" cmdType="S" cmd="[S]或关系"/>
                <Command cmdname="主键2" cmdType="S" cmd="[S]new command"/>
                <Command cmdname=")" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="主键3" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="程序匹配" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="程序匹配" cmdType="S" cmd="[S]new command"/>
              </Command>
            </Command>
          </Command>
          <Command cmdname="扩展项目" cmdType="S" cmd="[S]new command">
            <Command cmdname="数据扩展项0" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="数据扩展项1" cmdType="S" cmd="[S]new command"/>
          </Command>
          <Command cmdname="生成方式" cmdType="S" cmd="[S]new command">
            <Command cmdname="自动加1" cmdType="S" cmd="[S]1 command"/>
            <Command cmdname="自动减1" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="数据范围" cmdType="S" cmd="[S]1,2,3-9"/>
            <Command cmdname="随机数" cmdType="S" cmd="[S]new command数">
              <Command cmdname="合法性判断" cmdType="S" cmd="[S]new command"/>
            </Command>
            <Command cmdname="程序生成" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="表格选取" cmdType="S" cmd="[S]一new command">
              <Command cmdname="选取方式" cmdType="S" cmd="[S]new command"/>
            </Command>
          </Command>
        </Command>
        <Command cmdname="起始符2-0xAA" cmdType="S" cmd="[S]new command">
          <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择"/>
          <Command cmdname="内容" cmdType="S" cmd="[S]0xAA"/>
        </Command>
        <Command cmdname="长度" cmdType="S" cmd="[S]new command">
          <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择"/>
          <Command cmdname="全局合法性" cmdType="S" cmd="[S]new command"/>
        </Command>
        <Command cmdname="长度(反)" cmdType="S" cmd="[S]new command">
          <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择"/>
          <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command"/>
        </Command>
        <Command cmdname="流水号" cmdType="S" cmd="[S]new command">
          <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择"/>
          <Command cmdname="内容" cmdType="S" cmd="[S]0x55"/>
        </Command>
        <Command cmdname="数据" cmdType="S" cmd="[S]new command">
          <Command cmdname="命令1" cmdType="S" cmd="[S]new command">
            <Command cmdname="主命令字" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="子命令字" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="命令参数" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="数据项属性" cmdType="S" cmd="[S]new command">
              <Command cmdname="重复匹配" cmdType="S" cmd="[S]new command"/>
              <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command"/>
            </Command>
          </Command>
          <Command cmdname="命令2" cmdType="S" cmd="[S]new command">
            <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="命令字" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="命令参数" cmdType="S" cmd="[S]new command"/>
            <Command cmdname="循环匹配" cmdType="S" cmd="[S]new command"/>
          </Command>
        </Command>
        <Command cmdname="校验" cmdType="S" cmd="[S]new command">
          <Command cmdname="长度" cmdType="S" cmd="[S]new command"/>
          <Command cmdname="内容" cmdType="S" cmd="[S]new command"/>
          <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command"/>
        </Command>
        <Command cmdname="结束符" cmdType="S" cmd="[S]0x03">
          <Command cmdname="长度" cmdType="S" cmd="[S]new command"/>
          <Command cmdname="内容" cmdType="S" cmd="[S]0x55"/>
          <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command"/>
        </Command>
        <Command cmdname="匹配表格" cmdType="S" cmd="[S]new command">
          <Command cmdname="表格一" cmdType="S" cmd="[S]new command">
            <Command cmdname="表格结构" cmdType="S" cmd="[S]new command">
              <Command cmdname="一级键值" cmdType="S" cmd="[S]new command">
                <Command cmdname="长度" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="类型" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="备注" cmdType="S" cmd="[S]new command"/>
              </Command>
              <Command cmdname="键值内容" cmdType="S" cmd="[S]new command">
                <Command cmdname="名称" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="内容" cmdType="S" cmd="[S]new command"/>
                <Command cmdname="键值4" cmdType="S" cmd="[S]new command"/>
              </Command>
            </Command>
            <Command cmdname="表格内容" cmdType="S" cmd="[S]new command"/>
          </Command>
        </Command>
        <Command cmdname="全局变量" cmdType="S" cmd="[S]new command"/>
        <Command cmdname="全局函数" cmdType="S" cmd="[S]new command"/>
      </Command>
      <Command cmdname="数据构造器" cmdType="S" cmd="[S]new command">
        <Command cmdname="构造器1" cmdType="S" cmd="[S]new command"/>
        <Command cmdname="构造器2" cmdType="S" cmd="[S]new command"/>
      </Command>
      <Command cmdname="数据解析器" cmdType="S" cmd="[S]new command">
        <Command cmdname="解析器1" cmdType="S" cmd="[S]new command"/>
        <Command cmdname="解析器2" cmdType="S" cmd="[S]new command"/>
      </Command>
      <Command cmdname="流程构造器" cmdType="S" cmd="[S]new command">
        <Command cmdname="主\从站方式" cmdType="S" cmd="[S]new command"/>
      </Command>
    </Command>
  </Command>
  <Command cmdname="组帧发送处理【预处理后发送】" cmdType="P" cmd="[P]void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen)
{
    //帧格式:帧同步字符0x55+0xAA(2字节),长度LEN(1字节),数据DATA,校验CS（1字节）
    int len,i;
    unsigned char cs;
    dstData[0]=0x55;  //帧同步字符
    dstData[1]=0xAA;  //帧同步字符

    dstData[2]=srcLen;
    memcpy(dstData+3,srcData,srcLen);
    cs=0;
    for(i=0; i&lt;srcLen+3; i++)
        cs=cs^dstData[i];

    dstData[srcLen+3]=cs;
    *dstLen=srcLen+4; //目标帧数据长度:55 aa len data cs
}
void main()
{
    ShowMessage(&quot;数据预处理模板，对发送的数据自动套用该模板处理。\n处理格式为：帧同步字符(0x55+0xAA(2字节))，长度LEN(1字节)，数据DATA(n字节)，校验CS（1字节）&quot;);
}">
    <Command cmdname="发送前后处理" cmdType="P" cmd="[P]void main()
{
    ShowMessage(&quot;在发送前后对发送内容可以进行预处理！&quot;);
}

void BeforeSend()
{
    PrintToCommWin(&quot;=====================&quot;);
}
void AfterSend()
{
    PrintToCommWin(&quot;---------------------&quot;);
    PrintToCommWin(&quot;&quot;);
}"/>
    <Command cmdname="组帧模板" cmdType="R" cmd="[R]void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen)
{
    //帧格式:帧同步字符0x55+0xAA(2字节),长度LEN(1字节),数据DATA,校验CS（1字节）
    int len,i;
    unsigned char cs;
    dstData[0]=0x55;  //帧同步字符
    dstData[1]=0xAA;  //帧同步字符

    dstData[2]=srcLen;
    memcpy(dstData+3,srcData,srcLen);
    cs=0;
    for(i=0; i&lt;srcLen+3; i++)
        cs=cs^dstData[i];

    dstData[srcLen+3]=cs;
    *dstLen=srcLen+4; //目标帧数据长度:55 aa len data cs
}
void main()
{
    ShowMessage(&quot;数据预处理模板，对发送的数据自动套用该模板处理。\n处理格式为：帧同步字符(0x55+0xAA(2字节))，长度LEN(1字节)，数据DATA(n字节)，校验CS（1字节）&quot;);
}"/>
    <Command cmdname="数据预处理[增加转义字符]" cmdType="R" cmd="[R]void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen)
{
    //0x02 为转义字符
    int len,i;
    len=0; 
    for(i=0;i&lt;srcLen;i++)
    {        
        dstData[len++]=srcData[i];
        if(srcData[i]==0x02)        
            dstData[len++]=srcData[i];        
    }
    *dstLen=len ;  
}">
      <Command cmdname="1234" cmdType="H" cmd="[H]01 02 03 04"/>
    </Command>
    <Command cmdname="数据预处理[进行帧封装]" cmdType="R" cmd="[R]#include &quot;stdio.h&quot;
void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen)
{
    //帧格式:帧同步字符0x55+0xAA(2字节),长度LEN(1字节),数据DATA,校验CS（1字节）
    int len,i;
    unsigned char cs;
    dstData[0]=0x55;  //帧同步字符
    dstData[1]=0xAA;  //帧同步字符
         
    dstData[2]=srcLen;
    memcpy(dstData+3,srcData,srcLen);    
    cs=0;
    for(i=0;i&lt;srcLen+3;i++)
      cs=cs^dstData[i];
      
    dstData[srcLen+3]=cs;
    *dstLen=srcLen+4; //目标帧数据长度:55 aa len data cs
    printf(&quot;aaa&quot;);
}">
      <Command cmdname="1234" cmdType="H" cmd="[H]11 22 33 44"/>
      <Command cmdname="字符串" cmdType="S" cmd="[S]12345"/>
    </Command>
  </Command>
  <Command cmdname="网络通讯" cmdType="S" cmd="[S]=====数据发送区/C语言脚本编辑区=====
1.[F5]键发送/执行、[F4]键终止脚本运行。
2.[F8]键显示、隐藏输出栏。
3.[Ctrl+.]调出脚本接口函数列表、[Ctrl+/]提示函数参数信息、[Ctrl+P]列出代码模板。
4.[Ctrl+Enter]发送数据。
5.支持&quot;预处理&quot;功能，采用C语言脚本回调函数，对发送的数据进行预处理后发送。">
    <Command cmdname="以太网抓包" cmdType="S" cmd="[S]数据发送区/C语言脚本编辑区，[F5]键发送/执行。">
      <Command cmdname="UDP抓包分析" cmdType="P" cmd="[P]int cb1,cb2,cb3;
int cb1chk=1,cb2chk=1,cb3chk=1;

void cb1click(int control)
{
    cb1chk=GetProperty(cb1,&quot;checked&quot;,0,0);
}
void cb2click(int control)
{
    cb2chk=GetProperty(cb2,&quot;checked&quot;,0,0);
}
void cb3click(int control)
{
    cb3chk=GetProperty(cb3,&quot;checked&quot;,0,0);
}
void main()
{
    ClearOutputWin();   //清除输出窗口内容
    ClearVclControls();
    ShowVclWin(160);
    ShowOutputWin(800);
    HideLeftTools();
    SetCommType(10);

    int p=GetGuiWin();
    int pnl = CreateComponentEx(p,&quot;panel&quot;,&quot;caption&quot;,&quot;&quot;,&quot;left&quot;,2,&quot;top&quot;,2,&quot;width&quot;,620,&quot;height&quot;,170,NULL);
    cb1= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示卡号&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb1click,NULL);
    cb2= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示版本&quot;,&quot;left&quot;,10,&quot;top&quot;,60,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb2click,NULL);
    cb3= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示读卡分站状态&quot;,&quot;left&quot;,10,&quot;top&quot;,80,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb3click,NULL);



};

typedef struct _TAG
{
    int id;
    char name[20];
} TAG;


TAG taglist[]=
{
    {  935,&quot;测试01&quot;},
    {  750,&quot;测试02&quot;},
    {  288,&quot;测试03&quot;},
    {  909,&quot;测试04&quot;},
    {  737,&quot;测试05&quot;},
    {  855,&quot;测试06&quot;},
    {  552,&quot;测试07&quot;},
    {  782,&quot;测试08&quot;},
    {  296,&quot;测试09&quot;},
    {  269,&quot;测试10&quot;},
    {26896,&quot;测试11&quot;},
    {18662,&quot;测试12&quot;},
    {28725,&quot;测试13&quot;},
    {21839,&quot;测试14&quot;},
    {26890,&quot;测试15&quot;},
    {28385,&quot;测试16&quot;},
    {22119,&quot;测试17&quot;},
    {25876,&quot;测试18&quot;},
    {10955,&quot;测试19&quot;},
    {23656,&quot;测试20&quot;},
    {20793,&quot;测试21&quot;},
    {21669,&quot;测试22&quot;},
    {27235,&quot;测试23&quot;},
    {26250,&quot;测试24&quot;},
    {27378,&quot;测试25&quot;},
    {27885,&quot;测试26&quot;},
    {26269,&quot;测试27&quot;},
    {28805,&quot;测试28&quot;},
    {28872,&quot;测试29&quot;},
    {25696,&quot;测试30&quot;},
};

void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;

    //for(i=0;i&lt;count;i++)printf(&quot;%02x &quot;,buf[i]&amp;0xff);
    GetTimeStr(tm,62);
    sprintf(tmp,&quot;%d.%d.%d.【%3d】&quot;,(srcIp&gt;&gt;0)&amp;0xff,(srcIp&gt;&gt;8)&amp;0xff,(srcIp&gt;&gt;16)&amp;0xff,(srcIp&gt;&gt;24)&amp;0xff);

    if(count&gt;25)
    {

        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x99)&amp;&amp;(buf[9]==0x04)&amp;&amp;(count&gt;25))//&amp;&amp;(buf[2]==0x11)
        {
            sprintf(s,&quot;%s  %s.%1X %02d:%02d:%02d  %02d,卡号：&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[14],buf[15],buf[16],(count-24)/2);
            for(j=23; j&lt;count-1; j+=2)
            {
                //printf(&quot;卡号:%05d&quot;,buf[j]*256+buf[j+1]);
                fd=0;
                if((buf[j]&gt;&gt;7)&gt;0)
                    printf(&quot;呼叫：%d&quot;,(buf[j]*256+buf[j+1])&amp;0x7fff);

                for(k=0; k&lt;sizeof(taglist); k++)
                    if(buf[j]*256+buf[j+1]==taglist[k].id)
                    {
                        sprintf(tmp,&quot;   VIP--%s,&quot;,taglist[k].name);
                        fd=1;
                        break;
                    }
                if(fd==0)
                    sprintf(tmp,&quot;%05d,&quot;,buf[j]*256+buf[j+1]);
                strcat(s,tmp);
            }
            if(cb1chk)
                printf(&quot;%s&quot;,s);
        }
    }
    else if(count&gt;=15)
    {
        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1d))
        {
            sprintf(s,&quot;%s  %s.%1X 上报版本号:%c%c%c%c&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[10],buf[11],buf[12],buf[13]);
            if(cb2chk)printf(s);
        }
    }
    else if(count&gt;=12)
    {
        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1a))
        {
            sprintf(s,&quot;%s  %s.%1X 上报读卡分站状态:%d&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[10]&amp;0xff);
            if(cb3chk)printf(s);
        }
    }
    else if(count&gt;=11)
    {
        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x07))
            printf(&quot;%s  %s.%1X 站点启动报告,代码：%d&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[9]);
    }

}


































"/>
      <Command cmdname="HTTP抓包分析" cmdType="P" cmd="[P]int cb1,cb2,cb3;
int cb1chk=1,cb2chk=1,cb3chk=1;

void main()
{
    ClearOutputWin();   //清除输出窗口内容
    ClearVclControls();
    ShowVclWin(160);
    ShowOutputWin(800);
    HideLeftTools();
    SetCommType(10);

    int p=GetGuiWin();
    int pnl = CreateComponentEx(p,&quot;panel&quot;,&quot;caption&quot;,&quot;&quot;,&quot;left&quot;,2,&quot;top&quot;,2,&quot;width&quot;,620,&quot;height&quot;,170,NULL);
   // cb1= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示卡号&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb1click,NULL);
   // cb2= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示版本&quot;,&quot;left&quot;,10,&quot;top&quot;,60,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb2click,NULL);
   // cb3= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示读卡分站状态&quot;,&quot;left&quot;,10,&quot;top&quot;,80,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb3click,NULL);



};


void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;
    printf(&quot;cap tcp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);
    if(dstPort!=80) return;

    if(strstr(buf,&quot;passw&quot;)!=0)
    {
        char *p=strstr(buf,&quot;passw&quot;);
        printf(&quot;find:%s&quot;,p);
    }
    else
    {
        return;
    }


}


































"/>
      <Command cmdname="UDP抓包分析-协议树" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
int cb1,cb2,cb3;
int cb1chk=1,cb2chk=1,cb3chk=1;
int station[255];
void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count);//UDP抓包事件
void AnaProtocolData(unsigned char *buf,int count)
{
    int node,node1;
    int i,j,k;
    char s[1024];
    if(count&lt;7)return;
    if(buf[0]!=0xff) return;
    if(buf[1]!=0xff) return;
    if(buf[3]&gt;count-5) return;
    unsigned char cs=0;
    for(i=0; i&lt;buf[3]+3; i++)
        cs+=buf[2+i];
    if(cs!=0)
    {
        printf(&quot;check sum error!&quot;);
        return;
    }
    AddPrtclDetailNode(NULL,&quot;同步头&quot;,0,2);
    AddPrtclDetailNode(NULL,&quot;目的地址&quot;,2,1);
    AddPrtclDetailNode(NULL,&quot;数据长度&quot;,3,1);
    AddPrtclDetailNode(NULL,&quot;源地址&quot;,4,1);
    AddPrtclDetailNode(NULL,&quot;流水号&quot;,5,1);
    if(buf[3]-2&gt;0)
    {
        AddPrtclDetailNode(NULL,&quot;数据长度&quot;,6,1);
        node=AddPrtclDetailNode(NULL,&quot;数据&quot;,7,buf[6]);
        AddPrtclDetailNode(node,&quot;点号&quot;,7,1);
        AddPrtclDetailNode(node,&quot;命令号&quot;,8,2);
        AddPrtclDetailNode(NULL,&quot;校验&quot;,7+buf[6],1);
    }
    else
    {
        AddPrtclDetailNode(NULL,&quot;校验&quot;,6,1);
    }

    if(count&gt;25)
    {
        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x99)&amp;&amp;(buf[9]==0x04)&amp;&amp;(count&gt;25))//&amp;&amp;(buf[2]==0x11)
        {
            AddPrtclDetailNode(node,&quot;日期&quot;,10,4);

            node1=AddPrtclDetailNode(node,&quot;时间&quot;,14,3);
            sprintf(s,&quot;%02d:%02d:%02d&quot;,buf[14]&amp;0xff,buf[15]&amp;0xff,buf[16]&amp;0xff);
            AddPrtclDetailNode(node1,s,10,0);

            AddPrtclDetailNode(node,&quot;查询流水号&quot;,17,1);
            AddPrtclDetailNode(node,&quot;总包数&quot;,18,1);
            AddPrtclDetailNode(node,&quot;包号&quot;,19,1);
            AddPrtclDetailNode(node,&quot;节点号&quot;,20,1);
            AddPrtclDetailNode(node,&quot;总团数&quot;,21,1);
            AddPrtclDetailNode(node,&quot;团人数&quot;,22,1);

            node1=AddPrtclDetailNode(node,&quot;卡号&quot;,23,buf[6]-16);
            for(i=0; i&lt;buf[6]-16; i+=2)
            {
                sprintf(s,&quot;卡%02d:%05d &quot;,i+1,buf[23+i]*256+buf[23+i+1]);
                AddPrtclDetailNode(node1,s,23+i,2);
            }
        }
    }
    else if(count&gt;=15)
    {
        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1d))
        {
            sprintf(s,&quot;版本号:%c%c%c%c&quot;,buf[10],buf[11],buf[12],buf[13]);
            AddPrtclDetailNode(node,s,10,4);
        }
    }
    else if(count&gt;=12)
    {
        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1a))
        {
            sprintf(s,&quot;读卡分站状态:%d&quot;,buf[10]&amp;0xff);
            AddPrtclDetailNode(node,s,10,1);
        }
    }
    else if(count&gt;=11)
    {
        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x07))
        {
            sprintf(s,&quot;启动报告代码：%d&quot;,buf[9]);
            AddPrtclDetailNode(node,s,9,1);
        }
    }
}


void cb1click(int control)
{
    cb1chk=GetProperty(cb1,&quot;checked&quot;,0,0);
}

void cb2click(int control)
{
    cb2chk=GetProperty(cb2,&quot;checked&quot;,0,0);
}

void cb3click(int control)
{
    cb3chk=GetProperty(cb3,&quot;checked&quot;,0,0);
}
void btnClick(int control)
{
    unsigned char dat0[]= {0xFF,0xFF,0x11,0x19,0x13,0x09,0x16,0x10,0x99,0x04,0x07,0xDB,0x08,0x1A,0x0C,0x2A,0x18,0x56,0x01,0x01,0x10,0x01,0x03,0x5A,0xAF,0x69,0x4B,0x68,0x2A,0xEA};
    unsigned char dat1[]= {0xFF,0xFF,0x11,0x0A,0x13,0x05,0x07,0xC0,0x98,0x1D,0x31,0x2E,0x30,0x32,0x90};

    CapUdpData(0,0,0,0,dat0,sizeof(dat0));//UDP抓包模拟
    CapUdpData(0,0,0,0,dat1,sizeof(dat1));//UDP抓包模拟
}
void main()
{
    int i;
    ClearOutputWin();   //清除输出窗口内容
    ClearVclControls();
    ShowVclWin(160);
    ShowOutputWin(800);
    //HideLeftTools();
    ShowProtocolWin();
    ClearProtocolTree();
    SetCommType(10);

    int p=GetGuiWin();
    int pnl = CreateComponentEx(p,&quot;panel&quot;,&quot;caption&quot;,&quot;&quot;,&quot;left&quot;,2,&quot;top&quot;,2,&quot;width&quot;,620,&quot;height&quot;,170,NULL);
    cb1= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示卡号&quot;,&quot;left&quot;,10,&quot;top&quot;,40,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb1click,NULL);
    cb2= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示版本&quot;,&quot;left&quot;,10,&quot;top&quot;,60,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb2click,NULL);
    cb3= CreateComponentEx(pnl,&quot;checkbox&quot;,&quot;caption&quot;,&quot;显示读卡分站状态&quot;,&quot;left&quot;,10,&quot;top&quot;,80,&quot;width&quot;,160,&quot;checked&quot;,1,&quot;onclick&quot;,cb3click,NULL);
    CreateComponentEx(pnl,&quot;button&quot;,&quot;caption&quot;,&quot;测试数据&quot;,&quot;left&quot;,10,&quot;top&quot;,100,&quot;width&quot;,100,&quot;onclick&quot;,btnClick,NULL);
    for(i=0; i&lt;255; i++)station[i]=0;

    //btnClick(0);
};

typedef struct _TAG
{
    int id;
    char name[20];
} TAG;


TAG taglist[]=
{
    {  935,&quot;测试01&quot;},
    {  750,&quot;测试02&quot;},
    {  288,&quot;测试03&quot;},
    {  909,&quot;测试04&quot;},
    {  737,&quot;测试05&quot;},
    {  855,&quot;测试06&quot;},
    {  552,&quot;测试07&quot;},
    {  782,&quot;测试08&quot;},
    {  296,&quot;测试09&quot;},
    {  269,&quot;测试10&quot;},
    {26896,&quot;测试11&quot;},
    {18662,&quot;测试12&quot;},
    {28725,&quot;测试13&quot;},
    {21839,&quot;测试14&quot;},
    {26890,&quot;测试15&quot;},
    {28385,&quot;测试16&quot;},
    {22119,&quot;测试17&quot;},
    {25876,&quot;测试18&quot;},
    {10955,&quot;测试19&quot;},
    {23656,&quot;测试20&quot;},
    {20793,&quot;测试21&quot;},
    {21669,&quot;测试22&quot;},
    {27235,&quot;测试23&quot;},
    {26250,&quot;测试24&quot;},
    {27378,&quot;测试25&quot;},
    {27885,&quot;测试26&quot;},
    {26269,&quot;测试27&quot;},
    {28805,&quot;测试28&quot;},
    {28872,&quot;测试29&quot;},
    {25696,&quot;测试30&quot;},
};

void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;

    //for(i=0;i&lt;count;i++)printf(&quot;%02x &quot;,buf[i]&amp;0xff);
    GetTimeStr(tm,62);
    sprintf(tmp,&quot;%d.%d.%d.【%3d】&quot;,(srcIp&gt;&gt;0)&amp;0xff,(srcIp&gt;&gt;8)&amp;0xff,(srcIp&gt;&gt;16)&amp;0xff,(srcIp&gt;&gt;24)&amp;0xff);

    if(count&lt;7)return;
    if(buf[0]!=0xff) return;
    if(buf[1]!=0xff) return;
    if(buf[3]&gt;count-5) return;
    unsigned char cs=0;
    unsigned char src,dst;
    int node;


    for(i=0; i&lt;buf[3]+3; i++)
        cs+=buf[2+i];
    if(cs!=0)
    {
        printf(&quot;check sum error!&quot;);
        return;
    }

    src=buf[4];
    dst=buf[2];
    if(src==17)
    {
        if(station[dst]==0)
        {
            sprintf(s,&quot;分站-%d&quot;,dst);
            station[dst]=AddPrtclDataNode(NULL,s,0,0,0);
        }
        node=station[dst];
    }
    else
    {
        if(station[src]==0)
        {
            sprintf(s,&quot;分站-%d&quot;,src);
            station[dst]=AddPrtclDataNode(NULL,s,0,0,0);
        }
        node=station[src];
    }

    if(buf[3]==0x02)
    {
        sprintf(s,&quot;循访空包:%d-&gt;%d,sn:%d&quot;,buf[4],buf[2],buf[5]);
        src=buf[4];
        dst=buf[2];

        AddPrtclDataNode(node,s,buf,count,0);



        return;
    }

    if(count&gt;25)
    {
        sprintf(s,&quot;上报卡号:%d-&gt;%d,sn:%d&quot;,buf[4],buf[2],buf[5]);
        AddPrtclDataNode(node,s,buf,count,0);


        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x99)&amp;&amp;(buf[9]==0x04)&amp;&amp;(count&gt;25))//&amp;&amp;(buf[2]==0x11)
        {
            sprintf(s,&quot;%s  %s.%1X %02d:%02d:%02d  %02d,卡号：&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[14],buf[15],buf[16],(count-24)/2);
            for(j=23; j&lt;count-1; j+=2)
            {
                //printf(&quot;卡号:%05d&quot;,buf[j]*256+buf[j+1]);
                fd=0;
                if((buf[j]&gt;&gt;7)&gt;0)
                    printf(&quot;呼叫：%d&quot;,(buf[j]*256+buf[j+1])&amp;0x7fff);

                for(k=0; k&lt;sizeof(taglist); k++)
                    if(buf[j]*256+buf[j+1]==taglist[k].id)
                    {
                        sprintf(tmp,&quot;   VIP--%s,&quot;,taglist[k].name);
                        fd=1;
                        break;
                    }
                if(fd==0)
                    sprintf(tmp,&quot;%05d,&quot;,buf[j]*256+buf[j+1]);
                strcat(s,tmp);
            }
            if(cb1chk)
                printf(&quot;%s&quot;,s);
        }
    }
    else if(count&gt;=15)
    {
        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1d))
        {


            sprintf(s,&quot;上报版本号:%d-&gt;%d,sn:%d&quot;,buf[4],buf[2],buf[5]);
            AddPrtclDataNode(node,s,buf,count,0);

            sprintf(s,&quot;%s  %s.%1X 上报版本号:%c%c%c%c&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[10],buf[11],buf[12],buf[13]);
            if(cb2chk)printf(s);
        }
    }
    else if(count&gt;=12)
    {
        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x98)&amp;&amp;(buf[9]==0x1a))
        {


            sprintf(s,&quot;上报读卡分站状态:%d-&gt;%d,sn:%d&quot;,buf[4],buf[2],buf[5]);
            AddPrtclDataNode(node,s,buf,count,0);

            sprintf(s,&quot;%s  %s.%1X 上报读卡分站状态:%d&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[10]&amp;0xff);
            if(cb3chk)printf(s);
        }
    }
    else if(count&gt;=11)
    {
        if((buf[0]==0xff)&amp;&amp;(buf[1]==0xff)&amp;&amp;(buf[8]==0x07))
        {

            sprintf(s,&quot;站点启动报告:%d-&gt;%d,sn:%d&quot;,buf[4],buf[2],buf[5]);
            AddPrtclDataNode(node,s,buf,count,0);

            printf(&quot;%s  %s.%1X 站点启动报告,代码：%d&quot;,tm,tmp,(buf[7]&gt;&gt;4)&amp;0xff,buf[9]);
        }
    }

}


































"/>
    </Command>
    <Command cmdname="C脚本通讯协议分析-数据树形显示" cmdType="P" cmd="[P]#include &quot;windows.h&quot; 
 
//////////////// 接收队列处理 ///////////////////////////////////
#define MAXRXBUFLEN (1024*20)
#define GetRxBufLen()  ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN)
#define IsRxBufEmpty() (RxBufHead==RxBufTail)
#define IsRxBufFull()  ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead)
#define ClearRxBuf()   RxBufHead=RxBufTail=0

BYTE RxBuf[MAXRXBUFLEN];
BYTE RxBufHead=0;
BYTE RxBufTail=0;

BYTE GetRxBufByte(void)
{
   BYTE dat;
   dat=RxBuf[RxBufHead];
   RxBufHead++;
   RxBufHead%=MAXRXBUFLEN;
   return dat;
}
void DiscardRxBufBytes(BYTE count)
{
   RxBufHead+=count;
   RxBufHead%=MAXRXBUFLEN;
}
BYTE PeekRxBufByte(BYTE idx)
{
   BYTE tmpHead=RxBufHead;
   tmpHead+=idx;
   tmpHead%=MAXRXBUFLEN;
   return RxBuf[tmpHead];
}
void PutRxBufByte(BYTE dat)
{
   RxBuf[RxBufTail]=dat;
   RxBufTail++;
   RxBufTail%=MAXRXBUFLEN;
}

//////////////////////////////////////////////////////////////////
//////////////// 队列处理 ///////////////////////////////////
//#define MAXRXBUFLEN (1024*20)
#define GetPrtclBufLen()  ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN)
#define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail)
#define IsPrtclBufFull()  ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead)
#define ClearPrtclBuf()   PrtclBufHead=PrtclBufTail=0

BYTE PrtclBuf[MAXRXBUFLEN];
BYTE PrtclBufHead=0;
BYTE PrtclBufTail=0;

BYTE GetPrtclBufByte(void)
{
   BYTE dat;
   dat=PrtclBuf[PrtclBufHead];
   PrtclBufHead++;
   PrtclBufHead%=MAXRXBUFLEN;
   return dat;
}
void DiscardPrtclBufBytes(BYTE count)
{
   PrtclBufHead+=count;
   PrtclBufHead%=MAXRXBUFLEN;
}
BYTE PeekPrtclBufByte(BYTE idx)
{
   BYTE tmpHead=PrtclBufHead;
   tmpHead+=idx;
   tmpHead%=MAXRXBUFLEN;
   return PrtclBuf[tmpHead];
}
void PutPrtclBufByte(BYTE dat)
{
   PrtclBuf[PrtclBufTail]=dat;
   PrtclBufTail++;
   PrtclBufTail%=MAXRXBUFLEN;
}

//////////////////////////////////////////////////////////////////




#define MAXCMDLEN 20
BYTE StationCmd[MAXCMDLEN];
BYTE StationCmdLen;
BYTE RepBuf[140];

unsigned int  newId,newInterval;

void ConsolePutArray(BYTE buf[],BYTE len)
{
   BYTE i;
   for(i=0;i&lt;len;i++)
   	;//   halPutch(buf[i]);
}

 
void ProgramData(void)// 查询单个团详细信息
{
    BYTE i,j;
    BYTE find;
    BYTE idx;
    BYTE cs;
    BYTE mbCount;

    if(StationCmdLen!=1+4)
    { 	 
	  // return;
    }
    newId=StationCmd[1]+StationCmd[2]*256;
     
}

void ProcessStationCmd(void)
{
    if(StationCmdLen==0) return;
    switch(StationCmd[0])
    {   	
        case 0x08: // 查询工作状态            =[H]55 AA 02 FD 07 07 03
           ProgramData();
   	   break;
		
        default:
	   break;
    } 
}

void EncodePrtclData(void)//包裹解码
{
   BYTE i,len;
   BYTE cs;
   len=PeekPrtclBufByte(2);
   if(len&gt;MAXCMDLEN)
   {
       StationCmd[0]=PeekPrtclBufByte(4);
       for(i=0;i&lt;=4+len;i++)
   	   GetPrtclBufByte();//丢弃一个字节;
       return ;
   }
   AddPrtclDetailNode(NULL,&quot;同步头&quot;,PrtclBufHead,2);
   GetPrtclBufByte();//丢弃一个字节; 55
   GetPrtclBufByte();//丢弃一个字节; aa
   AddPrtclDetailNode(NULL,&quot;长度&quot;,PrtclBufHead,1);

   GetPrtclBufByte();//丢弃一个字节; len
   AddPrtclDetailNode(NULL,&quot;~长度&quot;,PrtclBufHead,1);
   GetPrtclBufByte();//丢弃一个字节; ~len

   AddPrtclDetailNode(NULL,&quot;data&quot;,PrtclBufHead,len);  

   for(i=0;i&lt;len;i++)
      StationCmd[i]=GetPrtclBufByte();
   GetPrtclBufByte(); //0x03

   cs=0;
   for(i=0;i&lt;len-1;i++)
      cs^=StationCmd[i];

   if(cs!=StationCmd[len-1])
   {       
       printf(&quot;check sum error!&quot;);
       //return;	
   }

   //ConsolePutROMString((rom char *)&quot;接收到命令包:&quot;);
   //ConsolePutInitData(0,StationCmd[0]);
   StationCmdLen=len-1; //不包含校验位
   printf(&quot;Recv a command!&quot;);
   ProcessStationCmd();

}


//通讯处理
void ProcessRxComm(void)
{
    BYTE len;
    while(GetRxBufLen()&gt;=7)
    {
        if(PeekRxBufByte(0)!=0x55)	  	
        {          
           DiscardRxBufBytes(1);
        }
        else if(PeekRxBufByte(1)!=0xaa)	  	
	{	   
	   DiscardRxBufBytes(2);
	}
	else if(PeekRxBufByte(2)+PeekRxBufByte(3)!=0xff)//长度、长度取反
	{	 
	   DiscardRxBufBytes(4);
	}
	else
	{
	   len=PeekRxBufByte(2);
           if(len&gt;MAXCMDLEN)  //命令过长
	   {	       
              DiscardRxBufBytes(4);
	   }
	   else if(GetRxBufLen()&gt;len+4)
	   {
	     if(PeekRxBufByte(4+len)!=0x03)//结束字符
	     {	 	   
        	   DiscardRxBufBytes(1);
	     }
	     else
	    {
                  
                 AddPrtclDataNode(NULL,&quot;版本号查询&quot;,&amp;RxBuf[RxBufHead],len+5,0);
                  
		 DiscardRxBufBytes(len+5);
                  
	    }
	  }
	  else
	  {
	      break;
	  }
	}			
    }	//while	
}



void ProcessPrtclData(void)
{
    BYTE len;
    while(GetPrtclBufLen()&gt;=7)
    {
        if(PeekPrtclBufByte(0)!=0x55)	  	
        {          
           DiscardPrtclBufBytes(1);
        }
        else if(PeekPrtclBufByte(1)!=0xaa)	  	
	{	   
	   DiscardPrtclBufBytes(2);
	}
	else if(PeekPrtclBufByte(2)+PeekPrtclBufByte(3)!=0xff)//长度、长度取反
	{	 
	   DiscardPrtclBufBytes(4);
	}
	else
	{
	   len=PeekPrtclBufByte(2);
           if(len&gt;MAXCMDLEN)  //命令过长
	   {	       
              DiscardPrtclBufBytes(4);
	   }
	   else if(GetPrtclBufLen()&gt;len+4)
	   {
	     if(PeekPrtclBufByte(4+len)!=0x03)//结束字符
	     {	 	   
        	   DiscardPrtclBufBytes(1);
	     }
	     else
	    {  
                 EncodePrtclData(); 
	    }
	  }
	  else
	  {
	      break;
	  }
	}			
    }	//while	
}


//////////////////////////////////////////////////////////////////////

void RecvSerialData(char *buf,int count)
{
   int i;
   for(i=0;i&lt;count;i++)
   {
       PutRxBufByte(buf[i]);
   }  
   printf(&quot;RecvSerialData,len(%d)&quot;,count);  
   ProcessRxComm();
 
}
void AnaProtocolData(char *buf,int count)
{   
   int node; int i;
   printf(&quot;AnaProtocolData,len(%d) &quot;,count );  
   ClearPrtclBuf();
   for(i=0;i&lt;count;i++)
       PutPrtclBufByte(buf[i]);
   ProcessPrtclData();
   
}

void click(int btn)
{
   char s[20];
   printf(&quot;clicked&quot;);
   //SetProperty(btn,&quot;enabled&quot;,&quot;false&quot;);
   GetProperty(btn,&quot;caption&quot;,s,20); 
   printf(&quot;button caption is %s&quot;,s);   
   MessageBox(0,s,&quot;按钮标题&quot;,1);
};







void main()
{
  int i;
  int btn;
  int node;
  char s[100];
  ShowProtocolWindow();
  ClearVclControls();
  ShowVclWin(150);
  ShowOutputWin(300);
  int p=GetGuiWindow();
  for(  i=0;i&lt;1;i++)
  {                              
     sprintf(s,&quot;按钮:%d&quot;,i);
     btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,s,&quot;left&quot;,10+i*70,&quot;top&quot;,30,&quot;width&quot;,65,&quot;onclick&quot;,click,NULL);//创建按钮
  }

  btn=CreateComponentEx(p,&quot;combobox&quot;,&quot;text&quot;,&quot;按钮&quot;,&quot;left&quot;,12+i*70,&quot;top&quot;,32,&quot;width&quot;,80,&quot;onclick&quot;,click,NULL);//创建按钮
  //SetProperty(btn,&quot;caption&quot;,&quot;最后一个按钮&quot;);
  StringsAdd(btn,&quot;111&quot;);
  //s[0]=90;//printf(&quot;%s&quot;,s);
  sprintf(s+10,&quot;按钮876587iuytiuyt87888777666555:%d&quot;,i);   
  ClearProtocolTree();
  //node=AddPrtclDataNode(NULL,&quot;版本号查询&quot;,s,100,0);
  //sprintf(s+10,&quot;reqtgfdsgfdsgft64ew2543w25435:%d&quot;,i); 
  //node=AddPrtclDataNode(node,&quot;版本号查询1&quot;,s,100,0);
};
">
      <Command cmdname="协议解析程序0" cmdType="P" cmd="[P]#include &quot;windows.h&quot;

//////////////// 接收队列处理 ///////////////////////////////////
#define MAXRXBUFLEN (1024*20)
#define GetRxBufLen()  ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN)
#define IsRxBufEmpty() (RxBufHead==RxBufTail)
#define IsRxBufFull()  ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead)
#define ClearRxBuf()   RxBufHead=RxBufTail=0

BYTE RxBuf[MAXRXBUFLEN];
BYTE RxBufHead=0;
BYTE RxBufTail=0;

BYTE GetRxBufByte(void)
{
    BYTE dat;
    dat=RxBuf[RxBufHead];
    RxBufHead++;
    RxBufHead%=MAXRXBUFLEN;
    return dat;
}
void DiscardRxBufBytes(BYTE count)
{
    RxBufHead+=count;
    RxBufHead%=MAXRXBUFLEN;
}
BYTE PeekRxBufByte(BYTE idx)
{
    BYTE tmpHead=RxBufHead;
    tmpHead+=idx;
    tmpHead%=MAXRXBUFLEN;
    return RxBuf[tmpHead];
}
void PutRxBufByte(BYTE dat)
{
    RxBuf[RxBufTail]=dat;
    RxBufTail++;
    RxBufTail%=MAXRXBUFLEN;
}

//////////////////////////////////////////////////////////////////
//////////////// 队列处理 ///////////////////////////////////
//#define MAXRXBUFLEN (1024*20)
#define GetPrtclBufLen()  ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN)
#define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail)
#define IsPrtclBufFull()  ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead)
#define ClearPrtclBuf()   PrtclBufHead=PrtclBufTail=0

BYTE PrtclBuf[MAXRXBUFLEN];
BYTE PrtclBufHead=0;
BYTE PrtclBufTail=0;

BYTE GetPrtclBufByte(void)
{
    BYTE dat;
    dat=PrtclBuf[PrtclBufHead];
    PrtclBufHead++;
    PrtclBufHead%=MAXRXBUFLEN;
    return dat;
}
void DiscardPrtclBufBytes(BYTE count)
{
    PrtclBufHead+=count;
    PrtclBufHead%=MAXRXBUFLEN;
}
BYTE PeekPrtclBufByte(BYTE idx)
{
    BYTE tmpHead=PrtclBufHead;
    tmpHead+=idx;
    tmpHead%=MAXRXBUFLEN;
    return PrtclBuf[tmpHead];
}
void PutPrtclBufByte(BYTE dat)
{
    PrtclBuf[PrtclBufTail]=dat;
    PrtclBufTail++;
    PrtclBufTail%=MAXRXBUFLEN;
}

//////////////////////////////////////////////////////////////////




#define MAXCMDLEN 20
BYTE StationCmd[MAXCMDLEN];
BYTE StationCmdLen;
BYTE RepBuf[140];

unsigned int  newId,newInterval;

void ConsolePutArray(BYTE buf[],BYTE len)
{
    BYTE i;
    for(i=0; i&lt;len; i++)
        ;//   halPutch(buf[i]);
}


void ProgramData(void)// 查询单个团详细信息
{
    BYTE i,j;
    BYTE find;
    BYTE idx;
    BYTE cs;
    BYTE mbCount;

    if(StationCmdLen!=1+4)
    {
        // return;
    }
    newId=StationCmd[1]+StationCmd[2]*256;

}

void ProcessStationCmd(void)
{
    if(StationCmdLen==0) return;
    switch(StationCmd[0])
    {
    case 0x08: // 查询工作状态            =[H]55 AA 02 FD 07 07 03
        ProgramData();
        break;
    case 0x09: // 查询工作状态            =[H]55 AA 02 FD 07 07 03
        ProgramData();
        break;
    default:
        break;
    }
}

void EncodePrtclData(void)//包裹解码
{
    BYTE i,len;
    BYTE cs;
    len=PeekPrtclBufByte(2);
    if(len&gt;MAXCMDLEN)
    {
        StationCmd[0]=PeekPrtclBufByte(4);
        for(i=0; i&lt;=4+len; i++)
            GetPrtclBufByte();//丢弃一个字节;
        return ;
    }
    AddPrtclDetailNode(NULL,&quot;同步头&quot;,PrtclBufHead,2);
    GetPrtclBufByte();//丢弃一个字节; 55
    GetPrtclBufByte();//丢弃一个字节; aa
    AddPrtclDetailNode(NULL,&quot;长度&quot;,PrtclBufHead,1);

    GetPrtclBufByte();//丢弃一个字节; len
    AddPrtclDetailNode(NULL,&quot;~长度&quot;,PrtclBufHead,1);
    GetPrtclBufByte();//丢弃一个字节; ~len

    AddPrtclDetailNode(NULL,&quot;data&quot;,PrtclBufHead,len);

    for(i=0; i&lt;len; i++)
        StationCmd[i]=GetPrtclBufByte();
    GetPrtclBufByte(); //0x03

    cs=0;
    for(i=0; i&lt;len-1; i++)
    {
        printf(&quot;cs:%d,%02x&quot;,i,StationCmd[i]&amp;0xff);
        cs+=StationCmd[i];
    }

    if(cs!=StationCmd[len-1])
    {
        printf(&quot;check sum error:0x%02x---0x%02x!&quot;,cs,StationCmd[len-1]&amp;0xff);
        //return;
    }
    else
        printf(&quot;check sum success:%02x!&quot;,StationCmd[len-1]&amp;0xff);

    //ConsolePutROMString((rom char *)&quot;接收到命令包:&quot;);
    //ConsolePutInitData(0,StationCmd[0]);
    StationCmdLen=len-1; //不包含校验位
    printf(&quot;Recv a command!&quot;);
    ProcessStationCmd();

}


//通讯处理
void ProcessRxComm(void)
{
    BYTE len;
    while(GetRxBufLen()&gt;=7)
    {
        if(PeekRxBufByte(0)!=0x55)
        {
            DiscardRxBufBytes(1);
        }
        else if(PeekRxBufByte(1)!=0xaa)
        {
            DiscardRxBufBytes(2);
        }
        else if(PeekRxBufByte(2)+PeekRxBufByte(3)!=0xff)//长度、长度取反
        {
            DiscardRxBufBytes(4);
        }
        else
        {
            len=PeekRxBufByte(2);
            if(len&gt;MAXCMDLEN)  //命令过长
            {
                DiscardRxBufBytes(4);
            }
            else if(GetRxBufLen()&gt;len+4)
            {
                if(PeekRxBufByte(4+len)!=0x03)//结束字符
                {
                    DiscardRxBufBytes(1);
                }
                else
                {
                    if(RxBuf[RxBufHead+4]==0x01)
                        AddPrtclDataNode(NULL,&quot;版本号查询&quot;,&amp;RxBuf[RxBufHead],len+5,0);
                    else if(RxBuf[RxBufHead+4]==0x02)
                        AddPrtclDataNode(NULL,&quot;读序列号&quot;,&amp;RxBuf[RxBufHead],len+5,0);
                    else if(RxBuf[RxBufHead+4]==0x03)
                        AddPrtclDataNode(NULL,&quot;控制继电器&quot;,&amp;RxBuf[RxBufHead],len+5,0);
                    DiscardRxBufBytes(len+5);

                }
            }
            else
            {
                break;
            }
        }
    }	//while
}



void ProcessPrtclData(void)
{
    BYTE len;
    while(GetPrtclBufLen()&gt;=7)
    {
        if(PeekPrtclBufByte(0)!=0x55)
        {
            DiscardPrtclBufBytes(1);
        }
        else if(PeekPrtclBufByte(1)!=0xaa)
        {
            DiscardPrtclBufBytes(2);
        }
        else if(PeekPrtclBufByte(2)+PeekPrtclBufByte(3)!=0xff)//长度、长度取反
        {
            DiscardPrtclBufBytes(4);
        }
        else
        {
            len=PeekPrtclBufByte(2);
            if(len&gt;MAXCMDLEN)  //命令过长
            {
                DiscardPrtclBufBytes(4);
            }
            else if(GetPrtclBufLen()&gt;len+4)
            {
                if(PeekPrtclBufByte(4+len)!=0x03)//结束字符
                {
                    DiscardPrtclBufBytes(1);
                }
                else
                {
                    EncodePrtclData();
                }
            }
            else
            {
                break;
            }
        }
    }	//while
}


//////////////////////////////////////////////////////////////////////

void RecvSerialData(char *buf,int count)
{
    int i;
    for(i=0; i&lt;count; i++)
    {
        PutRxBufByte(buf[i]);
    }
    printf(&quot;RecvSerialData,len(%d)&quot;,count);
    ProcessRxComm();

}
void AnaProtocolData(char *buf,int count)
{
    int node;
    int i;
    printf(&quot;AnaProtocolData,len(%d) &quot;,count );
    ClearPrtclBuf();
    for(i=0; i&lt;count; i++)
        PutPrtclBufByte(buf[i]);
    ProcessPrtclData();

}

void click(int btn)
{
    char s0[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x01 ,0x02 ,0x03 ,0x06 ,0x03};
    char s1[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x02 ,0x02 ,0xf3 ,0xf7 ,0x03};
    //SendHexString(s);
    RecvSerialData(s0,sizeof(s0));
    RecvSerialData(s1,sizeof(s1));
};



void main()
{
    int i;
    int btn;
    int node;
    char s[100];
    ShowProtocolWin();
    ClearVclControls();

    //ShowOutputWin(300);
    ShowVclWin(150);
    int p=GetGuiWin(1);
    for(  i=0; i&lt;2; i++)
    {
        sprintf(s,&quot;按钮:%d&quot;,i);
        btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,s,&quot;left&quot;,10+i*70,&quot;top&quot;,30,&quot;width&quot;,65,&quot;onclick&quot;,click,NULL);//创建按钮
    }

    ClearProtocolTree();
    click(0);
};
"/>
      <Command cmdname="协议解析程序1" cmdType="P" cmd="[P]#include &quot;windows.h&quot;

//////////////// 接收队列处理 ///////////////////////////////////
#define MAXRXBUFLEN (1024*20)
#define GetRxBufLen()  ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN)
#define IsRxBufEmpty() (RxBufHead==RxBufTail)
#define IsRxBufFull()  ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead)
#define ClearRxBuf()   RxBufHead=RxBufTail=0

BYTE RxBuf[MAXRXBUFLEN];
BYTE RxBufHead=0;
BYTE RxBufTail=0;

BYTE GetRxBufByte(void)
{
    BYTE dat;
    dat=RxBuf[RxBufHead];
    RxBufHead++;
    RxBufHead%=MAXRXBUFLEN;
    return dat;
}
void DiscardRxBufBytes(BYTE count)
{
    RxBufHead+=count;
    RxBufHead%=MAXRXBUFLEN;
}
BYTE PeekRxBufByte(BYTE idx)
{
    BYTE tmpHead=RxBufHead;
    tmpHead+=idx;
    tmpHead%=MAXRXBUFLEN;
    return RxBuf[tmpHead];
}
void PutRxBufByte(BYTE dat)
{
    RxBuf[RxBufTail]=dat;
    RxBufTail++;
    RxBufTail%=MAXRXBUFLEN;
}

//////////////////////////////////////////////////////////////////
//////////////// 队列处理 ///////////////////////////////////
//#define MAXRXBUFLEN (1024*20)
#define GetPrtclBufLen()  ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN)
#define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail)
#define IsPrtclBufFull()  ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead)
#define ClearPrtclBuf()   PrtclBufHead=PrtclBufTail=0

BYTE PrtclBuf[MAXRXBUFLEN];
BYTE PrtclBufHead=0;
BYTE PrtclBufTail=0;

BYTE GetPrtclBufByte(void)
{
    BYTE dat;
    dat=PrtclBuf[PrtclBufHead];
    PrtclBufHead++;
    PrtclBufHead%=MAXRXBUFLEN;
    return dat;
}
void DiscardPrtclBufBytes(BYTE count)
{
    PrtclBufHead+=count;
    PrtclBufHead%=MAXRXBUFLEN;
}
BYTE PeekPrtclBufByte(BYTE idx)
{
    BYTE tmpHead=PrtclBufHead;
    tmpHead+=idx;
    tmpHead%=MAXRXBUFLEN;
    return PrtclBuf[tmpHead];
}
void PutPrtclBufByte(BYTE dat)
{
    PrtclBuf[PrtclBufTail]=dat;
    PrtclBufTail++;
    PrtclBufTail%=MAXRXBUFLEN;
}

//////////////////////////////////////////////////////////////////




#define MAXCMDLEN 20
BYTE StationCmd[MAXCMDLEN];
BYTE StationCmdLen;
BYTE RepBuf[140];

unsigned int  newId,newInterval;

void ConsolePutArray(BYTE buf[],BYTE len)
{
    BYTE i;
    for(i=0; i&lt;len; i++)
        ;//   halPutch(buf[i]);
}


void ProgramData(void)// 查询单个团详细信息
{
    BYTE i,j;
    BYTE find;
    BYTE idx;
    BYTE cs;
    BYTE mbCount;

    if(StationCmdLen!=1+4)
    {
        // return;
    }
    newId=StationCmd[1]+StationCmd[2]*256;

}

void ProcessStationCmd(void)
{
    if(StationCmdLen==0) return;
    switch(StationCmd[0])
    {
    case 0x08: // 查询工作状态            =[H]55 AA 02 FD 07 07 03
        ProgramData();
        break;
    case 0x09: // 查询工作状态            =[H]55 AA 02 FD 07 07 03
        ProgramData();
        break;
    default:
        break;
    }
}

void EncodePrtclData(void)//包裹解码
{
    BYTE i,len;
    BYTE cs;
    len=PeekPrtclBufByte(2);
    if(len&gt;MAXCMDLEN)
    {
        StationCmd[0]=PeekPrtclBufByte(4);
        for(i=0; i&lt;=4+len; i++)
            GetPrtclBufByte();//丢弃一个字节;
        return ;
    }
    AddPrtclDetailNode(NULL,&quot;同步头&quot;,PrtclBufHead,2);
    GetPrtclBufByte();//丢弃一个字节; 55
    GetPrtclBufByte();//丢弃一个字节; aa
    AddPrtclDetailNode(NULL,&quot;长度&quot;,PrtclBufHead,1);

    GetPrtclBufByte();//丢弃一个字节; len
    AddPrtclDetailNode(NULL,&quot;~长度&quot;,PrtclBufHead,1);
    GetPrtclBufByte();//丢弃一个字节; ~len

    AddPrtclDetailNode(NULL,&quot;data&quot;,PrtclBufHead,len);

    for(i=0; i&lt;len; i++)
        StationCmd[i]=GetPrtclBufByte();
    GetPrtclBufByte(); //0x03

    cs=0;
    for(i=0; i&lt;len-1; i++)
    {
        printf(&quot;cs:%d,%02x&quot;,i,StationCmd[i]&amp;0xff);
        cs+=StationCmd[i];
    }

    if(cs!=StationCmd[len-1])
    {
        printf(&quot;check sum error:0x%02x---0x%02x!&quot;,cs,StationCmd[len-1]&amp;0xff);
        //return;
    }
    else
        printf(&quot;check sum success:%02x!&quot;,StationCmd[len-1]&amp;0xff);

    //ConsolePutROMString((rom char *)&quot;接收到命令包:&quot;);
    //ConsolePutInitData(0,StationCmd[0]);
    StationCmdLen=len-1; //不包含校验位
    printf(&quot;Recv a command!&quot;);
    ProcessStationCmd();

}


//通讯处理
void ProcessRxComm(void)
{
    BYTE len;
    while(GetRxBufLen()&gt;=7)
    {
        if(PeekRxBufByte(0)!=0x55)
        {
            DiscardRxBufBytes(1);
        }
        else if(PeekRxBufByte(1)!=0xaa)
        {
            DiscardRxBufBytes(2);
        }
        else if(PeekRxBufByte(2)+PeekRxBufByte(3)!=0xff)//长度、长度取反
        {
            DiscardRxBufBytes(4);
        }
        else
        {
            len=PeekRxBufByte(2);
            if(len&gt;MAXCMDLEN)  //命令过长
            {
                DiscardRxBufBytes(4);
            }
            else if(GetRxBufLen()&gt;len+4)
            {
                if(PeekRxBufByte(4+len)!=0x03)//结束字符
                {
                    DiscardRxBufBytes(1);
                }
                else
                {
                    if(RxBuf[RxBufHead+4]==0x01)
                        AddPrtclDataNode(NULL,&quot;版本号查询&quot;,&amp;RxBuf[RxBufHead],len+5,0);
                    else if(RxBuf[RxBufHead+4]==0x02)
                        AddPrtclDataNode(NULL,&quot;读序列号&quot;,&amp;RxBuf[RxBufHead],len+5,0);
                    else if(RxBuf[RxBufHead+4]==0x03)
                        AddPrtclDataNode(NULL,&quot;控制继电器&quot;,&amp;RxBuf[RxBufHead],len+5,0);
                    DiscardRxBufBytes(len+5);

                }
            }
            else
            {
                break;
            }
        }
    }	//while
}



void ProcessPrtclData(void)
{
    BYTE len;
    while(GetPrtclBufLen()&gt;=7)
    {
        if(PeekPrtclBufByte(0)!=0x55)
        {
            DiscardPrtclBufBytes(1);
        }
        else if(PeekPrtclBufByte(1)!=0xaa)
        {
            DiscardPrtclBufBytes(2);
        }
        else if(PeekPrtclBufByte(2)+PeekPrtclBufByte(3)!=0xff)//长度、长度取反
        {
            DiscardPrtclBufBytes(4);
        }
        else
        {
            len=PeekPrtclBufByte(2);
            if(len&gt;MAXCMDLEN)  //命令过长
            {
                DiscardPrtclBufBytes(4);
            }
            else if(GetPrtclBufLen()&gt;len+4)
            {
                if(PeekPrtclBufByte(4+len)!=0x03)//结束字符
                {
                    DiscardPrtclBufBytes(1);
                }
                else
                {
                    EncodePrtclData();
                }
            }
            else
            {
                break;
            }
        }
    }	//while
}


//////////////////////////////////////////////////////////////////////

void RecvSerialData(char *buf,int count)
{
    int i;
    for(i=0; i&lt;count; i++)
    {
        PutRxBufByte(buf[i]);
    }
    printf(&quot;RecvSerialData,len(%d)&quot;,count);
    ProcessRxComm();

}
void AnaProtocolData(char *buf,int count)
{
    int node;
    int i;
    printf(&quot;AnaProtocolData,len(%d) &quot;,count );
    ClearPrtclBuf();
    for(i=0; i&lt;count; i++)
        PutPrtclBufByte(buf[i]);
    ProcessPrtclData();

}

void click(int btn)
{
    char s0[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x01 ,0x02 ,0x03 ,0x06 ,0x03};
    char s1[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x02 ,0x02 ,0xf3 ,0xf7 ,0x03};
    //SendHexString(s);
    RecvSerialData(s0,sizeof(s0));
    RecvSerialData(s1,sizeof(s1));
};



void main()
{
    int i;
    int btn;
    int node;
    char s[100];
    ShowProtocolWin();
    ClearVclControls();

    //ShowOutputWin(300);
    ShowVclWin(150);
    int p=GetGuiWin(1);
    for(  i=0; i&lt;2; i++)
    {
        sprintf(s,&quot;按钮:%d&quot;,i);
        btn=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,s,&quot;left&quot;,10+i*70,&quot;top&quot;,30,&quot;width&quot;,65,&quot;onclick&quot;,click,NULL);//创建按钮
    }

    ClearProtocolTree();
    click(0);
};
"/>
      <Command cmdname="协议测试命令(通过串口回环模式)" cmdType="H" cmd="[H]55 AA 04 Fb 01 02 03 07 03"/>
    </Command>
    <Command cmdname="通讯数据分析" cmdType="S" cmd="[S]new command">
      <Command cmdname="以太网数据分析" cmdType="P" cmd="[P] 

void main()
{
    ClearOutputWin();   //清除输出窗口内容
    ClearVclControls();
    ShowVclWin(160);
    ShowOutputWin(-1);
    HideLeftTools();
};


void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;
    printf(&quot;cap tcp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);
    if(dstPort!=80) return;

    if(strstr(buf,&quot;passw&quot;)!=0)
    {
        char *p=strstr(buf,&quot;passw&quot;);
        printf(&quot;find:%s&quot;,p);
    }
    else
    {
        return;
    }
}
void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;
    printf(&quot;cap udp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);
    if(dstPort!=80) return;

    if(strstr(buf,&quot;passw&quot;)!=0)
    {
        char *p=strstr(buf,&quot;passw&quot;);
        printf(&quot;find:%s&quot;,p);
    }
    else
    {
        return;
    }
}


void RecvTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;
    printf(&quot;recv tcp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);
    if(dstPort!=80) return;

    if(strstr(buf,&quot;passw&quot;)!=0)
    {
        char *p=strstr(buf,&quot;passw&quot;);
        printf(&quot;find:%s&quot;,p);
    }
    else
    {
        return;
    }
}
void RecvUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;
    printf(&quot;recv udp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);
    if(dstPort!=80) return;

    if(strstr(buf,&quot;passw&quot;)!=0)
    {
        char *p=strstr(buf,&quot;passw&quot;);
        printf(&quot;find:%s&quot;,p);
    }
    else
    {
        return;
    }
}






























"/>
      <Command cmdname="通讯数据分析" cmdType="P" cmd="[P] 

void main()
{
    ClearOutputWin();   //清除输出窗口内容
    ClearVclControls();
    ShowVclWin(160);
    ShowOutputWin(-1);
    HideLeftTools();
};


void CapSerialData(unsigned int ComNum,int RdWt,unsigned char *buf,int count)//串口捕获数据事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;
    printf(&quot;cap serial data:COM%d,RdWt:%d,%s&quot;,ComNum,RdWt,buf);

}
void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;
    printf(&quot;cap udp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);
    
}
void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;
    printf(&quot;cap tcp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);
    
}

void RecvTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;
    printf(&quot;recv tcp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);
   
}
void RecvUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件
{
    int node;
    int i,j,k;
    char s[1024];
    char tm[62],tmp[62];
    int fd;
    printf(&quot;recv udp data:%x,%d,%x,%d,%s&quot;,srcIp,srcPort,dstIp,dstPort,buf);
    
}






























"/>
      <Command cmdname="通讯数据脚本分析" cmdType="P" cmd="[P]
void main()
{
    ClearOutputWin();   //清除输出窗口内容
    ClearVclControls();
    ShowVclWin(160);
    ShowOutputWin(-1);
    HideLeftTools();
};
void RecvSerialData(unsigned char *buf,int count)//串口接收到数据
{
    printf(&quot;Recv serial data,len-%d;%s&quot;,count,buf);
}

void CapSerialData(unsigned int ComNum,int RdWt,unsigned char *buf,int count)//串口捕获数据事件
{
    printf(&quot;cap serial data:COM%d,RdWt:%d,len-%d;%s&quot;,ComNum,RdWt,count,buf);
}

void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓取到数据包
{
    printf(&quot;cap udp data:%x,%d,%x,%d,len-%d;%s&quot;,srcIp,srcPort,dstIp,dstPort,count,buf);
}

void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//TCP抓取到数据包
{
    printf(&quot;cap tcp data:%x,%d,%x,%d,len-%d;%s&quot;,srcIp,srcPort,dstIp,dstPort,count,buf);
}

void RecvTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//TCP接收到数据
{

    printf(&quot;recv tcp data:%x,%d,%x,%d,len-%d;%s&quot;,srcIp,srcPort,dstIp,dstPort,count,buf);

}
void RecvUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP接收到数据
{
    printf(&quot;recv udp data:%x,%d,%x,%d,len-%d;%s&quot;,srcIp,srcPort,dstIp,dstPort,count,buf);
}






























"/>
    </Command>
    <Command cmdname="NEW" cmdType="S" cmd="[S]new command"/>
  </Command>
  <Command cmdname="逐行发送" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
int edt1;
int cbHex;
int cbx1,cbx2;
int tmr1;
int btn0,btn1,btn2;
int curLineIdx=0;
void OnClose(int *sender)
{
    HideVclWin();
    CloseVclWin();

}
void OnStart(void *sender)
{
    char s[200];
    curLineIdx=0;
    GetProperty(cbx1,&quot;text&quot;,s,20);
    int inv=atoi(s);
    printf(&quot;%d&quot;,inv);
    SetProperty(tmr1,&quot;interval&quot;,inv);
    SetProperty(tmr1,&quot;enabled&quot;,1);
    SetProperty(btn1,&quot;enabled&quot;,0);
    SetProperty(btn2,&quot;enabled&quot;,1);

}
void OnStop()
{
    SetProperty(tmr1,&quot;enabled&quot;,0);
    SetProperty(btn1,&quot;enabled&quot;,1);
    SetProperty(btn2,&quot;enabled&quot;,0);

}
int GetLineStr(char *buf,int size,int idx)
{
    int count;
    int i;
    count=GetInputWinLineCount();
    if(idx&gt;=count) return -1;
    GetInputWinLineStr(buf,size,idx);
}
void OnTimer()
{
    char s[200],s1[202];
    int ck;
    int cr;
    ck=GetProperty(cbHex,&quot;checked&quot;,s,4);
    if(GetLineStr(s,200,curLineIdx)&lt;0)
    {
        OnStop();
        return;
    }
    SetProperty(edt1,&quot;text&quot;,s);
    printf(&quot;Send:%s&quot;,s);
    curLineIdx++;


    if(ck==1)
    {
        SendHexString(s);
    }
    else
    {
        cr=GetProperty(cbx2,&quot;itemindex&quot;,0,0);
        if(cr==0)
            sprintf(s1,&quot;%s&quot;,s);
        else if(cr==1)
            sprintf(s1,&quot;%s\r&quot;,s);
        else if(cr==2)
            sprintf(s1,&quot;%s\n&quot;,s);
        else if(cr==3)
            sprintf(s1,&quot;%s\r\n&quot;,s);
        else if(cr==4)
            sprintf(s1,&quot;%s\n\r&quot;,s);
        SendString(s1);
    }
}

void main()
{
    ClearOutputWin();   //清除输出窗口内容
    ClearCommWin();
    //CloseInputWin();
    CloseCodeWin();//
    HideLeftTools();
    HideRightTools();
    HideOutputWin();
    ClearVclControls();
    int p=GetGuiWin(0);

    btn0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,     &quot;left&quot;,230,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnClose,NULL);//创建按钮
    btn1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;开始发送&quot;, &quot;left&quot;,10,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnStart,NULL);//创建按钮
    btn2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;停止发送&quot;, &quot;left&quot;,120,&quot;top&quot;,70,&quot;width&quot;,100,&quot;height&quot;,30,&quot;onclick&quot;,OnStop,NULL);//创建按钮
    int lbl1=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;发送内容:&quot;,&quot;left&quot;,10,&quot;top&quot;,8,&quot;width&quot;,90,&quot;height&quot;,20,NULL);//创建按钮
    edt1=CreateComponentEx(p,&quot;edit&quot;,  &quot;text&quot;,   &quot;...&quot;,   &quot;left&quot;,70,&quot;top&quot;,5,&quot;width&quot;,360,&quot;height&quot;,20,&quot;enabled&quot;,0,NULL);//创建按钮
    cbHex=CreateComponentEx(p,&quot;checkbox&quot;,&quot;caption&quot;,&quot;十六进制发送&quot;,&quot;left&quot;,10,&quot;top&quot;,35,&quot;width&quot;,100,&quot;height&quot;,20,NULL);//创建按钮
    int lbl2=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;发送间隔:&quot;,&quot;left&quot;,145,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮
    cbx1=CreateComponentEx(p,&quot;combobox&quot;,&quot;text&quot;,&quot;200&quot;,&quot;left&quot;,203,&quot;top&quot;,35,&quot;width&quot;,60,&quot;height&quot;,20,NULL);//创建按钮
    int lbl3=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;毫秒&quot;,&quot;left&quot;,270,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮
    CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;换行:&quot;,&quot;left&quot;,330,&quot;top&quot;,37,&quot;width&quot;,80,&quot;height&quot;,20,NULL);//创建按钮
    cbx2=CreateComponentEx(p,&quot;combobox&quot;,&quot;left&quot;,360,&quot;top&quot;,35,&quot;width&quot;,70,&quot;height&quot;,20,&quot;style&quot;,&quot;csdropdownlist&quot;,&quot;itemindex&quot;,2,NULL);//创建按钮



    tmr1=CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,500,&quot;enabled&quot;,0,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮

    StringsAdd(cbx1,&quot;1&quot;);
    StringsAdd(cbx1,&quot;100&quot;);
    StringsAdd(cbx1,&quot;200&quot;);
    StringsAdd(cbx1,&quot;500&quot;);
    StringsAdd(cbx1,&quot;1000&quot;);
    StringsAdd(cbx2,&quot;无&quot;);
    StringsAdd(cbx2,&quot;回车&quot;);
    StringsAdd(cbx2,&quot;换行&quot;);    
    StringsAdd(cbx2,&quot;回车换行&quot;);
    StringsAdd(cbx2,&quot;换行回车&quot;);
    SetProperty(cbx2,&quot;itemindex&quot;,3);


    AutoSetVclWinSize();
}"/>
  <Command cmdname="常用数据校验算法工具" cmdType="P" cmd="[P] 

#define UINT32 unsigned int
#define UINT unsigned int
#define UCHAR unsigned char
#define UINT16 unsigned short
#define  USHORT unsigned short
#define BOOL  unsigned char
#define FALSE 0
#define TRUE 1
#define ULONG  unsigned long
//======================================================================================

//                                       校验和

//======================================================================================

/******************************************************
*函数名称:CheckSum8
*输   入:buf 要校验的数据
        len 校验数据的长
*输   出:校验和
*功   能:校验和-8
*******************************************************/
UCHAR CheckSum8(UCHAR *buf,UINT len)
{
    UINT    i=0;
    UCHAR Sum=0;

    for (i=0; i&lt;len; i++)
    {
        Sum+=*buf++;
    }

    return Sum;
}
/******************************************************
*函数名称:CheckSumSum16
*输   入:buf 要校验的数据
        len 校验数据的长
*输   出:校验和
*功   能:校验和-16
*******************************************************/
UINT16 CheckSum16(UCHAR *buf,UINT len)
{
    UINT    i=0;
    UINT16 Sum=0;

    for (i=0; i&lt;len; i++)
    {
        Sum+=*buf++;
    }

    return Sum;
}
/******************************************************
*函数名称:CheckSum32
*输   入:buf 要校验的数据
        len 校验数据的长
*输   出:校验和
*功   能:校验和-32
*******************************************************/
UINT32 CheckSum32(UCHAR *buf,UINT len)
{
    UINT    i=0;
    UINT32 Sum=0;

    for (i=0; i&lt;len; i++)
    {
        Sum+=*buf++;
    }

    return Sum;
}

/******************************************************
*函数名称:IntelHexCheckSum
*输   入:buf 要校验的数据
        len 校验数据的长
*输   出:校验和
*功   能:校验和-Intel Hex
*******************************************************/
UCHAR IntelHexCheckSum(UCHAR *buf,UINT len)
{
    UCHAR Sum;

    Sum=CheckSum8(buf,len);
    Sum=0x01+(UCHAR)(~Sum);

    return Sum;
}
/******************************************************
*函数名称:NetCheckSum
*输   入:buf 要校验的数据
        len 校验数据的长
*输   出:校验和
*功   能:校验和-TCP/IP
*******************************************************/
USHORT NetCheckSum(UCHAR *buf, UINT len)
{
    UINT   Sum=0;

    while(len--)
    {
        Sum+=*buf++;
    }

    Sum=  (Sum&gt;&gt; 16)   +   (Sum&amp;   0xffff);
    Sum+= (Sum&gt;&gt; 16);

    return   (USHORT)(~Sum);
}
/******************************************************
*函数名称:BCCVerify
*输   入:buf 要校验的数据
        len 校验数据的长
*输   出:校验值
*功   能:异或校验
*******************************************************/
UCHAR BCCVerify(UCHAR *buf,UINT len)
{
    UCHAR s=0;
    UINT  i;
    for ( i=0; i&lt;len; i++)
    {
        s = s^(*(buf+i));
    }

    return s;
}

//======================================================================================

//                                       奇偶校验

//======================================================================================

/******************************************************
*函数名称:OddParity
*输   入:buf 要校验的数据; len 校验数据的长
*输   出:校验和
*功   能:奇校验
*******************************************************/
BOOL OddParity(UCHAR *buf, UINT len)
{
    UINT  i=0,j=0;
    UCHAR d=0;
    BOOL  bParity=FALSE;

    bParity = 1;

    for(j = 0; j &lt; len; j++)
    {
        d = *(buf + j);

        for(i = 0; i &lt; 8; i++)
        {

            if((d &amp; 0x01) == 0x01)
            {
                bParity ^= 1;
            }

            d = d &gt;&gt; 1;
        }
    }

    return bParity;
}
/******************************************************
*函数名称:EvenParity
*输   入:buf 要校验的数据; len 校验数据的长
*输   出:校验和
*功   能:偶校验
*******************************************************/
BOOL EvenParity(UCHAR *buf, UINT len)
{
    return (!OddParity(buf,len));
}

//======================================================================================

//                                       循环冗余校验

//======================================================================================
/******************************************************************
*  CRC8 码表
******************************************************************/
//生成多项式：X8+X5+X4+1=0x31 ，CRC8TAB[1]=生成多项式
const UCHAR CRC8TAB[256]=
{
    //0
    0x00, 0x31, 0x62, 0x53, 0xC4, 0xF5, 0xA6, 0x97,
    0xB9, 0x88, 0xDB, 0xEA, 0x7D, 0x4C, 0x1F, 0x2E,
    //1
    0x43, 0x72, 0x21, 0x10, 0x87, 0xB6, 0xE5, 0xD4,
    0xFA, 0xCB, 0x98, 0xA9, 0x3E, 0x0F, 0x5C, 0x6D,
    //2
    0x86, 0xB7, 0xE4, 0xD5, 0x42, 0x73, 0x20, 0x11,
    0x3F, 0x0E, 0x5D, 0x6C, 0xFB, 0xCA, 0x99, 0xA8,
    //3
    0xC5, 0xF4, 0xA7, 0x96, 0x01, 0x30, 0x63, 0x52,
    0x7C, 0x4D, 0x1E, 0x2F, 0xB8, 0x89, 0xDA, 0xEB,
    //4
    0x3D, 0x0C, 0x5F, 0x6E, 0xF9, 0xC8, 0x9B, 0xAA,
    0x84, 0xB5, 0xE6, 0xD7, 0x40, 0x71, 0x22, 0x13,
    //5
    0x7E, 0x4F, 0x1C, 0x2D, 0xBA, 0x8B, 0xD8, 0xE9,
    0xC7, 0xF6, 0xA5, 0x94, 0x03, 0x32, 0x61, 0x50,
    //6
    0xBB, 0x8A, 0xD9, 0xE8, 0x7F, 0x4E, 0x1D, 0x2C,
    0x02, 0x33, 0x60, 0x51, 0xC6, 0xF7, 0xA4, 0x95,
    //7
    0xF8, 0xC9, 0x9A, 0xAB, 0x3C, 0x0D, 0x5E, 0x6F,
    0x41, 0x70, 0x23, 0x12, 0x85, 0xB4, 0xE7, 0xD6,
    //8
    0x7A, 0x4B, 0x18, 0x29, 0xBE, 0x8F, 0xDC, 0xED,
    0xC3, 0xF2, 0xA1, 0x90, 0x07, 0x36, 0x65, 0x54,
    //9
    0x39, 0x08, 0x5B, 0x6A, 0xFD, 0xCC, 0x9F, 0xAE,
    0x80, 0xB1, 0xE2, 0xD3, 0x44, 0x75, 0x26, 0x17,
    //A
    0xFC, 0xCD, 0x9E, 0xAF, 0x38, 0x09, 0x5A, 0x6B,
    0x45, 0x74, 0x27, 0x16, 0x81, 0xB0, 0xE3, 0xD2,
    //B
    0xBF, 0x8E, 0xDD, 0xEC, 0x7B, 0x4A, 0x19, 0x28,
    0x06, 0x37, 0x64, 0x55, 0xC2, 0xF3, 0xA0, 0x91,
    //C
    0x47, 0x76, 0x25, 0x14, 0x83, 0xB2, 0xE1, 0xD0,
    0xFE, 0xCF, 0x9C, 0xAD, 0x3A, 0x0B, 0x58, 0x69,
    //D
    0x04, 0x35, 0x66, 0x57, 0xC0, 0xF1, 0xA2, 0x93,
    0xBD, 0x8C, 0xDF, 0xFE, 0x79, 0x48, 0x1B, 0x2A,
    //E
    0xC1, 0xF0, 0xA3, 0x92, 0x05, 0x34, 0x67, 0x56,
    0x78, 0x49, 0x1A, 0x2B, 0xBC, 0x8D, 0xDE, 0xEF,
    //F
    0x82, 0xB3, 0xE0, 0xD1, 0x46, 0x77, 0x24, 0x15,
    0x3B, 0x0A, 0x59, 0x68, 0xFF, 0xCE, 0x9D, 0xAC
};
/******************************************************
*函数名称:CRC8
*输   入:buf 要校验的数据; len 校验数据的长
*输   出:校验值
*功   能:循环冗余校验-8
*******************************************************/
UCHAR CRC8( UCHAR *buf, UINT len)
{
    UCHAR  crc=0;

    while ( len-- )
    {
        crc = CRC8TAB[crc^*buf];

        buf++;
    }

    return crc;
}
/******************************************************
*函数名称:CRC16Default
*输   入:pszBuf  要校验的数据
        unLength 校验数据的长
*输   出:校验值
*功   能:循环冗余校验-16
         （美国标准-0x8005）
*******************************************************/
UINT16 CRC16Default(UCHAR * pszBuf, UINT unLength)
{
    UINT32 i, j;
    UINT16 CrcReg = 0xFFFF;
    UINT16 CurVal;

    for (i = 0; i &lt; unLength; i++)
    {
        CurVal = pszBuf[i] &lt;&lt; 8;

        for (j = 0; j &lt; 8; j++)
        {
            if ((short)(CrcReg ^ CurVal) &lt; 0)
                CrcReg = (CrcReg &lt;&lt; 1) ^ 0x8005;
            else
                CrcReg &lt;&lt;= 1;
            CurVal &lt;&lt;= 1;
        }
    }

    return CrcReg;
}
/******************************************************
*函数名称:CRC16CCITT
*输   入:pszBuf  要校验的数据
        unLength 校验数据的长
*输   出:校验值
*功   能:循环冗余校验-16
         （CCITT标准-0x1021）
*******************************************************/
UINT16 CRC16CCITT(UCHAR * pszBuf, UINT unLength)
{

    UINT32 i, j;
    UINT16 CrcReg = 0xFFFF;
    UINT16 CurVal;

    for (i = 0; i &lt; unLength; i++)
    {
        CurVal = pszBuf[i] &lt;&lt; 8;

        for (j = 0; j &lt; 8; j++)
        {
            if ((short)(CrcReg ^ CurVal) &lt; 0)
                CrcReg = (CrcReg &lt;&lt; 1) ^ 0x1021;
            else
                CrcReg &lt;&lt;= 1;
            CurVal &lt;&lt;= 1;
        }
    }

    return CrcReg;
}
/******************************************************
*函数名称:CRC16RTU
*输   入:pszBuf  要校验的数据
        unLength 校验数据的长
*输   出:校验值
*功   能:循环冗余校验-16
         （RTU标准-0xA001）
*******************************************************/
UINT16 CRC16RTU( UCHAR * pszBuf, UINT unLength)
{
    UINT16 CRC=0XFFFF;
    UINT32 CRC_count;

    for(CRC_count=0; CRC_count&lt;unLength; CRC_count++)
    {
        int i;

        CRC=CRC^*(pszBuf+CRC_count);

        for(i=0; i&lt;8; i++)
        {
            if(CRC&amp;1)
            {
                CRC&gt;&gt;=1;
                CRC^=0xA001;
            }
            else
            {
                CRC&gt;&gt;=1;
            }

        }
    }

    return CRC;
}


static unsigned long Reflect(unsigned long ref, char ch)
{
    unsigned long value = 0;
    int i;

    for(  i = 1; i &lt; (ch + 1); i++)
    {
        if (ref &amp; 1)
            value |= 1 &lt;&lt; (ch - i);
        ref &gt;&gt;= 1;
    }

    return value;
}
/******************************************************
*函数名称:CRC32Default
*输   入:pszBuf  要校验的数据
        unLength 校验数据的长
*输   出:校验值
*功   能:循环冗余校验-32
         （美国标准-0x04C11DB7）
*******************************************************/
ULONG CRC32Default(UCHAR *pszBuf,UINT ulLength)
{
    unsigned long Result = 0xFFFFFFFF;
    unsigned long m_Table[256];

    unsigned long ulPolynomial = 0x04C11DB7;
    int i,j;

    for ( i = 0; i &lt;= 0xFF; i++)
    {
        m_Table[i] = Reflect(i, 8) &lt;&lt; 24;
        for (  j = 0; j &lt; 8; j++)
            m_Table[i] = (m_Table[i] &lt;&lt; 1) ^ (m_Table[i] &amp; (1 &lt;&lt; 31) ? ulPolynomial : 0);
        m_Table[i] = Reflect(m_Table[i], 32);
    }

    while (ulLength--)
        Result = (Result &gt;&gt; 8) ^ m_Table[(Result &amp; 0xFF) ^ *pszBuf++];

    Result ^= 0xFFFFFFFF;

    return Result;
}

unsigned long Reflect1(unsigned long ref, char ch)
{
    unsigned long value = 0;
    int i;

    for( i = 1; i &lt; (ch + 1); i++)
    {
        if (ref &amp; 1)
            value |= 1 &lt;&lt; (ch - i);
        ref &gt;&gt;= 1;
    }

    return value;
}



//======================================================================================

//                                       循环冗余校验

//======================================================================================
/******************************************************************
*  CRC8 码表
******************************************************************/
//生??y?????X5+X4+1=0x31 ，CRC8TAB[1]=生成多项式
const UCHAR CRC8TAB[256]=
{
    //0
    0x00, 0x31, 0x62, 0x53, 0xC4, 0xF5, 0xA6, 0x97,
    0xB9, 0x88, 0xDB, 0xEA, 0x7D, 0x4C, 0x1F, 0x2E,
    //1
    0x43, 0x72, 0x21, 0x10, 0x87, 0xB6, 0xE5, 0xD4,
    0xFA, 0xCB, 0x98, 0xA9, 0x3E, 0x0F, 0x5C, 0x6D,
    //2
    0x86, 0xB7, 0xE4, 0xD5, 0x42, 0x73, 0x20, 0x11,
    0x3F, 0x0E, 0x5D, 0x6C, 0xFB, 0xCA, 0x99, 0xA8,
    //3
    0xC5, 0xF4, 0xA7, 0x96, 0x01, 0x30, 0x63, 0x52,
    0x7C, 0x4D, 0x1E, 0x2F, 0xB8, 0x89, 0xDA, 0xEB,
    //4
    0x3D, 0x0C, 0x5F, 0x6E, 0xF9, 0xC8, 0x9B, 0xAA,
    0x84, 0xB5, 0xE6, 0xD7, 0x40, 0x71, 0x22, 0x13,
    //5
    0x7E, 0x4F, 0x1C, 0x2D, 0xBA, 0x8B, 0xD8, 0xE9,
    0xC7, 0xF6, 0xA5, 0x94, 0x03, 0x32, 0x61, 0x50,
    //6
    0xBB, 0x8A, 0xD9, 0xE8, 0x7F, 0x4E, 0x1D, 0x2C,
    0x02, 0x33, 0x60, 0x51, 0xC6, 0xF7, 0xA4, 0x95,
    //7
    0xF8, 0xC9, 0x9A, 0xAB, 0x3C, 0x0D, 0x5E, 0x6F,
    0x41, 0x70, 0x23, 0x12, 0x85, 0xB4, 0xE7, 0xD6,
    //8
    0x7A, 0x4B, 0x18, 0x29, 0xBE, 0x8F, 0xDC, 0xED,
    0xC3, 0xF2, 0xA1, 0x90, 0x07, 0x36, 0x65, 0x54,
    //9
    0x39, 0x08, 0x5B, 0x6A, 0xFD, 0xCC, 0x9F, 0xAE,
    0x80, 0xB1, 0xE2, 0xD3, 0x44, 0x75, 0x26, 0x17,
    //A
    0xFC, 0xCD, 0x9E, 0xAF, 0x38, 0x09, 0x5A, 0x6B,
    0x45, 0x74, 0x27, 0x16, 0x81, 0xB0, 0xE3, 0xD2,
    //B
    0xBF, 0x8E, 0xDD, 0xEC, 0x7B, 0x4A, 0x19, 0x28,
    0x06, 0x37, 0x64, 0x55, 0xC2, 0xF3, 0xA0, 0x91,
    //C
    0x47, 0x76, 0x25, 0x14, 0x83, 0xB2, 0xE1, 0xD0,
    0xFE, 0xCF, 0x9C, 0xAD, 0x3A, 0x0B, 0x58, 0x69,
    //D
    0x04, 0x35, 0x66, 0x57, 0xC0, 0xF1, 0xA2, 0x93,
    0xBD, 0x8C, 0xDF, 0xFE, 0x79, 0x48, 0x1B, 0x2A,
    //E
    0xC1, 0xF0, 0xA3, 0x92, 0x05, 0x34, 0x67, 0x56,
    0x78, 0x49, 0x1A, 0x2B, 0xBC, 0x8D, 0xDE, 0xEF,
    //F
    0x82, 0xB3, 0xE0, 0xD1, 0x46, 0x77, 0x24, 0x15,
    0x3B, 0x0A, 0x59, 0x68, 0xFF, 0xCE, 0x9D, 0xAC
};
/******************************************************
*函数名称:CRC8
*输   入:buf 要校验的数据; len 校验数据的长
*输   出:校验值
*功   能:循环冗余校验-8
*******************************************************/
UCHAR CRC81( UCHAR *buf, UINT len)
{
    UCHAR  crc=0;

    while ( len-- )
    {
        crc = CRC8TAB[crc^*buf];

        buf++;
    }

    return crc;
}
/******************************************************
*函数名称:CRC16Default
*输   入:pszBuf  要校验的数据
        unLength 校验数据的长
*输   出:校验值
*功   能:循环冗余校验-16
         （美国标准-0x8005）
*******************************************************/
UINT16 CRC16Default1(UCHAR * pszBuf, UINT unLength)
{
    UINT32 i, j;
    UINT16 CrcReg = 0xFFFF;
    UINT16 CurVal;

    for (i = 0; i &lt; unLength; i++)
    {
        CurVal = pszBuf[i] &lt;&lt; 8;

        for (j = 0; j &lt; 8; j++)
        {
            if ((short)(CrcReg ^ CurVal) &lt; 0)
                CrcReg = (CrcReg &lt;&lt; 1) ^ 0x8005;
            else
                CrcReg &lt;&lt;= 1;
            CurVal &lt;&lt;= 1;
        }
    }

    return CrcReg;
}
/******************************************************
*函数名称:CRC16CCITT
*输   入:pszBuf  要校验的数据
        unLength 校验数据的长
*输   出:校验值
*功   能:循环冗余校验-16
         （CCITT标准-0x1021）
*******************************************************/
UINT16 CRC16CCITT1(UCHAR * pszBuf, UINT unLength)
{

    UINT32 i, j;
    UINT16 CrcReg = 0xFFFF;
    UINT16 CurVal;

    for (i = 0; i &lt; unLength; i++)
    {
        CurVal = pszBuf[i] &lt;&lt; 8;

        for (j = 0; j &lt; 8; j++)
        {
            if ((short)(CrcReg ^ CurVal) &lt; 0)
                CrcReg = (CrcReg &lt;&lt; 1) ^ 0x1021;
            else
                CrcReg &lt;&lt;= 1;
            CurVal &lt;&lt;= 1;
        }
    }

    return CrcReg;
}
/******************************************************
*函数名称:CRC16RTU
*输   入:pszBuf  要校验的数据
        unLength 校验数据的长
*输   出:校验值
*功   能:循环冗余校验-16
         （RTU标准-0xA001）
*******************************************************/
UINT16 CRC16RTU1( UCHAR * pszBuf, UINT unLength)
{
    UINT16 CRC=0XFFFF;
    UINT32 CRC_count;

    for(CRC_count=0; CRC_count&lt;unLength; CRC_count++)
    {
        int i;

        CRC=CRC^*(pszBuf+CRC_count);

        for(i=0; i&lt;8; i++)
        {
            if(CRC&amp;1)
            {
                CRC&gt;&gt;=1;
                CRC^=0xA001;
            }
            else
            {
                CRC&gt;&gt;=1;
            }

        }
    }

    return CRC;
}


static unsigned long Reflect2(unsigned long ref, char ch)
{
    unsigned long value = 0;
    int i;

    for(  i = 1; i &lt; (ch + 1); i++)
    {
        if (ref &amp; 1)
            value |= 1 &lt;&lt; (ch - i);
        ref &gt;&gt;= 1;
    }

    return value;
}
/******************************************************
*函数名称:CRC32Default
*输   入:pszBuf  要校验的数据
        unLength 校验数据的长
*输   出:校验值
*功   能:循环冗余校验-32
         （美国标准-0x04C11DB7）
*******************************************************/
ULONG CRC32Default1(UCHAR *pszBuf,ULONG ulLength)
{
    unsigned long Result = 0xFFFFFFFF;
    unsigned long m_Table[256];

    unsigned long ulPolynomial = 0x04C11DB7;
    int i,j;

    for (  i = 0; i &lt;= 0xFF; i++)
    {
        m_Table[i] = Reflect(i, 8) &lt;&lt; 24;
        for (  j = 0; j &lt; 8; j++)
            m_Table[i] = (m_Table[i] &lt;&lt; 1) ^ (m_Table[i] &amp; (1 &lt;&lt; 31) ? ulPolynomial : 0);
        m_Table[i] = Reflect(m_Table[i], 32);
    }

    while (ulLength--)
        Result = (Result &gt;&gt; 8) ^ m_Table[(Result &amp; 0xFF) ^ *pszBuf++];

    Result ^= 0xFFFFFFFF;

    return Result;
}

unsigned long Reflect3(unsigned long ref, char ch)
{
    unsigned long value = 0;
    int i;

    for(  i = 1; i &lt; (ch + 1); i++)
    {
        if (ref &amp; 1)
            value |= 1 &lt;&lt; (ch - i);
        ref &gt;&gt;= 1;
    }

    return value;
}

















///////////////////////////// 人机界面部分 ////////////////////////////////////////////
typedef struct
{
    char *name;
    int  *pFunc;
    int  resultLen;
} CHECKLIST;



CHECKLIST checkList[]=
{
    {&quot;校验和-8&quot;,    (int *)(&amp;CheckSum8),8},
    {&quot;校验和-16&quot;,   (int *)(&amp;CheckSum16),16},
    {&quot;校验和-32&quot;,   (int *)(&amp;CheckSum32),32},
    {&quot;校验和-Intel Hex&quot;,(int *)(&amp;IntelHexCheckSum),8},
    {&quot;校验和-TCP/IP&quot;,   (int *)(&amp;NetCheckSum),8},
    {&quot;异或校验&quot;,        (int *)(&amp;BCCVerify),8},
    {&quot;奇校验&quot;,(int *)(&amp;OddParity),8},
    {&quot;偶校验&quot;,(int *)(&amp;EvenParity),8},
    {&quot;循环冗余校验-8&quot;,(int *)(&amp;CRC8),8},
    {&quot;循环冗余校验-16 （CCITT标准-0x1021）&quot;,(int *)(&amp;CRC16CCITT),16},
    {&quot;循环冗余校验-16 （美国标准-0x8005）&quot;,(int *)(&amp;CRC16Default),16},
    {&quot;循环冗余校验-16 （RTU标准-0xA001）&quot;,(int *)(&amp;CRC16RTU),16},
    {&quot;循环冗余校验-32 （美国标准-0x04C11DB7）&quot;,(int *)(&amp;CRC32Default),32},
    {&quot;&quot;},

};
char  (*pCheckFunc8)(char *buf,int len);
short (*pCheckFunc16)(char *buf,int len);
int   (*pCheckFunc32)(char *buf,int len);

void OnGetSelDat();
void OnGetAllDat();
void OnCalcCheckVal();
void OnClose()
{
    HideVclWin();
    // printf(&quot;hided&quot;);
    CloseVclWin();
}

int edtSdTxt;
int edtSumTxt;
int edtSumTxt1;
int edtDatLen;
int cbx1;
void main()
{
    int i;
    ClearOutputWin(); //清除输出窗口内容
    ClearCommWin();
    CloseCodeWin();
    HideRightTools();
    Update();
    ClearVclControls();
    int p=GetGuiWin(0);
    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;校验数据:&quot;,&quot;left&quot;,10 ,&quot;top&quot;,8,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtSdTxt=CreateComponentEx(p,&quot;memo&quot;,&quot;text&quot;,&quot;12 D4 AA 8E&quot;,&quot;left&quot;,10,&quot;top&quot;,25,&quot;width&quot;,370,&quot;height&quot;,130,&quot;scrollbars&quot;,&quot;ssboth&quot;,0);
    int button0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区反选数据&quot;,&quot;left&quot;,80 ,&quot;top&quot;,3,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetSelDat,0);
    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;取发送区所有数据&quot;,&quot;left&quot;,240,&quot;top&quot;,3,&quot;width&quot;,140,&quot;height&quot;,20,&quot;OnClick&quot;,OnGetAllDat,0);
    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;校验算法:&quot;,&quot;left&quot;,400 ,&quot;top&quot;,8,&quot;width&quot;,170,&quot;height&quot;,20,0);

    cbx1=CreateComponentEx(p,&quot;combobox&quot;,&quot;left&quot;,460,&quot;top&quot;,3,&quot;width&quot;,220,&quot;height&quot;,20,&quot;style&quot;,&quot;csdropdownlist&quot;,&quot;itemindex&quot;,2,NULL);//创建按钮


    CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;十进制求和结果:&quot;,&quot;left&quot;,400,&quot;top&quot;,38,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtSumTxt=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,100+400,&quot;top&quot;,35,&quot;width&quot;,180,&quot;height&quot;,20,0);
    int lblDatLen=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;数据长度:&quot;,&quot;left&quot;, 400,&quot;top&quot;,93,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtDatLen=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,100+400,&quot;top&quot;,90,&quot;width&quot;,180,&quot;height&quot;,20,0);
    int lblSumTxt1=CreateComponentEx(p,&quot;label&quot;,&quot;caption&quot;,&quot;16进制结果(8bit):&quot;,&quot;left&quot;, 400,&quot;top&quot;,68,&quot;width&quot;,170,&quot;height&quot;,20,0);
    edtSumTxt1=CreateComponentEx(p,&quot;edit&quot;,&quot;text&quot;,&quot;&quot;,&quot;left&quot;,100+400,&quot;top&quot;,65,&quot;width&quot;,180,&quot;height&quot;,20,0);
    int button2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;计算校验&quot;,&quot;left&quot;, 400,&quot;top&quot;,125,&quot;width&quot;,130,&quot;height&quot;,30,&quot;onclick&quot;,OnCalcCheckVal,0);
    int button1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关闭&quot;,&quot;left&quot;, 550,&quot;top&quot;,125,&quot;width&quot;,130,&quot;height&quot;,30,&quot;onclick&quot;,OnClose,0);
    //ShowVclWin(150);
    //ShowOutputWin(200);
    for(i=0; i&lt;100; i++)
    {
        if(checkList[i].name[0]==0)break;
        StringsAdd(cbx1,checkList[i].name);
    }

    SetProperty(cbx1,&quot;itemindex&quot;,0);
    AutoSetVclWinSize();
}


void OnGetSelDat()
{
    char s[2000];
    GetInputWinSelText(s,2000);
    if(strlen(s)==0) return;
    SetProperty(edtSdTxt,&quot;text&quot;,s);
    OnCalcCheckVal();
}
void OnGetAllDat()
{
    char s[2000];
    GetInputWinText(s,2000);
    if(strlen(s)==0) return;
    SetProperty(edtSdTxt,&quot;text&quot;,s);
    OnCalcCheckVal();
}


int GetVal(int val)
{
    if((val&gt;=48)&amp;&amp;(val&lt;=57))
        return val-48;
    else if((val&gt;=97)&amp;&amp;(val&lt;=102))
        return val+10-97;
    else if((val&gt;=65)&amp;&amp;(val&lt;=70))
        return val+10-65;

    return 0;
}

void isDigit(int val)
{
    if((val&gt;=48)&amp;&amp;(val&lt;=57))
        return 1;
    else if((val&gt;=97)&amp;&amp;(val&lt;=102))
        return 1;
    else if((val&gt;=65)&amp;&amp;(val&lt;=70))
        return 1;
    return 0;
}

void OnCalcCheckVal()
{
    int val,val1,gotfirst;


    char s[2000];
    char buf[2000];
    GetProperty(edtSdTxt,&quot;text&quot;,s,2000);

    //s=myForm.edtSdTxt.Text;
    int i=0;
    int sum=0;
    gotfirst=0;
    int len=0;
    int ls=strlen(s);
    while(i&lt;ls)
    {
        i=i+1;
        if(gotfirst==0)
        {
            val=s[i-1];
            if(isDigit(val))
                gotfirst=1;
        }
        else
        {
            val1=s[i-1];
            if(isDigit(val1))
            {
                //sum=sum+GetVal(val)*16+GetVal(val1);
                buf[len]=GetVal(val)*16+GetVal(val1);
                len=len+1;
                gotfirst=0;
            }
            else
            {
                //sum=sum+GetVal(val);
                buf[len]=GetVal(val);
                len=len+1;
                gotfirst=0;
            }
        }
    }
    if(gotfirst==1)
    {
        sum=sum+GetVal(val);
        len=len+1;
    }
    /*sprintf(s,&quot;%d&quot;,sum);
    SetProperty(edtSumTxt,&quot;text&quot;,s);
    sprintf(s,&quot;%x&quot;,sum);
    SetProperty(edtSumTxt1,&quot;text&quot;,s);
    sprintf(s,&quot;%d&quot;,len);
    SetProperty(edtDatLen,&quot;text&quot;,s);    */

    int idx;

    idx=GetProperty(cbx1,&quot;itemindex&quot;,0,0);
    if(checkList[idx].resultLen==8)
    {
        pCheckFunc8=checkList[idx].pFunc;
        sum=pCheckFunc8(buf,len);
        //printf(&quot;name:%s,val:%x&quot;,checkList[idx].name,sum);
    }
    else if(checkList[idx].resultLen==16)
    {
        pCheckFunc16=checkList[idx].pFunc;
        sum=pCheckFunc16(buf,len);
        //printf(&quot;name:%s,val:%x&quot;,checkList[idx].name,sum);
    }
    else if(checkList[idx].resultLen==32)
    {
        pCheckFunc32=checkList[idx].pFunc;
        sum=pCheckFunc32(buf,len);
        //printf(&quot;name:%s,val:%x&quot;,checkList[idx].name,sum);
    }

    sprintf(s,&quot;%d&quot;,sum);
    SetProperty(edtSumTxt,&quot;text&quot;,s);
    sprintf(s,&quot;%02X&quot;,sum);
    SetProperty(edtSumTxt1,&quot;text&quot;,s);
    sprintf(s,&quot;%d&quot;,len);
    SetProperty(edtDatLen,&quot;text&quot;,s);

    //for(i=0; i&lt;len; i++)
    //    printf(&quot;%x&quot;,buf[i]&amp;0xff);
}"/>
  <Command cmdname="发送文件" cmdType="P" cmd="[P]#include &quot;windows.h&quot;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define BUF_LEN 1
#define LINE     15
int p;
FILE *source,*dest;
int edt1,edt2,edt3,lblSentCount,lblFileSize;

int cbHex;
int cbx1,cbx2;
int tmr1;
int btn0,btn1,btn2;

unsigned char *fileDatBuf;
int fsize=0;
int sendIdx=0;
int onePktLen;
long int filesize( FILE *fp )
{
    long int save_pos, size_of_file;

    save_pos = ftell( fp );
    fseek( fp, 0L, SEEK_END );
    size_of_file = ftell( fp );
    fseek( fp, save_pos, SEEK_SET );
    return( size_of_file );
}


void OpenFileClick(void *sender)
{
    char s[200];
    GetFileName(s,200,&quot;*.*&quot;);
    if(strlen(s)&gt;0)
    {
        SetProperty(edt1,&quot;text&quot;,s);
    }
}


void SendFileData()
{
    char  fname[255];
    unsigned char s[100],ch[3];
    int i,count,ck;
    unsigned char *tmpBuf;
    unsigned char buffer[1024] ;
    int c;

    if(fsize&gt;0)free(fileDatBuf);
    fsize=0;

    GetProperty(edt1,&quot;text&quot;,fname,200);
    ch[0]=0;
    ch[2]=0;

    
    SetProperty(lblSentCount,&quot;caption&quot;,&quot;已发送: 0 字节&quot;);
    SetProperty(lblFileSize,&quot;caption&quot;,&quot;文件大小: 0 字节&quot;);

    if( (source=fopen(fname, &quot;rb&quot; )) == NULL )
    {
        sprintf(s,&quot;文件[%s]不存在!&quot;,fname);
        ShowMessage(s);
        return;
    }
    sendIdx=0;
    if(fsize&gt;0)free(fileDatBuf);
    fsize=filesize(source);
    sprintf(s,&quot;文件大小: %d 字节&quot;,fsize);
    SetProperty(lblFileSize,&quot;caption&quot;,s);
    //printf(&quot;File size:%d&quot;,fsize);


    ck=GetProperty(cbHex,&quot;checked&quot;,s,4);
    if(ck)
    {
        tmpBuf=(unsigned char *)malloc(fsize);
        fileDatBuf=(unsigned char *)malloc(fsize );
        count=fread(tmpBuf,1,fsize,source);
        //printf(&quot;file read:%d &quot;,count );
        fsize=0;
        i=0;
        while(i&lt;count)
        {
            if(((tmpBuf[i]&gt;='0')&amp;&amp;
                    (tmpBuf[i]&lt;='9'))||
                    ((tmpBuf[i]&gt;='a')&amp;&amp;
                     (tmpBuf[i]&lt;='f'))||
                    ((tmpBuf[i]&gt;='A')&amp;&amp;
                     (tmpBuf[i]&lt;='F')))
            {
                if(ch[0]==0)
                    ch[0]=tmpBuf[i];
                else
                {
                    ch[1]=tmpBuf[i];
                    fileDatBuf[fsize]=HexStrToInt(ch);
                    fsize++;
                    ch[0]=0;

                }
            }
            i++;
        }
        free(tmpBuf);
    }
    else
    {
        fileDatBuf=malloc(fsize);
        count=fread(fileDatBuf,1,fsize,source);
        //printf(&quot;file read:%d &quot;,count );
    }



    fclose(source);
    GetProperty(cbx2,&quot;text&quot;,s,200);
    onePktLen=atoi(s);
    if(onePktLen&lt;1)onePktLen=1;
    //printf(&quot;read OK!&quot;);



}


void OnClose(int *sender)
{

    HideVclWin();
    CloseVclWin();
    ////PrintToCommWin(&quot;over&quot;);

}
void OnStart(void *sender)
{
    char s[200];
    GetProperty(cbx1,&quot;text&quot;,s,20);
    int inv=atoi(s);
    //printf(&quot;%d&quot;,inv);
    SendFileData();
    if(fsize&gt;0)
    {
        SetProperty(tmr1,&quot;interval&quot;,inv);
        SetProperty(tmr1,&quot;enabled&quot;,1);
        SetProperty(btn1,&quot;enabled&quot;,0);
        SetProperty(btn2,&quot;enabled&quot;,1);
    }
    //myForm.btnStart.Enabled=false;
    //myForm.btnStop.Enabled=true;
}
void OnStop()
{
    SetProperty(tmr1,&quot;enabled&quot;,0);
    SetProperty(btn1,&quot;enabled&quot;,1);
    SetProperty(btn2,&quot;enabled&quot;,0);

    if(fsize&gt;0)free(fileDatBuf);
    fsize=0;
}
void OnTimer()
{
    char s[200];
    int  count;


    GetProperty(edt1,&quot;text&quot;,s,200);

    if(sendIdx&lt;fsize)
    {
        if(fsize-sendIdx&gt;onePktLen)
            count=onePktLen;
        else
            count=fsize-sendIdx;
        SendBuffer(&amp;fileDatBuf[sendIdx],count);
        //printf(&quot;fsize:%d,sendidx:%d&quot;,fsize,sendIdx);
        sendIdx+=count;
        sprintf(s,&quot;已发送: %d 字节&quot;,sendIdx);
        SetProperty(lblSentCount,&quot;caption&quot;,s);
    }
    if(sendIdx&gt;=fsize)
    {

        if(fsize&gt;0)free(fileDatBuf);
        fsize=0;
        OnStop();
        ShowMessage(&quot;文件发送结束!&quot;);
    }


}


void main()
{
    ClearOutputWin();   //清除输出窗口内容
    ClearCommWin();
    //CloseInputWin();
    CloseCodeWin();//
    HideLeftTools();
    HideRightTools();
    HideOutputWin();
    ClearVclControls();
    int p=GetGuiWin(0);

    btn0=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;关    闭&quot;,     &quot;left&quot;,300,&quot;top&quot;,90,&quot;width&quot;,130,&quot;height&quot;,30,&quot;onclick&quot;,OnClose,NULL);//创建按钮
    btn1=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;开始发送&quot;, &quot;left&quot;,10,&quot;top&quot;,90,&quot;width&quot;,130,&quot;height&quot;,30,&quot;onclick&quot;,OnStart,NULL);//创建按钮
    btn2=CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;停止发送&quot;, &quot;left&quot;,155,&quot;top&quot;,90,&quot;width&quot;,130,&quot;height&quot;,30,&quot;onclick&quot;,OnStop,NULL);//创建按钮
    int lbl1=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;文件名称:&quot;,&quot;left&quot;,10,&quot;top&quot;,8,&quot;width&quot;,90,&quot;height&quot;,20,NULL);//创建按钮
    edt1=CreateComponentEx(p,&quot;edit&quot;,  &quot;text&quot;,   &quot;c:\\tmp.txt&quot;,   &quot;left&quot;,70,&quot;top&quot;,5,&quot;width&quot;,330,&quot;height&quot;,20,NULL);//创建按钮
    //btn0=
    CreateComponentEx(p,&quot;button&quot;,&quot;caption&quot;,&quot;...&quot;,     &quot;left&quot;,410,&quot;top&quot;,5,&quot;width&quot;,40,&quot;height&quot;,22,&quot;onclick&quot;,OpenFileClick,NULL);//创建按钮

    cbHex=CreateComponentEx(p,&quot;checkbox&quot;,&quot;caption&quot;,&quot;十六进制发送&quot;,&quot;left&quot;,10,&quot;top&quot;,35,&quot;width&quot;,100,&quot;height&quot;,20,NULL);//创建按钮
    int lbl2=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;发送间隔:&quot;,&quot;left&quot;,145,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮
    cbx1=CreateComponentEx(p,&quot;combobox&quot;,&quot;text&quot;,&quot;200&quot;,&quot;left&quot;,203,&quot;top&quot;,35,&quot;width&quot;,60,&quot;height&quot;,20,NULL);//创建按钮
    int lbl3=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;毫秒&quot;,&quot;left&quot;,270,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮

    int lbl2=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;每包长度:&quot;,&quot;left&quot;,313,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮
    cbx2=CreateComponentEx(p,&quot;combobox&quot;,&quot;text&quot;,&quot;128&quot;,&quot;left&quot;,370,&quot;top&quot;,35,&quot;width&quot;,50,&quot;height&quot;,20,NULL);//创建按钮
    int lbl3=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;字节&quot;,&quot;left&quot;,425,&quot;top&quot;,37,&quot;width&quot;,70,&quot;height&quot;,20,NULL);//创建按钮

    lblFileSize=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;文件大小: 0 字节&quot;,&quot;left&quot;,10,&quot;top&quot;,67,&quot;width&quot;,120,&quot;height&quot;,20,NULL);//创建按钮
    lblSentCount=CreateComponentEx(p,&quot;label&quot;, &quot;caption&quot;,&quot;已发送: 0 字节&quot;,&quot;left&quot;,310,&quot;top&quot;,67,&quot;width&quot;,120,&quot;height&quot;,20,NULL);//创建按钮
    tmr1=CreateComponentEx(p,&quot;timer&quot;,&quot;interval&quot;,500,&quot;enabled&quot;,0,&quot;ontimer&quot;,OnTimer,NULL);//创建按钮
    //int img=CreateComponentEx(p,&quot;image&quot;,&quot;left&quot;,20,&quot;top&quot;,170,&quot;width&quot;,100,&quot;height&quot;,130,NULL);//创建按钮
    //int canvas=GetProperty(img,&quot;canvas&quot;,0,0);
    //LineTo(canvas,100,100);
    StringsAdd(cbx1,&quot;1&quot;);
    StringsAdd(cbx1,&quot;100&quot;);
    StringsAdd(cbx1,&quot;200&quot;);
    StringsAdd(cbx1,&quot;500&quot;);
    StringsAdd(cbx1,&quot;1000&quot;);
    StringsAdd(cbx2,&quot;1&quot;);
    StringsAdd(cbx2,&quot;16&quot;);
    StringsAdd(cbx2,&quot;32&quot;);
    StringsAdd(cbx2,&quot;64&quot;);
    StringsAdd(cbx2,&quot;128&quot;);
    StringsAdd(cbx2,&quot;512&quot;);
    StringsAdd(cbx2,&quot;1024&quot;);
    StringsAdd(cbx2,&quot;2048&quot;);


    //ShowVclWin(120);
    AutoSetVclWinSize();

}"/>
  <Command cmdname="RS485_18B20" cmdType="S" cmd="[S]读取18b20指令集">
    <Command cmdname="读取温度值" cmdType="H" cmd="[H]01 03 00 00 00 01 84 0A"/>
    <Command cmdname="读取设备地址" cmdType="H" cmd="[H]00 03 00 01 00 01 D4 1B"/>
    <Command cmdname="读取温度更新速度" cmdType="H" cmd="[H]01 03 00 02 00 01 25 CA "/>
    <Command cmdname="读取波特率" cmdType="H" cmd="[H]01 03 00 03 00 01 74 0A"/>
    <Command cmdname="更改设备地址" cmdType="H" cmd="[H]00 06 00 01 00 01 18 1B"/>
    <Command cmdname="更改温度更新速度" cmdType="H" cmd="[H]01 06 00 02 00 05 E8 09"/>
    <Command cmdname="更改波特率" cmdType="H" cmd="[H]01 06 00 03 00 05 B9 C9"/>
  </Command>
  <Command cmdname="KAV2模块" cmdType="S" cmd="[S]读取">
    <Command cmdname="读取通道值" cmdType="H" cmd="[H]01 03 06 B6 00 01 65 64"/>
    <Command cmdname="读取通道值1" cmdType="H" cmd="[H]09 03 06 B4 00 01 C5 EC"/>
    <Command cmdname="读取通道值2" cmdType="H" cmd="[H]09 03 06 B5 00 01 94 2C"/>
    <Command cmdname="读取模块地址" cmdType="H" cmd="[H]09 03 00 0C 00 01 45 41"/>
    <Command cmdname="设置模块地址" cmdType="H" cmd="[H]01 10 00 0C 00 01 01 09 10 51"/>
  </Command>
  <Command cmdname="RS485_水分传感器" cmdType="S" cmd="[S]读取">
    <Command cmdname="读取水分值" cmdType="H" cmd="[H]03 04 00 01 00 01 61 E8"/>
    <Command cmdname="读取传感器地址" cmdType="H" cmd="[H]ff 04 00 00 00 01 24 14"/>
    <Command cmdname="修改传感器地址为2" cmdType="H" cmd="[H]01 4a 00 00 02 00 99 64"/>
    <Command cmdname="修改传感器地址为3" cmdType="H" cmd="[H]01 4a 00 00 03 00 98 F4"/>
    <Command cmdname="修改传感器地址为4" cmdType="H" cmd="[H]01 4a 00 00 04 00 9a c4"/>
    <Command cmdname="修改传感器地址为5" cmdType="H" cmd="[H]01 4a 00 00 05 00 9B 54"/>
    <Command cmdname="修改传感器地址为6" cmdType="H" cmd="[H]01 4a 00 00 06 00 9B A4"/>
    <Command cmdname="修改传感器地址为7" cmdType="H" cmd="[H]01 4a 00 00 07 00 9a 34"/>
    <Command cmdname="修改传感器地址为8" cmdType="H" cmd="[H]01 4a 00 00 08 00 9F C4"/>
  </Command>
  <Command cmdname="ERROR" cmdType="S" cmd="[S]ERROR">
    <Command cmdname="打开风扇" cmdType="H" cmd="[H]21 01 09 01 5A 40 2C 66 24 31 A8"/>
    <Command cmdname="关闭风扇" cmdType="H" cmd="[H]21 01 09 01 5A 40 2C 66 24 30 AF"/>
  </Command>
  <Command cmdname="消息队列命令" cmdType="S" cmd="[S]AT+CFUN=0
">
    <Command cmdname="openled6" cmdType="S" cmd="[S]openled6"/>
  </Command>
  <Command cmdname="ERROR" cmdType="S" cmd="[S]ERROR">
    <Command cmdname="AT+CFUN=0" cmdType="S" cmd="[S]AT+CFUN=0
"/>
    <Command cmdname="AT+CGSN=1" cmdType="S" cmd="[S]AT+CGSN=1
"/>
    <Command cmdname="AT+NRB" cmdType="S" cmd="[S]AT+NRB
"/>
    <Command cmdname="AT+NCDP=180.101.147.115,5683" cmdType="S" cmd="[S]AT+NCDP=180.101.147.115,5683
"/>
    <Command cmdname="AT+CFUN=1" cmdType="S" cmd="[S]AT+CFUN=1
"/>
    <Command cmdname="AT+CIMI" cmdType="S" cmd="[S]AT+CIMI
"/>
    <Command cmdname="AT+CMEE=1" cmdType="S" cmd="[S]AT+CMEE=1
"/>
    <Command cmdname="AT+CGDCONT=1,\&quot;IP\&quot;,\&quot;ctnet\&quot;" cmdType="S" cmd="[S]AT+CGDCONT=1,&quot;IP&quot;,&quot;ctnb&quot;
"/>
    <Command cmdname="AT+NNMI=2" cmdType="S" cmd="[S]AT+NNMI=2
"/>
    <Command cmdname="AT+CGATT=1" cmdType="S" cmd="[S]AT+CGATT=1
"/>
    <Command cmdname="AT+CSCON=1" cmdType="S" cmd="[S]AT+CSCON=1
"/>
    <Command cmdname="AT+CGPADDR=1" cmdType="S" cmd="[S]AT+CGPADDR
"/>
    <Command cmdname="AT+NUESTATS" cmdType="S" cmd="[S]AT+NUESTATS
"/>
    <Command cmdname="CMDSTR_NOUSE" cmdType="S" cmd="[S]CMDSTR_NOUSE
"/>
    <Command cmdname="AT+NBAND？" cmdType="S" cmd="[S]AT+NBAND?"/>
    <Command cmdname="AT+NSOCR=DGRAM,17,8989,1" cmdType="S" cmd="[S]AT+NSOCR=DGRAM,17,8989,1"/>
    <Command cmdname="COAP协议" cmdType="S" cmd="[S]AT+NMGS=2,0A0A"/>
  </Command>
  <Command cmdname="ERROR" cmdType="S" cmd="[S]ERROR">
    <Command cmdname="设置系统时间" cmdType="S" cmd="[S]realtime:2019-2-20,19:47:00"/>
    <Command cmdname="设置闹钟" cmdType="S" cmd="[S]alarmtime:19:55:00,1,1"/>
  </Command>
</root>
