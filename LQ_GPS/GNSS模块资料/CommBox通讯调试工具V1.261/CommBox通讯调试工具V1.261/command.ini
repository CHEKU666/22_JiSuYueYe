  <?xml version="1.0" encoding="GB2312" ?> 
- <root cmdName="通讯工具命令表">
  <Command cmdname="超级终端模式" cmdType="P" cmd="[P]void main() { SetLayoutMode(0); ClearOutputWin(); //清除输出窗口内容 ClearCommWin(); CloseInputWin(); ShowTerminalWin(); HideLeftTools(); HideRightTools(); ClearVclControls(); HideVclWin(); }" /> 
  <Command cmdname="编程布局" cmdType="P" cmd="[P]void main() { SetLayoutMode(1); CloseOutputWin(); HideLeftTools(); HideRightTools(); HideVclWin(); }" /> 
  <Command cmdname="默认布局" cmdType="P" cmd="[P]void main() { //ClearOutput(); //清除输出窗口内容 //ClearCommWin(); SetLayoutMode(0); OpenInputWin(); HideTerminalWin(); ClearVclControls(); HideVclWin(); HideLeftTools(); HideRightTools(); }" /> 
  <Command cmdname="计算器" cmdType="P" cmd="[P]void main() { WinExec("calc.exe"); }" /> 
- <Command cmdname="Windows系统工具" cmdType="S" cmd="[S]new command">
  <Command cmdname="计算器" cmdType="P" cmd="[P]void main() { WinExec("calc.exe"); }" /> 
  <Command cmdname="记事本" cmdType="P" cmd="[P]void main() { WinExec("notepad.exe"); }" /> 
  <Command cmdname="命令行" cmdType="P" cmd="[P]void main() { WinExec("cmd.exe"); }" /> 
  <Command cmdname="画图" cmdType="P" cmd="[P] void main() { WinExec("mspaint.exe"); }" /> 
  <Command cmdname="Windows 超级终端:COM]" cmdType="P" cmd="[P] void main() { WinExec("C:\\Program Files\\Windows NT\\hypertrm.exe C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\附件\\通讯\\超级终端\\com 1"); }" /> 
  </Command>
- <Command cmdname="实用工具" cmdType="S" cmd="[S]数据发送区">
  <Command cmdname="超级终端" cmdType="P" cmd="[P]void main() { ClearOutputWin(); //清除输出窗口内容 ClearCommWin(); CloseInputWin(); ShowTerminalWin(); HideLeftTools(); HideRightTools(); ClearVclControls(); HideVclWin(); }" /> 
  <Command cmdname="定时发送" cmdType="P" cmd="[P]#include "windows.h" int edt1; int cbHex; int cbx1; int tmr1; int btn0,btn1,btn2; void OnClose(int *sender) { HideVclWin(); CloseVclWin(); ////PrintToCommWin("over"); } void OnStart(void *sender) { char s[200]; GetProperty(cbx1,"text",s,20); int inv=atoi(s); printf("%d",inv); SetProperty(tmr1,"interval",inv); SetProperty(tmr1,"enabled",1); SetProperty(btn1,"enabled",0); SetProperty(btn2,"enabled",1); //myForm.btnStart.Enabled=false; //myForm.btnStop.Enabled=true; } void OnStop() { SetProperty(tmr1,"enabled",0); SetProperty(btn1,"enabled",1); SetProperty(btn2,"enabled",0); } void OnTimer() { char s[200]; int ck; //PrintToCommWin("abc"); ck=GetProperty(cbHex,"checked",s,4); //printf("checked:%s",s); GetProperty(edt1,"text",s,200); if(ck==1) SendHexString(s); else SendString(s); } void main() { ClearOutputWin(); //清除输出窗口内容 ClearCommWin(); //CloseInputWin(); CloseCodeWin();// HideLeftTools(); HideRightTools(); HideOutputWin(); ClearVclControls(); int p=GetGuiWin(0); btn0=CreateComponentEx(p,"button","caption","关闭", "left",230,"top",70,"width",100,"height",30,"onclick",OnClose,NULL);//创建按钮 btn1=CreateComponentEx(p,"button","caption","开始发送", "left",10,"top",70,"width",100,"height",30,"onclick",OnStart,NULL);//创建按钮 btn2=CreateComponentEx(p,"button","caption","停止发送", "left",120,"top",70,"width",100,"height",30,"onclick",OnStop,NULL);//创建按钮 int lbl1=CreateComponentEx(p,"label", "caption","发送内容:","left",10,"top",8,"width",90,"height",20,NULL);//创建按钮 edt1=CreateComponentEx(p,"edit", "text", "123456", "left",70,"top",5,"width",260,"height",20,NULL);//创建按钮 cbHex=CreateComponentEx(p,"checkbox","caption","十六进制发送","left",10,"top",35,"width",100,"height",20,NULL);//创建按钮 int lbl2=CreateComponentEx(p,"label", "caption","发送间隔:","left",145,"top",37,"width",70,"height",20,NULL);//创建按钮 cbx1=CreateComponentEx(p,"combobox","text","200","left",203,"top",35,"width",60,"height",20,NULL);//创建按钮 int lbl3=CreateComponentEx(p,"label", "caption","毫秒","left",270,"top",37,"width",70,"height",20,NULL);//创建按钮 tmr1=CreateComponentEx(p,"timer","interval",500,"enabled",0,"ontimer",OnTimer,NULL);//创建按钮 //int img=CreateComponentEx(p,"image","left",20,"top",170,"width",100,"height",130,NULL);//创建按钮 //int canvas=GetProperty(img,"canvas",0,0); //LineTo(canvas,100,100); StringsAdd(cbx1,"1"); StringsAdd(cbx1,"100"); StringsAdd(cbx1,"200"); StringsAdd(cbx1,"500"); StringsAdd(cbx1,"1000"); //ShowVclWin(120); AutoSetVclWinSize(); }" /> 
  <Command cmdname="数据求和" cmdType="P" cmd="[P] void OnGetSelDat(); void OnGetAllDat(); void OnSum(); void OnClose() { HideVclWin(); // printf("hided"); CloseVclWin(); } int edtSdTxt; int edtSumTxt; int edtSumTxt1; int edtDatLen; void main() { ClearOutputWin(); //清除输出窗口内容 ClearCommWin(); CloseCodeWin(); HideRightTools(); Update(); ClearVclControls(); int p=GetGuiWin(0); CreateComponentEx(p,"label","caption","十六进制求和数据:","left",10,"top",8,"width",170,"height",20,0); edtSdTxt=CreateComponentEx(p,"edit","text","12 D4 AA 8E","left",120,"top",5,"width",270,"height",20,0); int button0=CreateComponentEx(p,"button","caption","取发送区反选数据","left",400,"top",5,"width",140,"height",20,"OnClick",OnGetSelDat,0); int button1=CreateComponentEx(p,"button","caption","取发送区所有数据","left",400,"top",38,"width",140,"height",20,"OnClick",OnGetAllDat,0); CreateComponentEx(p,"label","caption","十进制求和结果:","left",10,"top",38,"width",170,"height",20,0); edtSumTxt=CreateComponentEx(p,"edit","text","","left",120,"top",35,"width",70,"height",20,0); int lblDatLen=CreateComponentEx(p,"label","caption","数据长度:","left",10,"top",60,"width",170,"height",20,0); edtDatLen=CreateComponentEx(p,"edit","text","","left",120,"top",60,"width",70,"height",20,0); int lblSumTxt1=CreateComponentEx(p,"label","caption","16进制结果(8bit):","left",200,"top",38,"width",170,"height",20,0); edtSumTxt1=CreateComponentEx(p,"edit","text","","left",300,"top",35,"width",70,"height",20,0); int button2=CreateComponentEx(p,"button","caption","求和","left",10,"top",85,"width",240,"height",30,"onclick",OnSum,0); int button1=CreateComponentEx(p,"button","caption","关闭","left",260,"top",85,"width",240,"height",30,"onclick",OnClose,0); //ShowVclWin(150); //ShowOutputWin(200); AutoSetVclWinSize(); } void OnGetSelDat() { char s[2000]; GetInputWinSelText(s,2000); if(strlen(s)==0) return; SetProperty(edtSdTxt,"text",s); OnSum(); } void OnGetAllDat() { char s[2000]; GetInputWinText(s,2000); if(strlen(s)==0) return; SetProperty(edtSdTxt,"text",s); OnSum(); } int GetVal(int val) { if((val>=48)&&(val<=57)) return val-48; else if((val>=97)&&(val<=102)) return val+10-97; else if((val>=65)&&(val<=70)) return val+10-65; return 0; } void isDigit(int val) { if((val>=48)&&(val<=57)) return 1; else if((val>=97)&&(val<=102)) return 1; else if((val>=65)&&(val<=70)) return 1; return 0; } void OnSum() { int val,val1,gotfirst; char s[2000]; GetProperty(edtSdTxt,"text",s,2000); //s=myForm.edtSdTxt.Text; int i=0; int sum=0; gotfirst=0; int len=0; int ls=strlen(s); while(i<ls) { i=i+1; if(gotfirst==0) { val=s[i-1]; if(isDigit(val)) gotfirst=1; } else { val1=s[i-1]; if(isDigit(val1)) { sum=sum+GetVal(val)*16+GetVal(val1); len=len+1; gotfirst=0; } else { sum=sum+GetVal(val); len=len+1; gotfirst=0; } } } if(gotfirst==1) { sum=sum+GetVal(val); len=len+1; } sprintf(s,"%d",sum); SetProperty(edtSumTxt,"text",s); sprintf(s,"%x",sum); SetProperty(edtSumTxt1,"text",s); sprintf(s,"%d",len); SetProperty(edtDatLen,"text",s); }" /> 
  <Command cmdname="数据异或" cmdType="P" cmd="[P] void OnGetSelDat(); void OnGetAllDat(); void OnSum(); void OnClose() { HideVclWin(); // printf("hided"); CloseVclWin(); } int edtSdTxt; int edtSumTxt; int edtSumTxt1; int edtDatLen; void main() { ClearOutputWin(); //清除输出窗口内容 ClearCommWin(); CloseCodeWin(); HideRightTools(); Update(); ClearVclControls(); int p=GetGuiWin(); CreateComponentEx(p,"label","caption","十六进制求和数据:","left",10,"top",8,"width",170,"height",20,0); edtSdTxt=CreateComponentEx(p,"edit","text","12 D4 AA 8E","left",120,"top",5,"width",270,"height",20,0); int button0=CreateComponentEx(p,"button","caption","取发送区反选数据","left",400,"top",5,"width",140,"height",20,"OnClick",OnGetSelDat,0); int button1=CreateComponentEx(p,"button","caption","取发送区所有数据","left",400,"top",38,"width",140,"height",20,"OnClick",OnGetAllDat,0); CreateComponentEx(p,"label","caption","十进制求和结果:","left",10,"top",38,"width",170,"height",20,0); edtSumTxt=CreateComponentEx(p,"edit","text","","left",120,"top",35,"width",70,"height",20,0); int lblDatLen=CreateComponentEx(p,"label","caption","数据长度:","left",10,"top",60,"width",170,"height",20,0); edtDatLen=CreateComponentEx(p,"edit","text","","left",120,"top",60,"width",70,"height",20,0); int lblSumTxt1=CreateComponentEx(p,"label","caption","16进制结果(8bit):","left",200,"top",38,"width",170,"height",20,0); edtSumTxt1=CreateComponentEx(p,"edit","text","","left",300,"top",35,"width",70,"height",20,0); int button2=CreateComponentEx(p,"button","caption","求和","left",10,"top",85,"width",240,"height",30,"onclick",OnSum,0); int button1=CreateComponentEx(p,"button","caption","关闭","left",260,"top",85,"width",240,"height",30,"onclick",OnClose,0); AutoSetVclWinSize(); } char s[2000]; void OnGetSelDat() { GetInputWinSelText(s,2000); if(strlen(s)==0) return; SetProperty(edtSdTxt,"text",s); OnSum(); } void OnGetAllDat() { //char s[2000]; GetInputWinText(s,2000); if(strlen(s)==0) return; SetProperty(edtSdTxt,"text",s); OnSum(); } int GetVal(int val) { if((val>=48)&&(val<=57)) return val-48; else if((val>=97)&&(val<=102)) return val+10-97; else if((val>=65)&&(val<=70)) return val+10-65; return 0; } void isDigit(int val) { if((val>=48)&&(val<=57)) return 1; else if((val>=97)&&(val<=102)) return 1; else if((val>=65)&&(val<=70)) return 1; return 0; } void OnSum() { int val,val1,gotfirst; //char s[2000]; GetProperty(edtSdTxt,"text",s,2000); // s=myForm.edtSdTxt.Text; int i=0; int sum=0; gotfirst=0; int len=0; int ls=strlen(s); while(i<ls) { i=i+1; if(gotfirst==0) { val=s[i-1]; if(isDigit(val)) gotfirst=1; } else { val1=s[i-1]; if(isDigit(val1)) { sum=sum^(GetVal(val)*16)^GetVal(val1); len=len+1; gotfirst=0; } else { sum=sum^GetVal(val); len=len+1; gotfirst=0; } } } if(gotfirst==1) { sum=sum^GetVal(val); len=len+1; } sprintf(s,"%d",sum); SetProperty(edtSumTxt,"text",s); sprintf(s,"%x",sum); SetProperty(edtSumTxt1,"text",s); sprintf(s,"%d",len); SetProperty(edtDatLen,"text",s); }" /> 
  <Command cmdname="Ctrl+C" cmdType="H" cmd="[H]03" /> 
  <Command cmdname="ZModem发送文件" cmdType="P" cmd="[P]void main() { PrintToCommWin("Start transmit..."); ZModemSendFile("C:\\crash.txt",1); PrintToCommWin("Transmit over."); }" /> 
  <Command cmdname="Bin2Hex" cmdType="P" cmd="[P]#include <stdio.h> #include <string.h> #define BUF_LEN 1 #define LINE 31 int p; int edt1,edt2,edt3; void Trans(); long int filesize( FILE *fp ) { long int save_pos, size_of_file; save_pos = ftell( fp ); fseek( fp, 0L, SEEK_END ); size_of_file = ftell( fp ); fseek( fp, save_pos, SEEK_SET ); return( size_of_file ); } void Upper_chars(char *buffer) { unsigned int c; for (c=0; c <= strlen(buffer)-1; c++) *(buffer+c)=toupper( *(buffer+c) ); } void OpenFileClick(void *sender) { char s[200]; GetFileName(s,200,"*.*"); if(strlen(s)>0) { SetProperty(edt1,"text",s); } } void OpenFileClick1(void *sender) { char s[200]; GetFileName(s,200); if(strlen(s)>0) { SetProperty(edt2,"text",s); } } void CloseClick(void *Sender) { ClearOutputWin(); //清除输出窗口内容 HideVclWin(); CloseVclWin(); CloseForm(p); } void ViewC() { char s[200],s1[200]; GetProperty(edt2,"text",s,200); sprintf(s1,"notepad.exe %s",s); WinExec(s1); } void CreateGui() { CloseCodeWin(); ClearVclControls(); int GuiMode=2; if((GuiMode==0)||(GuiMode==1)) p=GetGuiWin(GuiMode); else p=CreateComponentEx(0,"form","caption","Bin2Hex工具","Width",570,"height",150,"BorderIcons","[biSystemMenu]","position","poMainFormCenter","formstyle","fsstayontop", "visible",1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] int pnl =p; //CreateComponentEx(p,"panel","caption","","left",2,"top",2,"width",610,"height",160,NULL); //int txt1= CreateComponentEx(pnl,"label","caption"," Bin2Hex工具","left",30,"top",10,"width",350,"color",0xff00ff,NULL); int txt2= CreateComponentEx(pnl,"label","caption","二进制文件名称：","left",10,"top",40-20,"width",90,NULL); edt1= CreateComponentEx(pnl,"edit", "text","c:\\boot.ini","left",105,"top",38-20,"width",345,NULL); int txt3= CreateComponentEx(pnl,"label","caption","转换到文件名称：","left",10,"top",68-20,"width",90,NULL); edt2= CreateComponentEx(pnl,"edit", "text","c:\\tmp.txt","left",105,"top",65-20,"width",345,NULL); int btn1= CreateComponentEx(pnl,"button","caption","...","left",465,"top",36-20,"width",65,"onclick",OpenFileClick,NULL); int btn2= CreateComponentEx(pnl,"button","caption","...","left",465,"top",63-20,"width",65,"onclick",OpenFileClick1,NULL); int btn3= CreateComponentEx(pnl,"button","caption","转 换" ,"left",75,"top",93+28-40,"width",120,"onclick",Trans,NULL); int btn4= CreateComponentEx(pnl,"button","caption","查看转换文件","left",215,"top",93+28-40,"width",120,"onclick",ViewC,NULL); int btn5= CreateComponentEx(pnl,"button","caption","退 出" ,"left",375,"top",93+28-40,"width",120,"onclick",CloseClick,NULL); } void main() { CreateGui(); } void Trans() { char argv[4][255]; char s[100]; FILE *source,*dest; unsigned char buffer[BUF_LEN], Dummy[20]; int c; GetProperty(edt1,"text",argv[1],200); GetProperty(edt2,"text",argv[2],200); GetProperty(edt3,"text",argv[3],200); //strcpy(argv[3],"data"); if( (source=fopen( argv[1], "rb" )) == NULL ) { printf("ERROR : I can't find source file %s\n",argv[1]); sprintf(s,"二进制文件[%s]不存在!",argv[1]); ShowMessage(s); return; } strcpy(Dummy,argv[2]); if( (dest=fopen( Dummy, "wb+" )) == NULL ) { sprintf(s,"目标文件[%s]无法创建!",argv[1]); ShowMessage(s); printf("ERROR : I can't open destination file %s\n",Dummy); return; } strcpy(Dummy,argv[3]); Upper_chars(Dummy); /* lower to upper chars */ strcat(Dummy,"_LEN"); /* add the suffix _LEN to the struct name */ //fprintf( dest, "\r\n//--------通讯调试工具1.255---------\r\n\r\n", Dummy, filesize(source) ); //fprintf( dest, "#define %s %d\r\n", Dummy, filesize(source) ); //fprintf( dest, "static unsigned char %s[]=\r\n{\r\n", argv[3] ); if( ferror( dest ) ) { printf( "ERROR writing on target file: %s\n",argv[2] ); return; } do { //fprintf(dest,""); for ( c=0; ((c <= LINE) && (! feof( source ) )) ; c++) { fread(buffer,1,1,source); if (!feof( source ) && c != 0) { //fprintf(dest,""); //printf(","); } if (! feof( source ) ) { fprintf(dest," %02x",*buffer); //printf("0x%02x",*buffer); } } fprintf(dest,"\r\n"); } while( ! feof( source ) ); // fprintf(dest,"};\r\n\r\n"); fclose(dest); fclose(source); printf("OK!"); ShowMessage("转换完成! "); }" /> 
  <Command cmdname="HexDump" cmdType="P" cmd="[P]#include <stdio.h> #include <string.h> #define BUF_LEN 1 #define LINE 15 int p; int edt1,edt2,edt3; void Trans(); long int filesize( FILE *fp ) { long int save_pos, size_of_file; save_pos = ftell( fp ); fseek( fp, 0L, SEEK_END ); size_of_file = ftell( fp ); fseek( fp, save_pos, SEEK_SET ); return( size_of_file ); } void Upper_chars(char *buffer) { unsigned int c; for (c=0; c <= strlen(buffer)-1; c++) *(buffer+c)=toupper( *(buffer+c) ); } void OpenFileClick(void *sender) { char s[200]; GetFileName(s,200,"*.*"); if(strlen(s)>0) SetProperty(edt1,"text",s); } void OpenFileClick1(void *sender) { char s[200]; GetFileName(s,200,"*.txt"); if(strlen(s)>0) SetProperty(edt2,"text",s); } void CloseClick(void *Sender) { ClearOutputWin(); //清除输出窗口内容 HideVclWin(); CloseVclWin(); CloseForm(p); } void ViewC() { char s[200],s1[200]; GetProperty(edt2,"text",s,200); sprintf(s1,"notepad.exe %s",s); WinExec(s1); } void CreateGui() { CloseCodeWin(); ClearVclControls(); int GuiMode=2; if((GuiMode==0)||(GuiMode==1)) p=GetGuiWin(GuiMode); else p=CreateComponentEx(0,"form","caption","HexDump工具","Width",570,"height",150,"BorderIcons","[biSystemMenu]","position","poMainFormCenter","formstyle","fsstayontop", "visible",1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] int pnl =p; int txt2= CreateComponentEx(pnl,"label","caption","二进制文件名称：","left",10,"top",40-20,"width",90,NULL); edt1= CreateComponentEx(pnl,"edit", "text","c:\\boot.ini","left",105,"top",38-20,"width",345,NULL); int txt3= CreateComponentEx(pnl,"label","caption","转换到文件名称：","left",10,"top",68-20,"width",90,NULL); edt2= CreateComponentEx(pnl,"edit", "text","c:\\tmp.txt","left",105,"top",65-20,"width",345,NULL); int btn1= CreateComponentEx(pnl,"button","caption","...","left",465,"top",36-20,"width",65,"onclick",OpenFileClick,NULL); int btn2= CreateComponentEx(pnl,"button","caption","...","left",465,"top",63-20,"width",65,"onclick",OpenFileClick1,NULL); int btn3= CreateComponentEx(pnl,"button","caption","转 换" ,"left",75,"top",93+28-40,"width",120,"onclick",Trans,NULL); int btn4= CreateComponentEx(pnl,"button","caption","查看转换文件","left",215,"top",93+28-40,"width",120,"onclick",ViewC,NULL); int btn5= CreateComponentEx(pnl,"button","caption","退 出" ,"left",375,"top",93+28-40,"width",120,"onclick",CloseClick,NULL); } void main() { CreateGui(); } void Trans() { char argv[4][255]; char s[100]; FILE *source,*dest; unsigned char buffer[BUF_LEN], Dummy[20]; int c,i; char fname[255]; char ext[255]; int count=0; unsigned char buf[20]; GetProperty(edt1,"text",argv[1],200); GetProperty(edt2,"text",argv[2],200); if( (source=fopen( argv[1], "rb" )) == NULL ) { sprintf(s,"二进制文件[%s]不存在!",argv[1]); ShowMessage(s); return; } strcpy(Dummy,argv[2]); if( (dest=fopen( Dummy, "wb+" )) == NULL ) { sprintf(s,"目标文件[%s]无法创建!",argv[1]); ShowMessage(s); return; } _splitpath(argv[1], NULL,NULL,fname,ext); fprintf( dest, "CommBox V1.26\r\nHEXDUMP 文件名称：%s%s,文件大小：%d Bytes\r\n", fname,ext, filesize(source) ); fprintf( dest, "------------------------------------------------------------------------------\r\n"); fprintf( dest, "地址(HEX) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0123456789ABCDEF\r\n"); fprintf( dest, "==============================================================================\r\n"); if( ferror( dest ) ) { printf( "ERROR writing on target file: %s\n",argv[2] ); return; } do { fprintf( dest, "%08X",count); count+=LINE; for ( c=0; ((c <= LINE) && (! feof( source ) )) ; c++) { fread(buffer,1,1,source); buf[c]=buffer[0]; if (! feof( source ) ) { if(c%4==0)fprintf(dest," "); fprintf(dest," %02x",*buffer); } else break; } if ( feof( source ) ) for(i=c; i<=LINE; i++) { if(i%4==0)fprintf(dest," "); fprintf(dest," "); } fprintf(dest," "); char xshz=1; i=0; while(i<c) { if(!xshz) { if((buf[i]>0x20)&&(buf[i]<0x80)) fprintf( dest, "%c",buf[i]); else fprintf( dest, "."); } else { unsigned char hz=0; if(i<c-1) if((buf[i]>=0xa1)&&(buf[i]<=0xfe)) if((buf[i+1]>=0xa1)&&(buf[i+1]<=0xfe)) hz=1; if(hz) { char tmp[3]; tmp[0]=buf[i]; tmp[1]=buf[i+1]; tmp[2]=0; fprintf( dest, "%s",tmp); i++; } else { if((buf[i]>0x20)&&(buf[i]<0x80)) fprintf( dest, "%c",buf[i]); else fprintf( dest, "."); } } i++; } fprintf(dest,"\r\n"); } while( ! feof( source ) ); fclose(dest); fclose(source); printf("OK!"); ShowMessage("转换完成! "); }" /> 
  <Command cmdname="二进制转C(bin2c)" cmdType="P" cmd="[P]#include <stdio.h> #include <string.h> #define BUF_LEN 1 #define LINE 15 int p; int edt1,edt2,edt3; void Trans(); long int filesize( FILE *fp ) { long int save_pos, size_of_file; save_pos = ftell( fp ); fseek( fp, 0L, SEEK_END ); size_of_file = ftell( fp ); fseek( fp, save_pos, SEEK_SET ); return( size_of_file ); } void Upper_chars(char *buffer) { unsigned int c; for (c=0; c <= strlen(buffer)-1; c++) *(buffer+c)=toupper( *(buffer+c) ); } void OpenFileClick(void *sender) { char s[200]; GetFileName(s,200,"*.*"); if(strlen(s)>0) { SetProperty(edt1,"text",s); } } void OpenFileClick1(void *sender) { char s[200]; GetFileName(s,200,"*.*"); if(strlen(s)>0) { SetProperty(edt2,"text",s); } } void CloseClick(void *Sender) { ClearOutputWin(); //清除输出窗口内容 HideVclWin(); CloseVclWin(); CloseForm(p); } void ViewC() { char s[200],s1[200]; GetProperty(edt2,"text",s,200); sprintf(s1,"notepad.exe %s",s); WinExec(s1); } void CreateGui() { //ShowVclWin(170); //ShowOutputWin(310); CloseCodeWin(); ClearVclControls(); //HideLeftTools(); //HideRightTools(); int GuiMode=2; if((GuiMode==0)||(GuiMode==1)) p=GetGuiWin(GuiMode); else p=CreateComponentEx(0,"form","caption","Bin2C工具","Width",560,"height",170,"BorderIcons","[biSystemMenu]","position","poMainFormCenter","formstyle","fsstayontop", "visible",1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] int pnl = p; int txt2= CreateComponentEx(pnl,"label","caption","二进制文件名称：","left",10,"top",40-30,"width",60,NULL); edt1= CreateComponentEx(pnl,"edit", "text","c:\\boot.ini","left",75,"top",38-30,"width",385,NULL); int txt3= CreateComponentEx(pnl,"label","caption","C文件名称：","left",10,"top",68-30,"width",60,NULL); edt2= CreateComponentEx(pnl,"edit", "text","c:\\tmp.c","left",75,"top",65-30,"width",385,NULL); int txt4= CreateComponentEx(pnl,"label","caption","结构名称：","left",10,"top",96-30,"width",60,NULL); edt3= CreateComponentEx(pnl,"edit", "text","data","left",75,"top",92-30,"width",385,NULL); int btn1= CreateComponentEx(pnl,"button","caption","...","left",465,"top",36-30,"width",65,"onclick",OpenFileClick,NULL); int btn2= CreateComponentEx(pnl,"button","caption","...","left",465,"top",63-30,"width",65,"onclick",OpenFileClick1,NULL); int btn3= CreateComponentEx(pnl,"button","caption","转 换" ,"left",75,"top",93+28-25,"width",120,"onclick",Trans,NULL); int btn4= CreateComponentEx(pnl,"button","caption","查看C文件","left",215,"top",93+28-25,"width",120,"onclick",ViewC,NULL); int btn5= CreateComponentEx(pnl,"button","caption","退 出" ,"left",375,"top",93+28-25,"width",120,"onclick",CloseClick,NULL); } void main() { printf("BIN2C V1.0 by baohongjie\n"); CreateGui(); } void Trans() { char argv[4][255]; char s[100]; FILE *source,*dest; unsigned char buffer[BUF_LEN], Dummy[20]; int c; GetProperty(edt1,"text",argv[1],200); GetProperty(edt2,"text",argv[2],200); GetProperty(edt3,"text",argv[3],200); if( (source=fopen( argv[1], "rb" )) == NULL ) { sprintf(s,"二进制文件[%s]不存在!",argv[1]); ShowMessage(s); return; } strcpy(Dummy,argv[2]); if( (dest=fopen( Dummy, "wb+" )) == NULL ) { sprintf(s,"目标文件[%s]无法创建!",argv[1]); ShowMessage(s); return; } strcpy(Dummy,argv[3]); Upper_chars(Dummy); /* lower to upper chars */ strcat(Dummy,"_LEN"); /* add the suffix _LEN to the struct name */ fprintf( dest, "\r\n//CommBox V1.256\r\n\r\n", Dummy, filesize(source) ); fprintf( dest, "#define %s %d\r\n", Dummy, filesize(source) ); fprintf( dest, "static unsigned char %s[]=\r\n{\r\n", argv[3] ); if( ferror( dest ) ) { printf( "ERROR writing on target file: %s\n",argv[2] ); return; } do { fprintf(dest," "); for ( c=0; ((c <= LINE) && (! feof( source ) )) ; c++) { fread(buffer,1,1,source); if (!feof( source ) && c != 0) { fprintf(dest,","); } if (! feof( source ) ) { fprintf(dest,"0x%02x",*buffer); } } fprintf(dest,",\r\n"); } while( ! feof( source ) ); fprintf(dest,"};\r\n\r\n"); fclose(dest); fclose(source); printf("OK!"); ShowMessage("-------------转换完成!-----------------"); }" /> 
  <Command cmdname="对接收数据进行C格式化" cmdType="P" cmd="[P]void CFormat(unsigned char *buf,int count)//串口接收到数? { int i; unsigned char sbuf[1024]; unsigned char tmp[100]; sbuf[0]=0; for(i=0; i<count; i++) { if(i%16==15) sprintf(tmp,"0x%02x,\r\n",buf[i]&0xff); else sprintf(tmp,"0x%02x,",buf[i]&0xff); strcat(sbuf,tmp); } printf(sbuf); } void RecvSerialData(unsigned char *buf,int count) // 串口接收到数? { CFormat(buf,count); } void main() { ShowOutputWin(-1); }" /> 
  <Command cmdname="单片机Hex文件转Bin文件" cmdType="P" cmd="[P]#include <stdio.h> #include <stdlib.h> #include <string.h> #include <ctype.h> #define BUF_LEN 1 #define LINE 15 int p; int edt1,edt2,edt3; /* size in bytes */ #define MEMORY_SIZE 1024*1024 #define ADDRESS_MASK 0x000F0000 #ifndef TRUE #define TRUE 1 #define FALSE 0 #endif #define MAX_FILE_NAME_SIZE 255 /* The data records can contain 255 bytes: this means 512 characters. */ #define MAX_LINE_SIZE 1024 #define NO_ADDRESS_TYPE_SELECTED 0 #define LINEAR_ADDRESS 1 #define SEGMENTED_ADDRESS 2 typedef char filetype[MAX_FILE_NAME_SIZE]; typedef int boolean; typedef unsigned char byte; filetype Filename; FILE *Filin, /* input files */ *Filout; /* output files */ void *NoFailMalloc (size_t size); int NoFailOpenInputFile (char *Flnm); int NoFailOpenOutputFile (char *Flnm); void *NoFailMalloc (size_t size) { void *result; if ((result = malloc (size)) == NULL) { fprintf (stderr,"Can't allocate memory.\n"); exit(1); } return (result); } int NoFailOpenInputFile (char *Flnm) { if ((Filin = fopen(Flnm,"r")) == NULL) { printf ("Input file %s cannot be opened. Enter new filename: ",Flnm); return 0; } return 1; } /* Open the output file, with error checking */ int NoFailOpenOutputFile (char *Flnm) { if ((Filout = fopen(Flnm,"w")) == NULL) { fprintf(stderr,"Output file %s cannot be opened. Enter new file name: ", Flnm); return 0; } return 1; } int Trans() { /* line inputted from file */ char Line[MAX_LINE_SIZE]; /* flag that a file was read */ boolean Fileread; boolean Enable_Checksum_Error = FALSE; boolean Status_Checksum_Error = FALSE; /* cmd-line parameter # */ char *c,*p; unsigned int Param; unsigned int i; /* Application specific */ unsigned int Nb_Bytes; unsigned int First_Word, Address, Segment, Upper_Address; unsigned int Lowest_Address, Highest_Address, Starting_Address; unsigned int Phys_Addr, Type; unsigned int temp; unsigned int Seg_Lin_Select = NO_ADDRESS_TYPE_SELECTED; boolean Starting_Address_Setted = FALSE; int temp2; byte Data_Str[MAX_LINE_SIZE]; byte Checksum; /* This will hold binary codes translated from hex file. */ byte *Memory_Block; printf ("hex2bin v1.0, commbox v1.260\n"); Param = 1; GetProperty(edt1,"text",Filename,200); /* Just a normal file name */ if(NoFailOpenInputFile (Filename)==0) { ShowMessage("Hex文件打开错误！"); return; } GetProperty(edt2,"text",Filename,200); if(NoFailOpenOutputFile(Filename)==0) { ShowMessage("Bin文件打开错误！"); return; } Fileread = TRUE; /* allocate a buffer */ Memory_Block = (byte *) NoFailMalloc(MEMORY_SIZE); memset (Memory_Block,0xFF,MEMORY_SIZE); Segment = 0; Upper_Address = 0; Lowest_Address = MEMORY_SIZE - 1; Highest_Address = 0; /* Now read the file & process the lines. */ do /* repeat until EOF(Filin) */ { /* Read a line from input file. */ fgets(Line,MAX_LINE_SIZE,Filin); /* Remove carriage return/line feed at the end of line. */ i = strlen(Line)-1; if (Line[i] == '\n') Line[i] = '\0'; sscanf (Line, ":%2x%4x%2x%s",&Nb_Bytes,&First_Word,&Type,Data_Str); Checksum = Nb_Bytes + (First_Word >> 8) + (First_Word & 0xFF) + Type; p = Data_Str; /* If we're reading the last record, ignore it. */ switch (Type) { /* Data record */ case 0: Address = First_Word; if (Seg_Lin_Select == SEGMENTED_ADDRESS) Phys_Addr = ((Segment << 4) & ADDRESS_MASK) + Address; else /* LINEAR_ADDRESS or NO_ADDRESS_TYPE_SELECTED Upper_Address = 0 as specified in the Intel spec. until an extended address record is read. */ Phys_Addr = ((Upper_Address << 16) & ADDRESS_MASK) + Address; /* Check that the physical address stays in the buffer's range. */ if ((Phys_Addr + Nb_Bytes) <= MEMORY_SIZE -1) { /* Set the lowest address as base pointer. */ if (Phys_Addr < Lowest_Address) Lowest_Address = Phys_Addr; /* Same for the top address. */ temp = Phys_Addr + Nb_Bytes -1; if (temp > Highest_Address) Highest_Address = temp; /* Read the Data bytes. */ /* Bytes are written in the Memory block even if checksum is wrong. */ for (i= Nb_Bytes; i > 0; i--) { sscanf (p, "%2x",&temp2); p += 2; Memory_Block[Phys_Addr++] = temp2; Checksum = (Checksum + temp2) & 0xFF; }; /* Read the Checksum value. */ sscanf (p, "%2x",&temp2); /* Verify Checksum value. */ Checksum = (Checksum + temp2) & 0xFF; if ((Checksum != 0) && Enable_Checksum_Error) { Status_Checksum_Error = TRUE; } } else { if (Seg_Lin_Select == SEGMENTED_ADDRESS) fprintf(stderr,"Data record skipped at %4X:%4X\n",Segment,Address); else fprintf(stderr,"Data record skipped at %8X\n",Phys_Addr); } break; /* End of file record */ case 1: /* Simply ignore checksum errors in this line. */ break; /* Extended segment address record */ case 2: /* First_Word contains the offset. It's supposed to be 0000 so we ignore it. */ /* First extended segment address record ? */ if (Seg_Lin_Select == NO_ADDRESS_TYPE_SELECTED) Seg_Lin_Select = SEGMENTED_ADDRESS; /* Then ignore subsequent extended linear address records */ if (Seg_Lin_Select == SEGMENTED_ADDRESS) { sscanf (p, "%4x%2x",&Segment,&temp2); /* Update the current address. */ Phys_Addr = (Segment << 4) & ADDRESS_MASK; /* Verify Checksum value. */ Checksum = (Checksum + (Segment >> 8) + (Segment & 0xFF) + temp2) & 0xFF; if ((Checksum != 0) && Enable_Checksum_Error) Status_Checksum_Error = TRUE; } break; /* Start segment address record */ case 3: /* Nothing to be done since it's for specifying the starting address for execution of the binary code */ break; /* Extended linear address record */ case 4: /* First_Word contains the offset. It's supposed to be 0000 so we ignore it. */ /* First extended linear address record ? */ if (Seg_Lin_Select == NO_ADDRESS_TYPE_SELECTED) Seg_Lin_Select = LINEAR_ADDRESS; /* Then ignore subsequent extended segment address records */ if (Seg_Lin_Select == LINEAR_ADDRESS) { sscanf (p, "%4x%2x",&Upper_Address,&temp2); /* Update the current address. */ Phys_Addr = (Upper_Address << 16) & ADDRESS_MASK; /* Verify Checksum value. */ Checksum = (Checksum + (Upper_Address >> 8) + (Upper_Address & 0xFF) + temp2) & 0xFF; if ((Checksum != 0) && Enable_Checksum_Error) Status_Checksum_Error = TRUE; } break; /* Start linear address record */ case 5: /* Nothing to be done since it's for specifying the starting address for execution of the binary code */ break; default: } } while (!feof (Filin)); /*-----------------------------------------------------------------------------*/ printf("Lowest address = %08X\n",Lowest_Address); printf("Highest address = %08X\n",Highest_Address); if(Starting_Address_Setted) { Lowest_Address = Starting_Address; } /* write binary file */ fwrite (&Memory_Block[Lowest_Address], 1, Highest_Address - Lowest_Address +1, Filout); free (Memory_Block); fclose (Filin); if (Status_Checksum_Error & Enable_Checksum_Error) { printf("Checksum error detected.\n"); return 1; } fclose (Filout); ShowDispMode(2); HexEditorLoadFromFile(Filename); ShowMessage("转换完成!"); return 0; } long int filesize( FILE *fp ) { long int save_pos, size_of_file; save_pos = ftell( fp ); fseek( fp, 0L, SEEK_END ); size_of_file = ftell( fp ); fseek( fp, save_pos, SEEK_SET ); return( size_of_file ); } void Upper_chars(char *buffer) { unsigned int c; for (c=0; c <= strlen(buffer)-1; c++) *(buffer+c)=toupper( *(buffer+c) ); } void OpenFileClick(void *sender) { char s[200]; GetFileName(s,200,"*.hex|*.hex"); if(strlen(s)>0) SetProperty(edt1,"text",s); } void OpenFileClick1(void *sender) { char s[200]; GetFileName(s,200,"*.bin|*.bin"); if(strlen(s)>0) SetProperty(edt2,"text",s); } void CloseClick(void *Sender) { ClearOutputWin(); //清除输出窗口内容 HideVclWin(); CloseVclWin(); CloseForm(p); } void ViewC() { char s[200],s1[200]; GetProperty(edt2,"text",s,200); sprintf(s1,"notepad.exe %s",s); WinExec(s1); } void CreateGui() { CloseCodeWin(); ClearVclControls(); int GuiMode=2; if((GuiMode==0)||(GuiMode==1)) p=GetGuiWin(GuiMode); else p=CreateComponentEx(0,"form","caption","Hex2Bin工具","Width",570,"height",150,"BorderIcons","[biSystemMenu]","position","poMainFormCenter","formstyle","fsstayontop", "visible",1,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] int pnl =p; int txt2= CreateComponentEx(pnl,"label","caption","Hex文件名称：","left",10,"top",40-20,"width",90,NULL); edt1= CreateComponentEx(pnl,"edit", "text","c:\\1.hex","left",105,"top",38-20,"width",345,NULL); int txt3= CreateComponentEx(pnl,"label","caption","转换到文件名称：","left",10,"top",68-20,"width",90,NULL); edt2= CreateComponentEx(pnl,"edit", "text","c:\\tmp.bin","left",105,"top",65-20,"width",345,NULL); int btn1= CreateComponentEx(pnl,"button","caption","...","left",465,"top",36-20,"width",65,"onclick",OpenFileClick,NULL); int btn2= CreateComponentEx(pnl,"button","caption","...","left",465,"top",63-20,"width",65,"onclick",OpenFileClick1,NULL); int btn3= CreateComponentEx(pnl,"button","caption","转 换" ,"left",75,"top",93+28-40,"width",120,"onclick",Trans,NULL); int btn4= CreateComponentEx(pnl,"button","caption","查看转换文件","left",215,"top",93+28-40,"width",120,"onclick",ViewC,NULL); int btn5= CreateComponentEx(pnl,"button","caption","退 出" ,"left",375,"top",93+28-40,"width",120,"onclick",CloseClick,NULL); } void main() { CreateGui(); }" /> 
  <Command cmdname="默认显示" cmdType="P" cmd="[P]void main() { //ClearOutput(); //清除输出窗口内容 //ClearCommWin(); SetLayoutMode(0); OpenInputWin(); HideTerminalWin(); ClearVclControls(); HideVclWin(); HideLeftTools(); HideRightTools(); }" /> 
  <Command cmdname="万年历" cmdType="P" cmd="[P]#include "windows.h" static unsigned char const sky[][3]= {"甲","乙","丙","丁","戊","己","庚","辛","壬","癸",}; static unsigned char const earth[][3]= {"子","丑","寅","卯","辰","巳","午","未","申","酉","戌","亥",}; static unsigned char const monthcode[][3]= {"一","二","三","四","五","六","七","八","九","十","冬","腊",}; static unsigned char const nongliday[][3]= {"初","十","廿","三",}; static unsigned char const weekhz[][3]= {"一","二","三","四","五","六","日"}; static unsigned char const MonthDayMax[]= {31,28,31,30,31,30,31,31,30,31,30,31,}; /********************************************************************************************************* ** 函数名称:GetChinaCalendar ** 功能描述:公农历转换(只允许1901-2099年) ** 输　入: year 公历年 ** month 公历月 ** day 公历日 ** p 储存农历日期地址 ** 输　出: 1 成功 ** 0 失败 */ extern unsigned char GetChinaCalendar( unsigned int year, unsigned char month, unsigned char day, unsigned char *p); /********************************************************************************************************* ** 函数名称:GetWeek ** 功能描述:输入公历日期得到星期(只允许1901-2099年) ** 输　入: year 公历年 ** month 公历月 ** day 公历日 ** p 储存星期地址 ** 输　出: 无 */ extern void GetWeek( unsigned int year, unsigned char month, unsigned char day, unsigned char *p); /********************************************************************************************************* ** 函数名称:GetChinaCalendarStr ** 功能描述:输入公历日期得到农历字符串 ** 如:GetChinaCalendarStr(2007,02,06,str) 返回str="丙戌年腊月十九" ** 输　入: year 公历年 ** month 公历月 ** day 公历日 ** str 储存农历日期字符串地址 15Byte ** 输　出: 无 */ extern void GetChinaCalendarStr( unsigned int year, unsigned char month, unsigned char day, char *str); /********************************************************************************************************* ** 函数名称:GetJieQi ** 功能描述:输入公历日期得到本月24节气日期 day<15返回上半月节气,反之返回下半月 ** 如:GetJieQiStr(2007,02,08,str) 返回str[0]=4 ** 输　入: year 公历年 ** month 公历月 ** day 公历日 ** str 储存对应本月节气日期地址 1Byte ** 输　出: 1 成功 ** 0 失败 */ extern unsigned char GetJieQi( unsigned int year, unsigned char month, unsigned char day, unsigned char *JQdate); /********************************************************************************************************* ** 函数名称:GetJieQiStr ** 功能描述:输入公历日期得到24节气字符串 ** 如:GetJieQiStr(2007,02,08,str) 返回str="离雨水还有11天" ** 输　入: year 公历年 ** month 公历月 ** day 公历日 ** str 储存24节气字符串地址 15Byte ** 输　出: 1 成功 ** 0 失败 */ extern unsigned char GetJieQiStr( unsigned int year, unsigned char month, unsigned char day, char *str); HANDLE dc; int img,pfm; int mx,my; int GuiMode=2;//GUI窗口显示模式 int imgLeft=10; int imgTop=40; int curYear,curMonth; void OnClose() { if((GuiMode==0)||(GuiMode==1)) { ClearVclControls(); HideVclWin(200); } else { CloseForm(pfm); } } void DrawMonth(int year,int month) { int dc; int i,j,count; char s[20]; char str[15]; unsigned char NLyear[4]; int wk; HPEN pen; HBRUSH brush; HFONT fontChr,fontHz; dc=(HANDLE)GetProperty(img,"dc",0,0,0); // Windows Font ID fontChr = CreateFont( -22, // Height Of Font 0, // Width Of Font 0, // Angle Of Escapement 0, // Orientation Angle FW_BOLD, // Font Weight TRUE, // Italic FALSE, // Underline FALSE, // Strikeout ANSI_CHARSET, // Character Set Identifier OUT_TT_PRECIS, // Output Precision CLIP_DEFAULT_PRECIS, // Clipping Precision ANTIALIASED_QUALITY, // Output Quality FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch //"Courier New"); // Font Name "Bodoni MT Black"); fontHz = CreateFont( -15, // Height Of Font 0, // Width Of Font 0, // Angle Of Escapement 0, // Orientation Angle FW_BOLD, // Font Weight FALSE, // Italic FALSE, // Underline FALSE, // Strikeout ANSI_CHARSET, // Character Set Identifier OUT_TT_PRECIS, // Output Precision CLIP_DEFAULT_PRECIS, // Clipping Precision ANTIALIASED_QUALITY, // Output Quality FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch //"Courier New"); // Font Name "Bodoni MT Black"); SelectObject(dc,fontHz); RECT rect= {0,0,640,780}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0xffffff); SelectObject(dc,brush); FillRect(dc,&rect,brush); DeleteObject(brush); for(i=0; i<7; i++) { sprintf(s,"星期%s",weekhz[i]); TextOutA(dc,12+i*70,10,s,strlen(s)); } GetWeek(year,month,1,&wk); wk=wk&0xff; if(wk==0)wk=7; pen=CreatePen(PS_SOLID,1, 0x000000); SelectObject(dc,pen); DeleteObject(pen); SetTextColor(dc,0x000000); count=MonthDayMax[month-1]; if(month==2) if((year%4==0)&&((year%100!=0)||(year%400==0))) count++; for(i=0; i<count; i++) { SetTextColor(dc,0x000000); SetBkColor(dc, 0xffffff); sprintf(s," %d ",i+1); SelectObject(dc,fontChr); if(i<10) TextOutA(dc,22 +((wk+i-1)%7)*70,34+70*((wk+i-1)/7),s,strlen(s)); else TextOutA(dc,16+((wk+i-1)%7)*70,34+70*((wk+i-1)/7),s,strlen(s)); GetChinaCalendarStr(year,month,i+1,str); //str ={"丙戌年腊月廿一"} GetChinaCalendar (year,month,i+1,NLyear); //NLyear={20,06,12,21} SelectObject(dc,fontHz); if(NLyear[3]==1) { DeleteObject(brush); brush=CreateSolidBrush(0xafafaf); SelectObject(dc,brush); SetTextColor(dc,0x00ffff); SetBkColor(dc,0xff0000 ); TextOutA(dc,20+((wk+i-1)%7)*70,60+70*((wk+i-1)/7),str+6,4); } else { DeleteObject(brush); brush=CreateSolidBrush(0xafafaf); SelectObject(dc,brush); SetTextColor(dc,0x000000); SetBkColor(dc, 0xffffff); TextOutA(dc,20+((wk+i-1)%7)*70,60+70*((wk+i-1)/7),str+10,strlen(str)-10); } GetJieQiStr(year,month,i+1,str); if(str[4]==0) { SetTextColor(dc,0x0000ff); SetBkColor(dc,0x00ffff ); TextOutA(dc,20+((wk+i-1)%7)*70,80+70*((wk+i-1)/7),str ,strlen(str) ); } //printf("day:%d %s",i+1,str); } MoveToEx(dc,0, 0,0); LineTo(dc,600, 0); for(i=0; i<10; i++) { MoveToEx(dc,0,-40+i*70,0); LineTo(dc,600,-40+i*70); } for(i=0; i<10; i++) { MoveToEx(dc, i*70,0,0); LineTo(dc, i*70,600); } sprintf(s,"%d年%d月",curYear,curMonth); SetProperty(pfm,"caption",s); printf("week:%d",wk ); Invalidate(img); DeleteObject(fontChr); DeleteObject(fontHz); } void OnLastMonth() { if(curMonth==1) { curMonth=12; curYear--; } else curMonth--; DrawMonth(curYear,curMonth); } void OnNextMonth() { if(curMonth==12) { curMonth=1; curYear++; } else curMonth++; DrawMonth(curYear,curMonth); } void OnLastYear() { curYear--; DrawMonth(curYear,curMonth); } void OnNextYear() { curYear++; DrawMonth(curYear,curMonth); } void main(void) { unsigned char week; unsigned char NLyear[4]; unsigned char JQdate; char str[15]; int i,j; int mi,mi1; SYSTEMTIME st; GetLocalTime(&st); //HideLeftTools(); ClearVclControls(); if((GuiMode==0)||(GuiMode==1)) { pfm=GetGuiWin(GuiMode); } else pfm=CreateComponentEx(0,"form","caption","分站模拟","Width",520,"height",480+50,"BorderIcons","[biSystemMenu]","position","poMainFormCenter","formstyle","fsstayontop",NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] //CreateComponentEx(pfm,"timer","interval",100,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 CreateComponentEx(pfm,"Button","caption","关闭","left",400,"top",5,"width",100,"height",20,"OnClick",OnClose,0); CreateComponentEx(pfm,"Button","caption","上月","left",20,"top",5,"width",70,"height",20,"OnClick",OnLastMonth,0); CreateComponentEx(pfm,"Button","caption","下月","left",100,"top",5,"width",70,"height",20,"OnClick",OnNextMonth,0); CreateComponentEx(pfm,"Button","caption","上年","left",220,"top",5,"width",70,"height",20,"OnClick",OnLastYear,0); CreateComponentEx(pfm,"Button","caption","下年","left",300,"top",5,"width",70,"height",20,"OnClick",OnNextYear,0); img=CreateComponentEx(pfm,"Image","left",imgLeft,"top",imgTop,"width",491,"height",381+70 ,0); SetProperty(pfm,"visible",1); //SetProperty(pfm,"caption","20120531"); curYear=st.wYear; curMonth=st.wMonth; DrawMonth(curYear,curMonth); } static unsigned char const year_code[]= { 0x04,0xAe,0x53, //1901 0 0x0A,0x57,0x48, //1902 3 0x55,0x26,0xBd, //1903 6 0x0d,0x26,0x50, //1904 9 0x0d,0x95,0x44, //1905 12 0x46,0xAA,0xB9, //1906 15 0x05,0x6A,0x4d, //1907 18 0x09,0xAd,0x42, //1908 21 0x24,0xAe,0xB6, //1909 0x04,0xAe,0x4A, //1910 0x6A,0x4d,0xBe, //1911 0x0A,0x4d,0x52, //1912 0x0d,0x25,0x46, //1913 0x5d,0x52,0xBA, //1914 0x0B,0x54,0x4e, //1915 0x0d,0x6A,0x43, //1916 0x29,0x6d,0x37, //1917 0x09,0x5B,0x4B, //1918 0x74,0x9B,0xC1, //1919 0x04,0x97,0x54, //1920 0x0A,0x4B,0x48, //1921 0x5B,0x25,0xBC, //1922 0x06,0xA5,0x50, //1923 0x06,0xd4,0x45, //1924 0x4A,0xdA,0xB8, //1925 0x02,0xB6,0x4d, //1926 0x09,0x57,0x42, //1927 0x24,0x97,0xB7, //1928 0x04,0x97,0x4A, //1929 0x66,0x4B,0x3e, //1930 0x0d,0x4A,0x51, //1931 0x0e,0xA5,0x46, //1932 0x56,0xd4,0xBA, //1933 0x05,0xAd,0x4e, //1934 0x02,0xB6,0x44, //1935 0x39,0x37,0x38, //1936 0x09,0x2e,0x4B, //1937 0x7C,0x96,0xBf, //1938 0x0C,0x95,0x53, //1939 0x0d,0x4A,0x48, //1940 0x6d,0xA5,0x3B, //1941 0x0B,0x55,0x4f, //1942 0x05,0x6A,0x45, //1943 0x4A,0xAd,0xB9, //1944 0x02,0x5d,0x4d, //1945 0x09,0x2d,0x42, //1946 0x2C,0x95,0xB6, //1947 0x0A,0x95,0x4A, //1948 0x7B,0x4A,0xBd, //1949 0x06,0xCA,0x51, //1950 0x0B,0x55,0x46, //1951 0x55,0x5A,0xBB, //1952 0x04,0xdA,0x4e, //1953 0x0A,0x5B,0x43, //1954 0x35,0x2B,0xB8, //1955 0x05,0x2B,0x4C, //1956 0x8A,0x95,0x3f, //1957 0x0e,0x95,0x52, //1958 0x06,0xAA,0x48, //1959 0x7A,0xd5,0x3C, //1960 0x0A,0xB5,0x4f, //1961 0x04,0xB6,0x45, //1962 0x4A,0x57,0x39, //1963 0x0A,0x57,0x4d, //1964 0x05,0x26,0x42, //1965 0x3e,0x93,0x35, //1966 0x0d,0x95,0x49, //1967 0x75,0xAA,0xBe, //1968 0x05,0x6A,0x51, //1969 0x09,0x6d,0x46, //1970 0x54,0xAe,0xBB, //1971 0x04,0xAd,0x4f, //1972 0x0A,0x4d,0x43, //1973 0x4d,0x26,0xB7, //1974 0x0d,0x25,0x4B, //1975 0x8d,0x52,0xBf, //1976 0x0B,0x54,0x52, //1977 0x0B,0x6A,0x47, //1978 0x69,0x6d,0x3C, //1979 0x09,0x5B,0x50, //1980 0x04,0x9B,0x45, //1981 0x4A,0x4B,0xB9, //1982 0x0A,0x4B,0x4d, //1983 0xAB,0x25,0xC2, //1984 0x06,0xA5,0x54, //1985 0x06,0xd4,0x49, //1986 0x6A,0xdA,0x3d, //1987 0x0A,0xB6,0x51, //1988 0x09,0x37,0x46, //1989 0x54,0x97,0xBB, //1990 0x04,0x97,0x4f, //1991 0x06,0x4B,0x44, //1992 0x36,0xA5,0x37, //1993 0x0e,0xA5,0x4A, //1994 0x86,0xB2,0xBf, //1995 0x05,0xAC,0x53, //1996 0x0A,0xB6,0x47, //1997 0x59,0x36,0xBC, //1998 0x09,0x2e,0x50, //1999 294 0x0C,0x96,0x45, //2000 297 0x4d,0x4A,0xB8, //2001 0x0d,0x4A,0x4C, //2002 0x0d,0xA5,0x41, //2003 0x25,0xAA,0xB6, //2004 0x05,0x6A,0x49, //2005 0x7A,0xAd,0xBd, //2006 0x02,0x5d,0x52, //2007 0x09,0x2d,0x47, //2008 0x5C,0x95,0xBA, //2009 0x0A,0x95,0x4e, //2010 0x0B,0x4A,0x43, //2011 0x4B,0x55,0x37, //2012 0x0A,0xd5,0x4A, //2013 0x95,0x5A,0xBf, //2014 0x04,0xBA,0x53, //2015 0x0A,0x5B,0x48, //2016 0x65,0x2B,0xBC, //2017 0x05,0x2B,0x50, //2018 0x0A,0x93,0x45, //2019 0x47,0x4A,0xB9, //2020 0x06,0xAA,0x4C, //2021 0x0A,0xd5,0x41, //2022 0x24,0xdA,0xB6, //2023 0x04,0xB6,0x4A, //2024 0x69,0x57,0x3d, //2025 0x0A,0x4e,0x51, //2026 0x0d,0x26,0x46, //2027 0x5e,0x93,0x3A, //2028 0x0d,0x53,0x4d, //2029 0x05,0xAA,0x43, //2030 0x36,0xB5,0x37, //2031 0x09,0x6d,0x4B, //2032 0xB4,0xAe,0xBf, //2033 0x04,0xAd,0x53, //2034 0x0A,0x4d,0x48, //2035 0x6d,0x25,0xBC, //2036 0x0d,0x25,0x4f, //2037 0x0d,0x52,0x44, //2038 0x5d,0xAA,0x38, //2039 0x0B,0x5A,0x4C, //2040 0x05,0x6d,0x41, //2041 0x24,0xAd,0xB6, //2042 0x04,0x9B,0x4A, //2043 0x7A,0x4B,0xBe, //2044 0x0A,0x4B,0x51, //2045 0x0A,0xA5,0x46, //2046 0x5B,0x52,0xBA, //2047 0x06,0xd2,0x4e, //2048 0x0A,0xdA,0x42, //2049 0x35,0x5B,0x37, //2050 0x09,0x37,0x4B, //2051 0x84,0x97,0xC1, //2052 0x04,0x97,0x53, //2053 0x06,0x4B,0x48, //2054 0x66,0xA5,0x3C, //2055 0x0e,0xA5,0x4f, //2056 0x06,0xB2,0x44, //2057 0x4A,0xB6,0x38, //2058 0x0A,0xAe,0x4C, //2059 0x09,0x2e,0x42, //2060 0x3C,0x97,0x35, //2061 0x0C,0x96,0x49, //2062 0x7d,0x4A,0xBd, //2063 0x0d,0x4A,0x51, //2064 0x0d,0xA5,0x45, //2065 0x55,0xAA,0xBA, //2066 0x05,0x6A,0x4e, //2067 0x0A,0x6d,0x43, //2068 0x45,0x2e,0xB7, //2069 0x05,0x2d,0x4B, //2070 0x8A,0x95,0xBf, //2071 0x0A,0x95,0x53, //2072 0x0B,0x4A,0x47, //2073 0x6B,0x55,0x3B, //2074 0x0A,0xd5,0x4f, //2075 0x05,0x5A,0x45, //2076 0x4A,0x5d,0x38, //2077 0x0A,0x5B,0x4C, //2078 0x05,0x2B,0x42, //2079 0x3A,0x93,0xB6, //2080 0x06,0x93,0x49, //2081 0x77,0x29,0xBd, //2082 0x06,0xAA,0x51, //2083 0x0A,0xd5,0x46, //2084 0x54,0xdA,0xBA, //2085 0x04,0xB6,0x4e, //2086 0x0A,0x57,0x43, //2087 0x45,0x27,0x38, //2088 0x0d,0x26,0x4A, //2089 0x8e,0x93,0x3e, //2090 0x0d,0x52,0x52, //2091 0x0d,0xAA,0x47, //2092 0x66,0xB5,0x3B, //2093 0x05,0x6d,0x4f, //2094 0x04,0xAe,0x45, //2095 0x4A,0x4e,0xB9, //2096 0x0A,0x4d,0x4C, //2097 0x0d,0x15,0x41, //2098 0x2d,0x92,0xB5, //2099 }; /*月份数据表*/ static unsigned char const day_code1[9]= {0x0,0x1f,0x3b,0x5a,0x78,0x97,0xb5,0xd4,0xf3}; static unsigned short const day_code2[3]= {0x111,0x130,0x14e}; /**************************************************************************** * 子函数,用于读取数据表中农历月的大月或小月,如果该月为大返回1,为小返回0 ****************************************************************************/ static unsigned char GetMoonDay(unsigned char month_p,unsigned short table_addr) { switch (month_p) { case 1: if((year_code[table_addr]&0x08)==0) return(0); else return(1); case 2: if((year_code[table_addr]&0x04)==0) return(0); else return(1); case 3: if((year_code[table_addr]&0x02)==0) return(0); else return(1); case 4: if((year_code[table_addr]&0x01)==0) return(0); else return(1); case 5: if((year_code[table_addr+1]&0x80)==0) return(0); else return(1); case 6: if((year_code[table_addr+1]&0x40)==0) return(0); else return(1); case 7: if((year_code[table_addr+1]&0x20)==0) return(0); else return(1); case 8: if((year_code[table_addr+1]&0x10)==0) return(0); else return(1); case 9: if((year_code[table_addr+1]&0x08)==0) return(0); else return(1); case 10: if((year_code[table_addr+1]&0x04)==0) return(0); else return(1); case 11: if((year_code[table_addr+1]&0x02)==0) return(0); else return(1); case 12: if((year_code[table_addr+1]&0x01)==0) return(0); else return(1); case 13: if((year_code[table_addr+2]&0x80)==0) return(0); else return(1); } return(0); } /********************************************************************************************************* ** 函数名称:GetChinaCalendar ** 功能描述:公农历转换(只允许1901-2099年) ** 输　入: year 公历年 ** month 公历月 ** day 公历日 ** p 储存农历日期地址 ** 输　出: 1 成功 ** 0 失败 *****/ unsigned char GetChinaCalendar( unsigned int year, unsigned char month, unsigned char day, unsigned char *p) { unsigned char temp1,temp2,temp3,month_p,yearH,yearL; unsigned char flag_y; unsigned short temp4,table_addr; yearH=year/100; yearL=year%100; if((yearH!=19)&&(yearH!=20)) return(0); /* 定位数据表地址 */ if(yearH==20) table_addr=(yearL+100-1)*3; else table_addr=(yearL-1)*3; /* 取当年春节所在的公历月份 */ temp1=year_code[table_addr+2]&0x60; temp1>>=5; /* 取当年春节所在的公历日 */ temp2=year_code[table_addr+2]&31; /* 计算当年春年离当年元旦的天数,春节只会在公历1月或2月 */ if(temp1==1) temp3=temp2-1; else temp3=temp2+31-1; /* 计算公历日离当年元旦的天数 */ if (month<10) temp4=day_code1[month-1]+day-1; else temp4=day_code2[month-10]+day-1; /* 如果公历月大于2月并且该年的2月为闰月,天数加1 */ if ((month>2)&&(yearL%4==0)) temp4++; /* 判断公历日在春节前还是春节后 */ if (temp4>=temp3) { temp4-=temp3; month=1; month_p=1; flag_y=0; if(GetMoonDay(month_p,table_addr)==0) temp1=29; //小月29天 else temp1=30; //大小30天 /* 从数据表中取该年的闰月月份,如为0则该年无闰月 */ temp2=year_code[table_addr]/16; while(temp4>=temp1) { temp4-=temp1; month_p++; if(month==temp2) { flag_y=~flag_y; if(flag_y==0)month++; } else month++; if(GetMoonDay(month_p,table_addr)==0) temp1=29; else temp1=30; } day=temp4+1; } /* 公历日在春节前使用下面代码进行运算 */ else { temp3-=temp4; if (yearL==0) { yearL=100-1; yearH=19; } else yearL--; table_addr-=3; month=12; temp2=year_code[table_addr]/16; if (temp2==0) month_p=12; else month_p=13; flag_y=0; if(GetMoonDay(month_p,table_addr)==0) temp1=29; else temp1=30; while(temp3>temp1) { temp3-=temp1; month_p--; if(flag_y==0) month--; if(month==temp2) flag_y=~flag_y; if(GetMoonDay(month_p,table_addr)==0) temp1=29; else temp1=30; } day=temp1-temp3+1; } *p++=yearH; *p++=yearL; *p++=month; *p=day; return(1); } static unsigned char const table_week[12]= {0,3,3,6,1,4,6,2,5,0,3,5}; //月修正数据表 /********************************************************************************************************* ** 函数名称:GetWeek ** 功能描述:输入公历日期得到星期(只允许1901-2099年) ** 输　入: year 公历年 ** month 公历月 ** day 公历日 ** p 储存星期地址 ** 输　出: 无 ***********************/ void GetWeek( unsigned int year, unsigned char month, unsigned char day, unsigned char *p) { unsigned int temp2; unsigned char yearH,yearL; yearH=year/100; yearL=year%100; /* 如果为21世纪,年份数加100 */ if (yearH>19) yearL+=100; /* 所过闰年数只算1900年之后的 */ temp2=yearL+yearL/4; temp2=temp2%7; temp2=temp2+day+table_week[month-1]; if (yearL%4==0&&month<3) temp2--; *p=(temp2%7); } /********************************************************************************************************* ** 函数名称:GetSkyEarth ** 功能描述:输入公历日期得到一个甲子年(只允许1901-2099年) ** 输　入: year 公历年 ** p 储存星期地址 ** 输　出: 无 **********************************************************************************/ static void GetSkyEarth(unsigned int year,unsigned char *p) { unsigned char x; if(year>=1984) { year=year-1984; x=year%60; } else { year=1984-year; x=60-year%60; } *p=x; } static void StrCopy(char *target,unsigned char const *source,unsigned char no) { unsigned int i; for(i=0; i<no; i++) { *target++=*source++; } } /********************************************************************************************************* ** 函数名称:GetChinaCalendarStr ** 功能描述:输入公历日期得到农历字符串 ** 如:GetChinaCalendarStr(2007,02,06,str) 返回str="丙戌年腊月十九" ** 输　入: year 公历年 ** month 公历月 ** day 公历日 ** str 储存农历日期字符串地址 15Byte ** 输　出: 无 *******************************************************************************/ void GetChinaCalendarStr( unsigned int year, unsigned char month, unsigned char day, char *str) { unsigned char NLyear[4]; unsigned char SEyear; StrCopy(&str[0],(unsigned char *)"甲子年正月初一",15); if(GetChinaCalendar(year,month,day,(unsigned char *)NLyear)==0) return; GetSkyEarth(NLyear[0]*100+NLyear[1],&SEyear); StrCopy(&str[0],(unsigned char *) sky[SEyear%10],2); // 甲 StrCopy(&str[2],(unsigned char *)earth[SEyear%12],2); // 子 if(NLyear[2]==1) StrCopy(&str[6],(unsigned char *)"正",2); else StrCopy(&str[6],(unsigned char *)monthcode[NLyear[2]-1],2); if(NLyear[3]>10) StrCopy(&str[10],(unsigned char *)nongliday[NLyear[3]/10],2); else StrCopy(&str[10],(unsigned char *)"初",2); StrCopy(&str[12],(unsigned char *)monthcode[(NLyear[3]-1)%10],2); } /********************************************************************************************************* ** 以下为24节气计算相关程序 **------------------------------------------------------------------------------------------------------ ********************************************************************************************************/ /* 每年24节气标志表 有兴趣的朋友可按照上面给的原理添加其它年份的表格 */ static unsigned char const YearMonthBit[]= { 0x4E,0xA6,0x99, //2000 0x9C,0xA2,0x98, //2001 0x80,0x00,0x18, //2002 0x00,0x10,0x24, //2003 0x4E,0xA6,0x99, //2004 0x9C,0xA2,0x98, //2005 0x80,0x82,0x18, //2006 0x00,0x10,0x24, //2007 0x4E,0xA6,0xD9, //2008 0x9E,0xA2,0x98, //2009 0x80,0x82,0x18, //2010 0x00,0x10,0x04, //2011 0x4E,0xE6,0xD9, //2012 0x9E,0xA6,0xA8, //2013 0x80,0x82,0x18, //2014 0x00,0x10,0x00, //2015 0x0F,0xE6,0xD9, //2016 0xBE,0xA6,0x98, //2017 0x88,0x82,0x18, //2018 0x80,0x00,0x00, //2019 0x0F,0xEF,0xD9, //2020 0xBE,0xA6,0x99, //2021 0x8C,0x82,0x98, //2022 0x80,0x00,0x00, //2023 0x0F,0xEF,0xDB, //2024 0xBE,0xA6,0x99, //2025 0x9C,0xA2,0x98, //2026 0x80,0x00,0x18, //2027 0x0F,0xEF,0xDB, //2028 0xBE,0xA6,0x99, //2029 0x9C,0xA2,0x98, //2030 0x80,0x00,0x18, //2031 0x0F,0xEF,0xDB, //2032 0xBE,0xA2,0x99, //2033 0x8C,0xA0,0x98, //2034 0x80,0x82,0x18, //2035 0x0B,0xEF,0xDB, //2036 0xBE,0xA6,0x99, //2037 0x8C,0xA2,0x98, //2038 0x80,0x82,0x18, //2039 0x0F,0xEF,0xDB, //2040 0xBE,0xE6,0xD9, //2041 0x9E,0xA2,0x98, //2042 0x80,0x82,0x18, //2043 0x0F,0xEF,0xFB, //2044 0xBF,0xE6,0xD9, //2045 0x9E,0xA6,0x98, //2046 0x80,0x82,0x18, //2047 0x0F,0xFF,0xFF, //2048 0xFC,0xEF,0xD9, //2049 0xBE,0xA6,0x18, //2050 }; static unsigned char const days[]= { 6,20,4,19,6,21, //一月到三月 的节气基本日期 5,20,6,21,6,21, //四月到六月 的节气基本日期 7,23,8,23,8,23, //七月到九月 的节气基本日期 8,24,8,22,7,22, //十月到十二月的节气基本日期 }; static char const JieQiStr[][5]= //以公历日期先后排序 { /* 名称 角度 公历日期 周期 */ "小寒", //285 1月 6日 "大寒", //300 1月20日 29.5天 "立春", //315 2月 4日 "雨水", //330 2月19日 29.8天 "惊蛰", //345 3月 6日 "春分", // 0 3月21日 30.2天 "清明", // 15 4月 5日 "谷雨", // 30 4月20日 30.7天 "立夏", // 45 5月 6日 "夏满", // 60 5月21日 31.2天 "芒种", // 75 6月 6日 "夏至", // 90 6月21日 31.4天 "小暑", //105 7月 7日 "大暑", //120 7月23日 31.4天 "立秋", //135 8月 8日 "处暑", //150 8月23日 31.1天 "白露", //165 9月 8日 "秋分", //180 9月23日 30.7天 "寒露", //195 10月 8日 "霜降", //210 10月24日 30.1天 "立冬", //225 11月 8日 "小雪", //240 11月22日 29.7天 "大雪", //255 12月 7日 "冬至", //270 12月22日 29.5天 }; /********************************************************************************************************* ** 函数名称:GetJieQi ** 功能描述:输入公历日期得到本月24节气日期 day<15返回上半月节气,反之返回下半月 ** 如:GetJieQiStr(2007,02,08,str) 返回str[0]=4 ** 输　入: year 公历年 ** month 公历月 ** day 公历日 ** str 储存对应本月节气日期地址 1Byte ** 输　出: 1 成功 ** 0 失败 ************************************************************************************/ unsigned char GetJieQi( unsigned int year, unsigned char month, unsigned char day, unsigned char *JQdate) { unsigned char bak1,value,JQ; if((year<2000)||(year>2050)) return 0; if((month==0) ||(month>12)) return 0; JQ = (month-1) *2 ; //获得节气顺序标号(0～23 if(day >= 15) JQ++; //判断是否是上半月 bak1=YearMonthBit[(year-2000)*3+JQ/8]; //获得节气日期相对值所在字节 value =((bak1<<(JQ%8))&0x80); //获得节气日期相对值状态 *JQdate=days[JQ]; if( value != 0 ) { //判断年份,以决定节气相对值1代表1,还是－1。 if( (JQ== 1||JQ== 11||JQ== 18||JQ== 21)&&year< 2044) (*JQdate)++; else (*JQdate)--; } return 1; } static unsigned char const MonthDayMax[]= {31,28,31,30,31,30,31,31,30,31,30,31,}; /********************************************************************************************************* ** 函数名称:GetJieQiStr ** 功能描述:输入公历日期得到24节气字符串 ** 如:GetJieQiStr(2007,02,08,str) 返回str="离雨水还有11天" ** 输　入: year 公历年 ** month 公历月 ** day 公历日 ** str 储存24节气字符串地址 15Byte ** 输　出: 1 成功 ** 0 失败 **********************************************************************************/ unsigned char GetJieQiStr( unsigned int year, unsigned char month, unsigned char day, char *str) { unsigned char JQdate,JQ,MaxDay; if(GetJieQi(year,month,day,&JQdate)==0) return 0; JQ = (month-1) *2 ; //获得节气顺序标号(0～23 if(day >= 15) JQ++; //判断是否是上半月 if(day==JQdate) //今天正是一个节气日 { StrCopy(str,(unsigned char *)JieQiStr[JQ],5); return 1; } //今天不是一个节气日 StrCopy(str,(unsigned char *)"离小寒还有??天",15); if(day<JQdate) //如果今天日期小于本月的节气日期 { StrCopy(&str[2],(unsigned char *)JieQiStr[JQ],4); day=JQdate-day; } else //如果今天日期大于本月的节气日期 { StrCopy(&str[2],(unsigned char *)JieQiStr[JQ+1],4); if(day < 15) { GetJieQi(year,month,15,&JQdate); day=JQdate-day; } else //翻月 { MaxDay=MonthDayMax[month-1]; if(month==2) //润月问题 { if((year%4==0)&&((year%100!=0)||(year%400==0))) MaxDay++; } if(++month==13) month=1; GetJieQi(year,month,1,&JQdate); day=MaxDay-day+JQdate; } } str[10]=day/10+'0'; str[11]=day%10+'0'; return 1; }" /> 
  <Command cmdname="数据示波器-源程序" cmdType="P" cmd="[P]#include "windows.h" // Header File For Windows #include <stdio.h> // Header File For Standard Input/Output #include <stdlib.h> #include <gl\gl.h> // Header File For The OpenGL32 Library #include <gl\glu.h> // Header File For The GLu32 Library #include <gl\glaux.h> // Header File For The Glaux Library //#include"libtcc1.c" #include"math.h" #pragma comment(lib,"lib\\ftgl.def"); #pragma comment(lib,"lib\\shx.o"); #pragma comment(lib,"lib\\glGraphLib.o"); #define bool unsigned char int starttime; unsigned int framecount=0; GLuint base; int *ft; bool closing=0; #define num 360 // Number Of Stars To Draw int mx=0,my=0; int mdx=-1,mdy=-1; int mux=-1,muy=-1; int md=0; int tbxscale,tbyscale; int xscale=0,yscale=0; int bkColor=0; int tbbkclr; int cbWave,cbHisto,cbClock,cbDigit,dispHisto=0,dispClock=0,dispDigit=0,dispWave=0; unsigned char NeedRedraw=1; GLuint texture[1]; // Storage For One textures double imgWidth; HGLRC hglrc; HDC hdc; int cbDisp1=1,cbDisp2=1; int cbSimDat,tmrSimDat; unsigned char DispChannel[16]= {1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; float imgX0=-20,imgX1=20,imgY0=-8,imgY1=8; int wd,ht; double zoom=1,offsetx=0,offsety=0; unsigned char waveData[16][1024]; int waveDataCount[16]= {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; int GuiMode=2,pfm,pfm0; int maxWaveCount; typedef struct CharIndex { int code; int shapePtr; int len; } CharIndex; int winwidth,winheight; typedef struct _ShxFont_ { int openOK; int indexCount; unsigned char *buffer; CharIndex *indexBuffer; int type; int shxFontDownLine,shxFontUpLine; double scale; } ShxFont; ShxFont *sfChar=NULL,*sfHz=NULL; double GetShxFontScale(ShxFont *sf); typedef struct { float x; float y; float z; } POINT3D; extern void Draw7Seg(int dig,float x0,float y0,float z0,float scale,float r,float g,float b,float alpha,float width,float thick,float italic); //下 extern void DrawClock(float x,float y,float z,float r,float g,float b,float rad1,float rad2,unsigned char *name,unsigned char dat); void SwapFolat(float *a,float *b) { float tmp=*a; *a=*b; *b=tmp; } void FormCreate() { hdc=GetDC(GetFormHandle(pfm)); //hdc=(HANDLE)GetProperty(pnl,"dc",0,0,0); int nPixelFormat; static PIXELFORMATDESCRIPTOR pfd= { sizeof(PIXELFORMATDESCRIPTOR), 1, PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER, PFD_TYPE_RGBA, 24, 0,0,0,0,0, 0,0, 0,0,0,0,0, 32, 0, 0, PFD_MAIN_PLANE, 0, 0,0,0 }; nPixelFormat=ChoosePixelFormat(hdc,&pfd); SetPixelFormat(hdc,nPixelFormat,&pfd); hglrc=wglCreateContext(hdc); wglMakeCurrent(hdc,hglrc); } //--------------------------------------------------------------------------- GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } void OnClose() { if((GuiMode==0)||(GuiMode==1)) { ClearVclControls(); HideVclWin(200); } else { //ClearVclControls(); CloseForm(pfm0); } printf("close"); } void FormDestroy() { closing=1; Wait(2); printf("destroy"); } int AnsiToUnicode(unsigned char *pszA, unsigned char* ppszW) { ULONG cCharacters; DWORD dwError; if (NULL == pszA) { *ppszW = NULL; printf("ERROR0"); return NOERROR; } cCharacters = strlen(pszA)+1; if (NULL == ppszW) return E_OUTOFMEMORY; // Covert to Unicode. if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, -1, ppszW, cCharacters)) { dwError = GetLastError(); free(ppszW); ppszW = NULL; printf("ERROR"); return HRESULT_FROM_WIN32(dwError); } return NOERROR; } GLvoid glPrint(const char *fmt, ...) // Custom GL "Print" Routine { char text[256],text1[256]; // Holds Our String va_list ap; // Pointer To List Of Arguments if (fmt == NULL) // If There's No Text return; // Do Nothing va_start(ap, fmt); // Parses The String For Variables vsprintf(text, fmt, ap); // And Converts Symbols To Actual Numbers va_end(ap); // Results Are Stored In Text glPushAttrib(GL_LIST_BIT); // Pushes The Display List Bits //glListBase(base - 32); // Sets The Base Character to 32 ////// glCallLists(strlen(text), GL_UNSIGNED_BYTE, text); // Draws The Display List Text glScalef(0.006,0.006,0.006); glScalef(1.5,1.5,0.006); AnsiToUnicode(text,text1); ftglRenderFontW(ft, text1, 0xffff); //ftglRenderFont(ft, text, 0xffff); glPopAttrib(); // Pops The Display List Bits } void DrawLine(ShxFont *sf,double x0,double y0,double x1,double y1) { double scale; scale=5.0/GetShxFontHeight(sf)*1.0* sf->scale;// 0.08; x0*=scale; y0*=scale; x1*=scale; y1*=scale; x0+=0; x1+=0; glBegin(GL_LINES); glVertex3f(x0+0.3*y0,y0, 0.0f); glVertex3f(x1+0.3*y1,y1, 0.0f); glEnd(); } GLvoid glShxPrint(const char *fmt, ...) // Custom GL "Print" Routine { unsigned char text[256]; // Holds Our String va_list ap; // Pointer To List Of Arguments int i=0; if (fmt == NULL) // If There's No Text return; // Do Nothing //return; va_start(ap, fmt); // Parses The String For Variables vsprintf(text, fmt, ap); // And Converts Symbols To Actual Numbers va_end(ap); // Results Are Stored In Text //glLoadIdentity();// //glScalef(0.1,0.1,0); // while(text[i]) { if(text[i]<128) { ReadCharShape(sfChar,text[i],0);// glTranslatef(14,0.0f,0.0f);//// i++; } else { glTranslatef(0.0,-3.5f,0.0f); ReadCharShape(sfHz,text[i]*256+text[i+1],0); glTranslatef(22.0,3.5f,0.0f); i++; i++; } } } AUX_RGBImageRec *LoadBMP(char *Filename) // Loads A Bitmap Image { FILE *File=NULL; // File Handle if (!Filename) // Make Sure A Filename Was Given return NULL; // If Not Return NULL File=fopen(Filename,"r"); // Check To See If The File Exists if (File) // Does The File Exist? { fclose(File); // Close The Handle return auxDIBImageLoad(Filename); // Load The Bitmap And Return A Pointer } return NULL; // If Load Failed Return NULL } int LoadGLTextures() // Load Bitmaps And Convert To Textures { int Status=FALSE; // Status Indicator AUX_RGBImageRec *TextureImage[1]; // Create Storage Space For The Texture memset(TextureImage,0,sizeof(void *)*1); // Set The Pointer To NULL // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit if (TextureImage[0]=LoadBMP("dat/mf.bmp")) { Status=TRUE; // Set The Status To TRUE glGenTextures(1, &texture[0]); // Create One Texture // Create Linear Filtered Texture glBindTexture(GL_TEXTURE_2D, texture[0]); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data); } if (TextureImage[0]) // If Texture Exists { if (TextureImage[0]->data) // If Texture Image Exists { free(TextureImage[0]->data); // Free The Texture Image Memory } free(TextureImage[0]); // Free The Image Structure } return Status; // Return The Status } GLvoid BuildFont(GLvoid) // Build Our Bitmap Font { HFONT font; // Windows Font ID HFONT oldfont; // Used For Good House Keeping base = glGenLists(96); // Storage For 96 Characters font = CreateFont( -11, // Height Of Font 0, // Width Of Font 0, // Angle Of Escapement 0, // Orientation Angle FW_BOLD, // Font Weight TRUE, // Italic FALSE, // Underline FALSE, // Strikeout ANSI_CHARSET, // Character Set Identifier OUT_TT_PRECIS, // Output Precision CLIP_DEFAULT_PRECIS, // Clipping Precision ANTIALIASED_QUALITY, // Output Quality FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch //"Courier New"); // Font Name "Bodoni MT Black"); //printf("font:%x",font); oldfont = (HFONT)SelectObject(hdc, font); // Selects The Font We Want wglUseFontBitmaps(hdc, 32, 96, base); // Builds 96 Characters Starting At Character 32 SelectObject(hdc, oldfont); // Selects The Font We Want DeleteObject(font); // Delete The Font } void ResizeGl() { char s[100]; glMatrixMode(GL_PROJECTION); glLoadIdentity(); double ox=-(offsetx+mux-mdx)*792.0/winwidth; double oy=(offsety+muy-mdy); if (winwidth/1.8 <= winheight) { glOrtho(-22.5*zoom, 22.5*zoom, -22.5 * (GLfloat)winheight*1.0/(GLfloat)winwidth*zoom, 22.5 * (GLfloat)winheight*1.0/(GLfloat)winwidth*zoom, -20.0, 20.0); imgWidth=-22.5*zoom; //printf("imgWidth000:%f",imgWidth); sprintf(s,"1:%d,%d:%f,%f,%f,%f",winwidth,winheight,-10.5, 10.5, -10.5 * (GLfloat)winheight*1.0/(GLfloat)winwidth, 10.5 * (GLfloat)winheight*1.0/(GLfloat)winwidth); } else { glOrtho(-10.0*(GLfloat)winwidth/(GLfloat)winheight*zoom, 10.0*(GLfloat)winwidth/(GLfloat)winheight*zoom, -10.0*zoom, 10.0*zoom, -20.0, 20.0); imgWidth=-10.0*(GLfloat)winwidth/(GLfloat)winheight*zoom; //printf("imgWidth111:%f",imgWidth); sprintf(s,"2:%d,%d:%f,%f,%f,%f",winwidth,winheight,-10.5*(GLfloat)winwidth/(GLfloat)winheight, 10.5*(GLfloat)winwidth/(GLfloat)winheight, -10.5, 10.5); } glTranslatef(-ox*0.066*zoom,-oy*0.066*zoom,0); //printf(s); //SetProperty(pfm,"caption",s); glMatrixMode(GL_MODELVIEW); } GLvoid ReSizeGLScene(GLsizei width, GLsizei height) // Resize And Initialize The GL Window { if (height==0) // Prevent A Divide By Zero By height=1; // Making Height Equal One winwidth=width; winheight=height; //glViewport(0, 0, (GLsizei)width*1.8, (GLsizei)height*1); glViewport(0 , 0 , (GLsizei)width , (GLsizei)height ); ResizeGl(); glLoadIdentity(); glDrawBuffer(GL_BACK); // added code // Reset The Modelview Matrix } POINT3D pot3d; POINT3D ScreenToGL(int x,int y) { glMatrixMode(GL_MODELVIEW); glPushMatrix(); GLint viewport[4]; GLdouble modelview[16]; GLdouble projection[16]; GLfloat winX, winY, winZ; GLdouble posX, posY, posZ; glGetDoublev( GL_MODELVIEW_MATRIX, modelview ); glGetDoublev( GL_PROJECTION_MATRIX, projection ); glGetIntegerv( GL_VIEWPORT, viewport ); winX = x; winY = viewport[3] - y; glReadPixels( x, (winY), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &winZ ); gluUnProject( winX, winY, winZ, modelview, projection, viewport, &posX, &posY, &posZ); pot3d.x = (float)posX; pot3d.y = (float)posY; pot3d.z = (float)posZ; return pot3d; } #define FT_ENC_TAG( value, a, b, c, d ) \ unsigned int value = ( ( (int)(a) << 24 ) | \ ( (int)(b) << 16 ) | \ ( (int)(c) << 8 ) | \ (int)(d) ) FT_ENC_TAG( FT_ENCODING_UNICODE, 'u', 'n', 'i', 'c' ); int InitGL(GLvoid) // All Setup For OpenGL Goes Here { unsigned short val; val=0x137f; if (!LoadGLTextures()) // Jump To Texture Loading Routine { printf("LoadGLTextures error!"); return FALSE; // If Texture Didn't Load Return FALSE } glEnable(GL_TEXTURE_2D); // Enable Texture Mapping glShadeModel(GL_SMOOTH); // Enable Smooth Shading glClearColor(0.1f, 0.0f, 0.0f, 1.0f); // Black Background glClearDepth(1.0f); // Depth Buffer Setup glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Really Nice Perspective Calculations glBlendFunc(GL_SRC_ALPHA,GL_ONE); // Set The Blending Function For Translucency glEnable(GL_BLEND); BuildFont(); //ft=ftglCreateBufferFont("c:\\windows\\fonts\\BOD_BLAI.TTF"); //__asm__("fldcw %0":"m"(val)); ft=ftglCreateBufferFont("c:\\windows\\fonts\\simhei.TTf"); //ft=ftglCreateBufferFont("ni7seg.TTf"); //__asm__("fldcw %0":"m"(val)); ftglSetFontFaceSize(ft, 80, 72); ftglSetFontDepth(ft, 10); ftglSetFontOutset(ft, 0, 3); ftglSetFontDisplayList(ft,0); ftglSetFontCharMap(ft, FT_ENCODING_UNICODE); //printf("glft:%x,set char map:%d",ft,r); return TRUE; // Initialization Went OK } GLvoid glDrawCube() // 绘制立方体 { glBegin(GL_QUADS); // 前面 glNormal3f( 0.0f, 0.0f, 1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); // 后面 glNormal3f( 0.0f, 0.0f,-1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); // 上面 glNormal3f( 0.0f, 1.0f, 0.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, 1.0f, 1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, 1.0f, 1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); // 下面 glNormal3f( 0.0f,-1.0f, 0.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, -1.0f, -1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); // 右面 glNormal3f( 1.0f, 0.0f, 0.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); // 左面 glNormal3f(-1.0f, 0.0f, 0.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); glEnd(); } unsigned int Start=0; void DrawSinWave() { int i,loop; glEnable(GL_LINE_SMOOTH); glDisable(GL_TEXTURE_2D); for(i=1; i<5; i++) { glLoadIdentity(); // glTranslatef(-12.5f,3.0f,-2.0f ); glLineWidth(1.2f*(5-i)); glColor4f(0.0f,1.0f,0.0f,0.10f*i); glBegin(GL_LINE_STRIP ); for (loop=0; loop<num; loop+=1) //非调制 sine wave glVertex3f((loop+0)*0.1-5,2.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))-5,0); glEnd(); } } void DrawDataWave(int channel,float x,float y,float r,float g,float b) { int i,j,loop; int mid; glEnable(GL_LINE_SMOOTH); glEnable(GL_POLYGON_SMOOTH); glDisable(GL_TEXTURE_2D); glEnable(GL_BLEND); int w=4-wd/300; if(w<0) w=0; if(waveDataCount[channel]+5<maxWaveCount) mid=waveDataCount[channel]+5; else mid=maxWaveCount; for(i=w; i<5; i++) { glLoadIdentity(); glLineWidth(1.2f*(5-i)); glColor4f(r,g,b,0.10f*i); glBegin(GL_LINE_STRIP ); for(j=0; j<=waveDataCount[channel]; j++) { glVertex3f(imgX0+x+j/(6.0-xscale/10.0),y+imgY0+0.035*waveData[channel][j]/(1.0-yscale/50.0),0); } glEnd(); glBegin(GL_LINE_STRIP ); glColor4f(r,g,b,0.02f*i); for(j=waveDataCount[channel]; j<=mid; j++) { glVertex3f(imgX0+x+j/(6.0-xscale/10.0),y+imgY0+0.035*waveData[channel][j]/(1.0-yscale/50.0),0); } glEnd(); glBegin(GL_LINE_STRIP ); glColor4f(r,g,b,0.10f*i); for(j=waveDataCount[channel]+5; j<maxWaveCount; j++) { glVertex3f(imgX0+x+j/(6.0-xscale/10.0),y+imgY0+0.035*waveData[channel][j]/(1.0-yscale/50.0),0); } glEnd(); } glBegin(GL_QUADS); glColor4f(r ,g ,b,0.2f ); glVertex3f(imgX0+x+waveDataCount[channel]/(6.0-xscale/10.0), imgY0, 0.0f); glVertex3f(imgX0+x+(waveDataCount[channel]+5)/(6.0-xscale/10.0), imgY0, 0.0f); glVertex3f(imgX0+x+(waveDataCount[channel]+5)/(6.0-xscale/10.0), imgY0+20, 0.0f); glVertex3f(imgX0+x+ waveDataCount[channel] /(6.0-xscale/10.0), imgY0+20, 0.0f); glEnd(); } void DrawHistogram(int channel,float x,float y,float wd,float r,float g,float b) { glLineWidth(1.0f); glLoadIdentity(); glEnable(GL_BLEND); glBegin(GL_QUADS); glColor4f(r ,g ,b,0.8f ); glVertex3f(x+imgX0,y+imgY0, 0.0f); glVertex3f(x+imgX0+wd,y+imgY0, 0.0f); glColor4f(r ,g ,b,0.2f ); glVertex3f(x+imgX0+wd,y+imgY0+0.015*waveData[channel][waveDataCount[channel]]*(2+yscale/25.0), 0.0f); glVertex3f(x+imgX0,y+imgY0+0.015*waveData[channel][waveDataCount[channel]]*(2+yscale/25.0), 0.0f); glEnd(); glDisable(GL_BLEND); glBegin(GL_LINE_LOOP); glColor4f(r ,g ,b,0.8f ); glVertex3f(x+imgX0,y+imgY0, 0.0f); glVertex3f(x+imgX0+wd,y+imgY0, 0.0f); glColor4f(r ,g ,b,0.8f ); glVertex3f(x+imgX0+wd,y+imgY0+0.015*waveData[channel][waveDataCount[channel]]*(2+yscale/25.0), 0.0f); glVertex3f(x+imgX0,y+imgY0+0.015*waveData[channel][waveDataCount[channel]]*(2+yscale/25.0), 0.0f); glEnd(); glEnable(GL_BLEND); } void DrawGrid() { int i,j; glDisable(GL_TEXTURE_2D); glDisable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA,GL_ONE); glLoadIdentity(); glBegin(GL_QUADS); glColor4f(0.0f,0.1+bkColor/80.0,0.1+bkColor/80.0,1.0f); glVertex3f(imgX0,imgY1, -0.0f); glVertex3f(imgX1,imgY1,-0.0f); glColor4f(0.0f,0.1+bkColor/80.0,0.1+bkColor/80.0,1.0f); glVertex3f(imgX1,imgY0,-0.0f); glVertex3f(imgX0,imgY0, -0.0f); glEnd(); /**/ glEnable(GL_BLEND); glColor4f(0.0f ,0.3f ,0.0f,0.3f ); for(j=0; j<10; j++) for(i=0; i<24; i+=2) { glBegin(GL_QUADS); glVertex3f(imgX0+(i+0+j%2)*(imgX1-imgX0)/24.0+0.04,imgY0+(j+0)*(imgY1-imgY0)/10.0+0.04, 0.0f); glVertex3f(imgX0+(i+1+j%2)*(imgX1-imgX0)/24.0-0.04,imgY0+(j+0)*(imgY1-imgY0)/10.0+0.04, 0.0f); glVertex3f(imgX0+(i+1+j%2)*(imgX1-imgX0)/24.0-0.04,imgY0+(j+1)*(imgY1-imgY0)/10.0-0.04, 0.0f); glVertex3f(imgX0+(i+0+j%2)*(imgX1-imgX0)/24.0+0.04,imgY0+(j+1)*(imgY1-imgY0)/10.0-0.04, 0.0f); glEnd(); } for(j=1; j<3; j++) //draw grid { glLoadIdentity(); // // Reset The View Before We Draw Each Star //glTranslatef(-1.5f,0.0f,-0.0f); glLineWidth(1.2f*(3-j)); // 设置线宽为2.0f glColor4f(0.0f,1.0f,1.0f,0.06f*j); for(i=0; i<=10; i++) { glBegin(GL_LINES); glVertex3f(imgX0,imgY0+i*(imgY1-imgY0)/10.0, 0.0f); glVertex3f(imgX1,imgY0+i*(imgY1-imgY0)/10.0, 0.0f); glEnd(); } for(i=0; i<=24; i++) { glBegin(GL_LINES); glVertex3f(imgX0+i*(imgX1-imgX0)/24.0,imgY0, 0.0f); glVertex3f(imgX0+i*(imgX1-imgX0)/24.0,imgY1, 0.0f); glEnd(); } } glDisable(GL_BLEND); glLineWidth(2.2f); // 设置线宽为2.0f glColor4f(0.0f,1.0f,1.0f,1.0f); /*glBegin(GL_LINE_STRIP); glVertex3f(imgX0,imgY0, 0.0f); glVertex3f(imgX1,imgY0, 0.0f); glVertex3f(imgX1,imgY1, 0.0f); glVertex3f(imgX0,imgY1, 0.0f); glVertex3f(imgX0,imgY0, 0.0f); glEnd(); glEnable(GL_BLEND); glDisable(GL_BLEND); glLoadIdentity(); glColor4f(0.0f ,1.0f ,1.0f,0.6f ); for(i=0; i<24; i++) { glRasterPos2f(imgX0+i*(imgX1-imgX0)/24.0-0.3f, imgY0-0.8); glPrint("%d",i); } for(i=0; i<10; i++) { glRasterPos2f(imgX0-1.0f,imgY0+i*(imgY1-imgY0)/10.0-0.3f); glPrint("%d",i); } */ glEnable(GL_BLEND); } void DrawFrame() { int i,j; glDisable(GL_TEXTURE_2D); glDisable(GL_BLEND); glColor4f(0.0f,0.05f,0.05f,1.0f); //fill mouse glLoadIdentity(); glBegin(GL_QUADS); //left fill glVertex3f(imgX0,imgY0-10, -0.0f); glVertex3f(imgX0,imgY1+10, -0.0f); glVertex3f(imgX0-10,imgY1+10,-0.0f); glVertex3f(imgX0-10,imgY0-10,-0.0f); glEnd(); glBegin(GL_QUADS); //top fill glVertex3f(imgX0-10,imgY1, -0.0f); glVertex3f(imgX1+10,imgY1, -0.0f); glVertex3f(imgX1+10,imgY1+10,-0.0f); glVertex3f(imgX0-10,imgY1+10,-0.0f); glEnd(); glBegin(GL_QUADS); //right fill glVertex3f(imgX1,imgY1+10, -0.0f); glVertex3f(imgX1+10,imgY1+10, -0.0f); glVertex3f(imgX1+10,imgY0-10,-0.0f); glVertex3f(imgX1,imgY0-10,-0.0f); glEnd(); glBegin(GL_QUADS); //bottom fill glVertex3f(imgX0-10,imgY0, -0.0f); glVertex3f(imgX1+10,imgY0, -0.0f); glVertex3f(imgX1+10,imgY0-10,-0.0f); glVertex3f(imgX0-10,imgY0-10,-0.0f); glEnd(); glColor4f(0.0f ,0.3f ,0.0f,0.3f ); //glDisable(GL_BLEND); glLineWidth(1.0f); // 设置线宽为2.0f glColor4f(0.0f,1.0f,1.0f,1.0f); glEnable(GL_BLEND); if((dispClock==1)||(dispDigit==1)) // { glLineWidth(2.0f); glColor4f(0.0f,1.0f,1.0f,0.5+1.0f*bkColor/80.0); glBegin(GL_LINE_STRIP); glVertex3f(imgX0,imgY0, 0.0f); glVertex3f(imgX1,imgY0, 0.0f); glVertex3f(imgX1,imgY1, 0.0f); glVertex3f(imgX0,imgY1, 0.0f); glVertex3f(imgX0,imgY0, 0.0f); glEnd(); } glEnable(GL_BLEND); if(dispClock) return; if(dispDigit) return; glEnable(GL_BLEND); glDisable(GL_BLEND); glLoadIdentity(); glEnable(GL_BLEND); glLineWidth(1.0f); glBegin(GL_LINES); glVertex3f(imgX0,imgY0-0.2, 0.0f); glVertex3f(imgX1,imgY0-0.2, 0.0f); glVertex3f(imgX0-0.2,imgY0, 0.0f); glVertex3f(imgX0-0.2,imgY1, 0.0f); glEnd(); for(i=0; i<=24*5; i++) { if(i%5==0) glLineWidth(2.0f); else glLineWidth(1.0f); glBegin(GL_LINES); glVertex3f(imgX0+i*(imgX1-imgX0)/(24.0*5) ,imgY0-0.2, 0.0f); if(i%5==0) glVertex3f(imgX0+i*(imgX1-imgX0)/(24.0*5) ,imgY0-0.8, 0.0f); else glVertex3f(imgX0+i*(imgX1-imgX0)/(24.0*5) ,imgY0-0.6, 0.0f); glEnd(); } for(i=0; i<=10*5; i++) { if(i%5==0) glLineWidth(2.0f); else glLineWidth(1.0f); glBegin(GL_LINES); glVertex3f(imgX0-0.2,imgY0+i*(imgY1-imgY0)/(10.0*5), 0.0f); if(i%5==0) glVertex3f(imgX0-0.8,imgY0+i*(imgY1-imgY0)/(10.0*5), 0.0f); else glVertex3f(imgX0-0.6,imgY0+i*(imgY1-imgY0)/(10.0*5), 0.0f); glEnd(); } glLineWidth(1.0f); glColor4f(0.0f ,1.0f ,1.0f,1.0f ); for(i=0; i<=24; i+=2) { glLoadIdentity(); glTranslatef(imgX0+i*(imgX1-imgX0)/24.0-0.8f, imgY0-1.6,0); //glRasterPos2f(imgX0+i*(imgX1-imgX0)/24.0-0.3f, imgY0-0.8); //glPrint("%d",i); glScalef(0.04,0.04,1); glShxPrint("%2d",i); } for(i=0; i<=10; i+=2) { glLoadIdentity(); glTranslatef(imgX0-2.0f,imgY0+i*(imgY1-imgY0)/10.0-0.3f,0); //glRasterPos2f(imgX0-1.0f,imgY0+i*(imgY1-imgY0)/10.0-0.3f); //glPrint("%d",i); if(i==10) glTranslatef(-0.5,0,0); glScalef(0.04,0.04,1); glShxPrint("%2d",i*10); } glEnable(GL_BLEND); } void DrawCube(float x,float y,float z,float scale) { glEnable(GL_TEXTURE_2D); //glDisable(GL_BLEND); glColor4f(0.3f,0.3f,1.0f,0.6f); glLoadIdentity(); // // Reset The View Before We Draw Each Star glTranslatef(x,y,z); glScalef(scale,scale,scale); glRotatef(framecount*1,framecount*1,framecount*2,1.0f); glDrawCube(x,y,z); // glEnable(GL_BLEND); } void RoundRect1( float divide, //圆角细分数量 float cirr, //内圆角半径 float cirR, //外圆角半径 float w, //内矩形宽度 float h, //内矩形高度 float W, //外矩形宽度 float H) //外矩形高度 { } void DrawMouseCursor() { glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glLoadIdentity(); POINT3D p3=ScreenToGL(mx,my); POINT3D pd3=ScreenToGL(mdx,mdy); POINT3D pu3=ScreenToGL(mux,muy); glDisable(GL_TEXTURE_2D); glTranslatef(p3.x,p3.y,0.0f); if(md) glRotatef(framecount*3,0,0,1.0f); glColor4f(1.0f,0.0f,0.0f,0.6f); //fill mouse glBegin(GL_QUADS); glVertex3f(0.3f,-0.3f, -20.0f); glVertex3f(-0.3f,-0.3f, -20.0f); glVertex3f(-0.3f,0.3f,-20.0f); glVertex3f(0.3f,0.3f,-20.0f); glEnd(); glColor4f(1.0f,0.0f,0.0f,1.0f); //frame mouse glLineWidth(1.5f); glBegin(GL_LINE_LOOP); glVertex3f(-0.45f,-0.45f, 0.0f); glVertex3f(0.45f,-0.45f, 0.0f); glVertex3f(0.45f,0.45f,0.0f); glVertex3f(-0.45f,0.45f,0.0f); glEnd(); glLineWidth(1.0f); glBegin(GL_LINES); //mouse cross line glVertex3f(-1.9f,0, 0.0f); glVertex3f(1.9f,0, 0.0f); glVertex3f(0,-1.9f,0.0f); glVertex3f(0,1.9f,0.0f); glVertex3f(-1.9f,0, 0.0f); glVertex3f(0+1.9f,0, 0.0f); glVertex3f(0,-1.9f,0.0f); glVertex3f(0,1.9f,0.0f); glEnd(); glLoadIdentity(); return; if(mdx!=-1) { glColor4f(0.0f,1.0f,0.0f,0.3f); glBegin(GL_QUADS); glVertex3f(pu3.x,pu3.y, -10.0f); glVertex3f(pd3.x,pu3.y, -10.0f); glVertex3f(pd3.x,pd3.y, -10.0f); glVertex3f(pu3.x,pd3.y, -10.0f); glEnd(); glLineWidth(1.5f); glColor4f(1.0f,0.0f,0.0f,1.0f); if(pu3.x<pd3.x)SwapFolat(&(pu3.x),&(pd3.x)); if(pu3.y>pd3.y)SwapFolat(&pu3.y,&pd3.y); if((pu3.x-pd3.x<2.0f)||(pd3.y-pu3.y<2.0f)) { glBegin(GL_LINE_LOOP); glVertex3f(pu3.x,pu3.y, -10.0f); glVertex3f(pd3.x,pu3.y, -10.0f); glVertex3f(pd3.x,pd3.y, -10.0f); glVertex3f(pu3.x,pd3.y, -10.0f); glEnd(); } else { glBegin(GL_LINES); glVertex3f(pd3.x,pd3.y, -10.0f); glVertex3f(pd3.x+1,pd3.y, -10.0f); glVertex3f(pd3.x,pd3.y, -10.0f); glVertex3f(pd3.x,pd3.y-1, -10.0f); glVertex3f(pu3.x,pd3.y, -10.0f); glVertex3f(pu3.x-1,pd3.y, -10.0f); glVertex3f(pu3.x,pd3.y, -10.0f); glVertex3f(pu3.x,pd3.y-1, -10.0f); glVertex3f(pu3.x,pu3.y, -10.0f); glVertex3f(pu3.x-1,pu3.y, -10.0f); glVertex3f(pu3.x,pu3.y, -10.0f); glVertex3f(pu3.x,pu3.y+1, -10.0f); glVertex3f(pd3.x,pu3.y, -10.0f); glVertex3f(pd3.x+1,pu3.y, -10.0f); glVertex3f(pd3.x,pu3.y, -10.0f); glVertex3f(pd3.x,pu3.y+1, -10.0f); glEnd(); } } } void DrawRectangSinWave() { int i; glLoadIdentity(); // Reset The Current Modelview Matrix glTranslatef(-1.5f+1.40*sin(3.14*3.0*Start/360.0),-1.6f,-4.0f); // Move One Unit Into The Screen glColor4f(0.0f ,1.0f ,0.0f,0.3f ); for(i=0; i<8; i++) { glBegin(GL_QUADS); glVertex3f(-6.0+0.0f+i*2,-7.0f, 0.0f); glVertex3f(-6.0+1.2f+i*2,-7.0f, 0.0f); glVertex3f(-6.0+1.2f+i*2,8.5f+2*sin(i)*sin(3.14*3.0*Start/360.0),0.0f); glVertex3f(-6.0+0.0f+i*2,8.5f+2*sin(i)*sin(3.14*3.0*Start/360.0),0.0f); glEnd(); } } void DrawFpsInfo() { int i=0; //for(i=0; i<15; i++) { glLoadIdentity(); glColor4f(0.0f ,1.0f ,0.0f,1.0f ); glTranslatef(imgX0+5,imgY1+0.5-i*1.2,0); glLineWidth(0.8f ); //glRasterPos2f(imgX0+8,imgY1+1); int sec=(GetTickCount()-starttime)/1000; if(sec==0)sec=1; //glPrint(" 示波器软件 OSCILLOSCOPE %03d [%03d,%03d] fps:%03d",Start,mx,my,framecount/sec); // Print GL Text To The Screen glScalef(0.04,0.04,1); glShxPrint("示波器软件 -- OSCILLOSCOPE %03d [%03d,%03d] FPS:%03d",Start,mx,my,framecount/sec); // Print GL Text To The Screen } } int DrawGLScene(GLvoid) // Here's Where We Do All The Drawing { int i,j; char s[40]; if(closing) return 0; unsigned char dat; double ox=(offsetx+mux-mdx); double oy=(offsety+muy-mdy); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear The Screen And The Depth Buffer glBindTexture(GL_TEXTURE_2D, texture[0]); // Select Our Texture Start+=1; Start%=720; DrawGrid(); //DrawSinWave(); if(dispWave) { for(i=0; i<16; i++) if(DispChannel[i]==1) DrawDataWave(i,0,3+i*6,0,1,i); } if(dispHisto==1) { DrawHistogram(0,6,0,8,0,1,0); DrawHistogram(1,20,0,8,1,0,0); // DrawRectangDataWave(2,10,0,2,1,0,1); } DrawFrame(); //DrawCube(-20.0f, 9.0f,0.0f,0.5f); //DrawCube(-18.0f, 9.0f,0.0f,0.5f); //RoundRect1(40.0, 10.0, 20.0, 25.0,25.0, 26.0,26.0); //DrawRectangSinWave(); DrawFpsInfo(); ////////glDisable(GL_BLEND); glEnable(GL_LINE_SMOOTH); glEnable(GL_POLYGON_SMOOTH); //glHint(GL_LINE_SMOOTH_HINT, GL_NICEST); glLineWidth(1.0f); if(dispClock) { DrawClock(-8,0.01,0, 0.5,0.5,1.0,6.7,7.85," CH01",waveData[0][waveDataCount[0]]); DrawClock(10 ,0.01 ,0,1,1,1,6.7,7.85," CH02",waveData[1][waveDataCount[1]]); //DrawClock(-2,-1,0, 1.0,0,0,4.11,4.61); //DrawClock(7.0,3,0, 0.0,1,0,4.11,4.61); } if(dispDigit) { dat=waveData[0][waveDataCount[0]]; Draw7Seg((dat%1000)/100,-19+0*6.0 ,-6.8, 0, 1.35, 0,1,0,0.3,4.0,0.6,0.1); Draw7Seg((dat%100)/10, -19+1*6.0 ,-6.8, 0, 1.35, 0,1,0,0.3,4.0,0.6,0.1); Draw7Seg((dat%10)/1, -19+2*6.0 ,-6.8, 0, 1.35, 0,1,0,0.3,4.0,0.6,0.1); dat=waveData[1][waveDataCount[0]]; Draw7Seg((dat%1000)/100, 1+0*6.0 ,-6.8, 0, 1.35, 1,0,0,0.5,4.0,0.6,0.1); Draw7Seg((dat%100)/10, 1+1*6.0 ,-6.8, 0, 1.35, 1,0,0,0.5,4.0,0.6,0.1); Draw7Seg((dat%10)/1, 1+2*6.0 ,-6.8, 0, 1.35, 1,0,0,0.5,4.0,0.6,0.1); } DrawMouseCursor(); framecount++; SwapBuffers(hdc); return TRUE;// // Everything Went OK } void OnTest() { DispChannel[0]= GetProperty(cbDisp1,"checked",0,0); DispChannel[1]= GetProperty(cbDisp2,"checked",0,0); NeedRedraw=1; } void OnResize() { int x,y; x=GetProperty(pfm,"width",0,0); y=GetProperty(pfm,"height",0,0); ReSizeGLScene(x,y); wd=x; ht=y; //printf("%d",wd); NeedRedraw=1; } void OnMouseWheel(int id, int state,int wheelDelta,int pos,int handled) { zoom+= -wheelDelta/12000.0*4.0; if(zoom<0.1)zoom=0.1; //glViewport(0-winwidth*(zoom-1.0)*0.5, 0-winheight*(zoom-1.0)*0.5, (GLsizei)winwidth*zoom, (GLsizei)winheight*zoom); //printf("mouse wheel:%d,%f",wheelDelta,zoom); ResizeGl(); NeedRedraw=1; //glMatrixMode(GL_PROJECTION); //glLoadIdentity(); //glScalef(0.045*zoom,0.1*zoom,0.1); //glTranslatef(0.06*(offsetx+mux-mdx)/zoom ,0.06*(offsety+mdy-muy)/zoom,0.1); //SetProperty(pfm,"caption",s); //glMatrixMode(GL_MODELVIEW); } void OnMouseMove(int id,int state,int x,int y) { int h=0; int h1=0; if(GuiMode==2) { //h=GetSystemMetrics(SM_CYCAPTION); //h1=GetSystemMetrics(SM_CXFRAME); } mx=x; my=y; if(md) { mux=mx; muy=my; OnMouseWheel(0,0,0,0,0); } NeedRedraw=1; } void OnMouseDown(int id,int btn,int state,int x,int y) { mdx=x; mdy=y; if(GuiMode!=2) mdy+=30; mux=x; muy=y; if(GuiMode!=2) muy+=30; md=1; NeedRedraw=1; mx=x; my=y; } void OnMouseUp(int id,int btn,int state,int x,int y) { mux=x; muy=y ; if(GuiMode!=2) muy+=30; md=0; NeedRedraw=1; offsetx+=mux-mdx; offsety-=mdy-muy; mx=x; my=y; mdx=mux; mdy=muy; } void AddWaveDataByte(int channel,unsigned char dat) { waveDataCount[channel]++; waveDataCount[channel]%=maxWaveCount; waveData[channel][waveDataCount[channel]]=dat;//*0.015f; NeedRedraw=1; } void AddWaveDataBuf(int channel,unsigned char *buf,int count) { int i; for(i=0; i<count; i++) { waveDataCount[channel]++; waveDataCount[channel]%=maxWaveCount; waveData[channel][waveDataCount[channel]]=buf[i];//*0.015f; } NeedRedraw=1; } void OnPaint() { NeedRedraw=1; } int RandVal(int max) { return 1+(int)(max*1.0*rand()/(RAND_MAX+1.0)); } void OnTimer() { int i; double si; unsigned char dat; if(closing) return; //for(i=0; i<2; i++) // AddWaveDataByte(0,RandVal(255)); for(i=0; i<2; i++) { si= 127+127.0*sin(3.1415*(framecount%201)/100); AddWaveDataByte(1,si); AddWaveDataByte(0,255-si); //printf("%f",200.0*sin(3.1415*(framecount%41)/20)); } for(i=0; i<2; i++) AddWaveDataByte(2,RandVal(255)); //printf("a"); } void OnSimDat() { int i; if(GetProperty(cbSimDat,"checked",0,0)==1) SetProperty(tmrSimDat,"enabled",1); else { SetProperty(tmrSimDat,"enabled",0); for(i=0; i<1024; i++) { AddWaveDataByte(0,0); AddWaveDataByte(1,0); } } } void OnXScaleClick(int sender) { xscale=GetProperty(tbxscale,"Position",0,0); maxWaveCount=(imgX1-imgX0) *(6.0-xscale/10.0); yscale=GetProperty(tbyscale,"Position",0,0); bkColor=GetProperty(tbbkclr,"Position",0,0); dispHisto=GetProperty(cbHisto,"checked",0,0); dispClock=GetProperty(cbClock,"checked",0,0); dispDigit=GetProperty(cbDigit,"checked",0,0); dispWave=GetProperty(cbWave,"checked",0,0); //printf("maxWaveCount:%d",maxWaveCount); if(sender==cbClock) { if(dispClock==1) SetProperty(tbbkclr,"Position",30,0); } else { if((sender==cbHisto)||(sender==cbDigit)||(sender==cbWave)) SetProperty(tbbkclr,"Position",1,0); } DrawGLScene(); } void main() { int i,j; int mi,mi1; double tmp; //HideLeftTools(); ClearVclControls(); GuiMode=2; //HideVclWin(-1); if((GuiMode==0)||(GuiMode==1)) { pfm=GetGuiWin(GuiMode); pfm=CreateComponentEx(pfm,"panel","caption","示波器","Width",900,"height",400,"BorderIcons","[biSystemMenu,biMaximize]","position","poMainFormCenter","formstyle","fsstayontop","cursor",-1,"OnClose",FormDestroy,"OnResize",OnResize,"OnMouseDown",OnMouseDown,"OnMouseUp",OnMouseUp,"OnMouseMove",OnMouseMove,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] pfm0=pfm; } else { pfm0=CreateComponentEx(0,"form","caption","示波器","Width",900,"height",400,"BorderIcons","[biSystemMenu,biMaximize]","position","poMainFormCenter","formstyle","fsstayontop","OnClose",FormDestroy,"OnPaint",OnPaint,"OnMouseWheel",OnMouseWheel,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] pfm=CreateComponentEx(pfm0,"panel","caption","示波器","Left",10,"top",10,"Width",800,"height",380,"Anchors","[akLeft,akTop,akRight,akBottom]","cursor",-1, "OnMouseDown",OnMouseDown,"OnMouseUp",OnMouseUp,"OnMouseMove",OnMouseMove,"OnResize",OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] //pfm=CreateComponentEx(0,"form","caption","示波器","Width",900,"height",400,"BorderIcons","[biSystemMenu,biMaximize]","position","poMainFormCenter","formstyle","fsstayontop","cursor",-1,"OnClose",FormDestroy,"OnResize",OnResize,"OnMouseDown",OnMouseDown,"OnMouseUp",OnMouseUp,"OnMouseMove",OnMouseMove,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] //pfm0=pfm; } //int btn=CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); tmrSimDat=CreateComponentEx(pfm0,"timer","interval",25,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 cbDisp1=CreateComponentEx(pfm0,"CheckBox","caption","通道1","left",820,"top",5,"width",60,"height",20,"Anchors","[akTop,akRight]","checked",1,"OnClick",OnTest,0); cbDisp2=CreateComponentEx(pfm0,"CheckBox","caption","通道2","left",820,"top",25,"width",60,"height",20,"Anchors","[akTop,akRight]","checked",0,"OnClick",OnTest,0); cbSimDat=CreateComponentEx(pfm0,"CheckBox","caption","模拟数据","left",820,"top",45,"width",60,"height",20,"Anchors","[akTop,akRight]","checked",1,"OnClick",OnSimDat,0); CreateComponentEx(pfm0,"label","left",820,"top",80,"width",80,"height",20,"Anchors","[akTop,akRight]","caption","X轴比例：",0); tbxscale=CreateComponentEx(pfm0,"TrackBar","left",810,"top",95,"width",80,"height",20,"max",50,"Anchors","[akTop,akRight]","OnChange",OnXScaleClick,0); CreateComponentEx(pfm0,"label","left",820,"top",125,"width",80,"height",20,"Anchors","[akTop,akRight]","caption","Y轴比例：",0); tbyscale=CreateComponentEx(pfm0,"TrackBar","left",810,"top",140,"width",80,"height",20,"max",50,"Anchors","[akTop,akRight]","OnChange",OnXScaleClick,0); CreateComponentEx(pfm0,"label","left",820,"top",170,"width",80,"height",20,"Anchors","[akTop,akRight]","caption","背景亮度：",0); tbbkclr=CreateComponentEx(pfm0,"TrackBar","left",810,"top",185,"width",80,"height",20,"max",50,"position",0,"Anchors","[akTop,akRight]","OnChange",OnXScaleClick,0); cbWave=CreateComponentEx(pfm0,"radiobutton","caption","波形图","left",820,"top",215,"width",60,"height",20,"Anchors","[akTop,akRight]","checked",1,"OnClick",OnXScaleClick,0); cbHisto=CreateComponentEx(pfm0,"radiobutton","caption","柱状图","left",820,"top",235,"width",60,"height",20,"Anchors","[akTop,akRight]","checked",0,"OnClick",OnXScaleClick,0); cbClock=CreateComponentEx(pfm0,"radiobutton","caption","仪表盘","left",820,"top",255,"width",60,"height",20,"Anchors","[akTop,akRight]","checked",0,"OnClick",OnXScaleClick,0); cbDigit=CreateComponentEx(pfm0,"radiobutton","caption","数值显示","left",820,"top",275,"width",80,"height",20,"Anchors","[akTop,akRight]","checked",0,"OnClick",OnXScaleClick,0); maxWaveCount=(imgX1-imgX0)*6; FormCreate(); OnResize(); InitGL(); sfHz=CreateShxFont("dat\\HZTXT.SHX"); sfHz->scale=1.50;// //printf("hz scale:%f",GetShxFontScale(sfHz)); //sfChar=CreateShxFont("dat\\IC-italicc.shx"); //sfChar=CreateShxFont("dat\\HAND1.SHX"); //sfChar=CreateShxFont("dat\\gdt.SHX"); sfChar=CreateShxFont("dat\\txt.SHX"); DrawGLScene(); starttime=GetTickCount(); SetProperty(pfm0,"visible",1); SetProperty(pfm,"OnMouseMove",OnMouseMove); OnXScaleClick(0); OnTest(); //ClearOutputWin(); int count=0; while(!closing) { if(NeedRedraw) { NeedRedraw=0; DrawGLScene(); } //sleep(1); count++; if(count%2==1) { Wait(1); } } SetProperty(tmrSimDat,"enabled",0); OnClose(); KillFont(); wglMakeCurrent(NULL,NULL); wglDeleteContext(hglrc); DeleteObject(hdc); FreeShxFont(sfChar); FreeShxFont(sfHz); printf("exit"); } void MainFormClose() { closing=1; Wait(2); } void OnTerminate() { closing=1; printf("terminate"); Wait(2); }" /> 
  <Command cmdname="数据示波器" cmdType="P" cmd="[P]#pragma comment(lib,"lib\\oscilloscope.o") #pragma comment(lib,"lib\\ftgl.def"); void RecvSerialData(unsigned char *buf,int count)//串口接收到数? { int i; //for(i=0; i<count; i++) // AddWaveDataByte(0,buf[i]); AddWaveDataBuf(0,buf,count); } void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { AddWaveDataBuf(0,buf,count); } void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { AddWaveDataBuf(0,buf,count); }" /> 
  </Command>
- <Command cmdname="嵌入式开发" cmdType="S" cmd="[S]=====数据发送区/C语言脚本编辑区===== 1.[F5]键发送/执行、[F4]键终止脚本运行。 2.[F8]键显示、隐藏输出栏。 3.[Ctrl+.]调出脚本接口函数列表、[Ctrl+/]提示函数参数信息、[Ctrl+P]列出代码模板。 4.[Ctrl+Enter]发送数据。 5.支持"预处理"功能，采用C语言脚本回调函数，对发送的数据进行预处理后发送。">
  <Command cmdname="2410/2440 DNW" cmdType="P" cmd="[P]#include "windows.h" void OpenFileClick(void *sender); void DownLoadClick(void *sender); void CancelClick(void *sender); void AddFileToLv(unsigned char* s,unsigned char *time,int save); void UpdateLv(); int edt1; int cancel; int pgb1; int txt6; int edt2; int tmr1; int txt2,btn2,btn3,lv; int cb1; char *sIID="{8e120c45-4968-4188-ba19-9a82361c8fa8}";//usb 驱动程序 IID #include "windows.h" void DropFileFromTFtpServer(char* filename) { char s[200]; printf("get tftp file:%s",filename); sprintf(s,"tftp -g -r %s 192.168.11.2",filename); #if 0 if(MessageBox(GetAppHandle(),s,"是否执行命令？",4)==6) #endif SendString(s); } void DropFileToTFtpServer(char* filename) { char s[200]; printf("Send tftp file:%s",filename); sprintf(s,"tftp -p -l %s 192.168.11.2",filename); #if 0 if(MessageBox(GetAppHandle(),s,"是否执行命令？",4)==6) #endif SendString(s); } void CommWinDbClick() { char s[100]; char s1[20]; int len1=-1; int i; int len=GetCommWinSelText(s,100); int ck= GetProperty(cb1,"checked",NULL,0); //printf("checked:%d",ck); if(ck==0)return; for(i=0; i<len; i++) { if(len1==-1) { if((s[i]>='0')&&(s[i]<='9')) { len1=0; s1[len1++]=s[i]; } } else { if((s[i]>='0')&&(s[i]<='9')) { s1[len1++]=s[i]; if(len1>10)break; } else break; } } printf("len:%d-[%s]",len,s); if(len1>0) { s1[len1]=0; len1=atoi(s1); printf(s1); printf("%d",len1); sprintf(s,"数据内容:[%s]",s1); #if 0 int opt=MessageBox(GetAppHandle(),s,"是否发送数据？",4); printf("opt:%d",opt); if(opt==6) #endif SendString(s1); } } void DownLoad() { char s[200]; CHAR *pBuffer; DWORD RSize; int fileSize = 0; int i; cancel=0; SetProperty(btn2,"enabled",0); SetProperty(btn3,"enabled",1); SetProperty(pgb1,"position",0); SetProperty(txt6,"caption","0%"); int iTmp=GetPathName(sIID,s,200); if(iTmp>0) //devName~="" then printf("Usb device PathName:%s",s); else { ShowMessage("Usb host not connected!"); return ; } sprintf(s,"%s\\\\PIPE01",s); printf("usb name:%s",s); HANDLE Handle=CreateFile(s, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL); if (Handle<=0) { printf("打开文件%s错误！",s); return; } GetProperty(edt1,"text",s,200); SaveIniString("DNW","FileName",s); AddFileToLv(s,0,1); GetProperty(edt2,"text",s,200); SaveIniString("DNW","Address",s); GetProperty(edt1,"text",s,200); HANDLE Handle1=CreateFile(s, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL); printf("发送文件名称：%s",s); if(Handle1<=0) { sprintf(s,"打开文件【%s】错误！",s); ShowMessage(s);//"打开文件【"..pb.edit1.text.."】错误！"); return ; } int Length =SetFilePointer(Handle1,0,NULL,FILE_END); SetFilePointer(Handle1,0,NULL,FILE_BEGIN); char *Buffer = malloc(Length + 10); // --addr(4bytes)+length(4bytes)+filedata(length bytes)+checksum(2bytes) int BytesRead ; ReadFile(Handle1, Buffer+8, Length,&BytesRead,NULL); CloseHandle(Handle1); GetProperty(edt2,"text",s,200); int downloadAddress=StrToInt(s); //0x32000000; printf("Address:0x%x",downloadAddress); Buffer[0]=(downloadAddress>>0)&0xff; Buffer[1]=(downloadAddress>>8)&0xff; Buffer[2]=(downloadAddress>>16)&0xff; Buffer[3]=(downloadAddress>>24)&0xff; int len1=Length+10; Buffer[4]=(len1>>0)&0xff; Buffer[5]=(len1>>8)&0xff; Buffer[6]=(len1>>16)&0xff; Buffer[7]=(len1>>24)&0xff; unsigned short cs=0; for(i=0; i<Length; i++) { cs+=Buffer[8+i]; // 计算校验和 } cs&=0xffff; // --取16bits printf("check sum is :%x",cs); Buffer[Length+8]=(cs>>0)&0xff; Buffer[Length+9]=(cs>>8)&0xff; Length=Length+10;//addr(4bytes)+length(4bytes)+filedata(length bytes)+checksum(2bytes) int TxBufCount=0; int txBlkSize=0; int TX_SIZE=4096*4; int BytesWrite ; printf("Download to device ..."); Update(); while(1) { if (cancel==1)break; if((Length-TxBufCount) > TX_SIZE) txBlkSize =TX_SIZE; else txBlkSize = Length-TxBufCount; //printf("filewrite:%d...", txBlkSize); int wlen=WriteFile( Handle, Buffer+TxBufCount, txBlkSize, &BytesWrite,NULL); //printf("wrote %d",BytesWrite); if(BytesWrite<=0) { printf("下载失败，请重新启动开发板！"); CloseHandle(Handle); free(Buffer); return; }; TxBufCount =TxBufCount+txBlkSize; float fPer=1.0f; //fPer= int per=((TxBufCount+1)*100)/Length; SetProperty(pgb1,"position",per); sprintf(s,"%d%s",per,"%"); SetProperty(txt6,"caption",s); Update(); //printf("write %d of %d:%d%",TxBufCount,Length,per); if (TxBufCount>= Length) break; Wait(0); }; printf("close file ..."); CloseHandle(Handle); printf("free mem ..."); free(Buffer); printf("Download end"); SetProperty(btn2,"enabled",1); SetProperty(btn3,"enabled",0); } void OnTimer() { char s[200]; //printf("aaa"); int iTmp=GetPathName(sIID,s,200); //printf("bbb"); if(iTmp>0) //devName~="" then { //printf("Usb device PathName:%s",s); SetProperty(txt2,"caption"," USB:OK"); SetProperty(txt2,"color",0x00ff00); SetProperty(btn2,"enabled",1); } else { //printf("Usb device PathName:%s",s); SetProperty(txt2,"caption"," USB:x"); SetProperty(txt2,"color",0x0000ff); SetProperty(btn2,"enabled",0); } //printf("ccc"); UpdateLv(); //printf("ddd"); } void Save() { int i; char s1[200],s2[200]; int count=GetListViewItemCount(lv); sprintf(s1,"%d",count); SaveIniString("DNW","FileCount",s1); for(i=0; i<count; i++) { GetListViewItem(lv,i,2,s1,200); sprintf(s2,"FileName%d",i); SaveIniString("DNW",s2,s1); GetListViewItem(lv,i,0,s1,200); sprintf(s2,"FileDt%d",i); SaveIniString("DNW",s2,s1); } } void KeyBtnClick(void *Sender) { int tag,t; t=GetProperty(Sender,"tag",&tag,4); printf("tag:%d",t); SendByte(t); } void DelClick(void *Sender) { int idx; idx=GetListViewItemIndex(lv); DelListViewItem(lv,idx); Save(); } void ClearClick(void *Sender) { while(GetListViewItemCount(lv)>0) DelListViewItem(lv,0); Save(); } void lvDbClick(void *Sender) { int idx; char s1[200]; idx=GetListViewItemIndex(lv); GetListViewItem(lv,idx,2,s1,200); SetProperty(edt1,"text",s1); } void CloseClick(void *Sender) { //UpdateLv(); //return; ClearOutputWin(); //清除输出窗口内容 HideVclWin(); // printf("hided"); CloseVclWin(); } void main() { ClearOutputWin(); //清除输出窗口内容 //ClearCommWin(); CloseInputWin(); ClearVclControls(); printf("=============SAMSUNG S3C2410/2440 USB 下载工具(DNW)=============="); int p=GetGuiWin(); int pnl = CreateComponentEx(p,"panel","caption","","left",2,"top",2,"width",650,"height",230,NULL); int txt1= CreateComponentEx(pnl,"label","caption"," SAMSUNG S3C2410/2440 USB 下载工具(DNW)","left",30,"top",10,"width",350,"color",0xff00ff,NULL); txt2= CreateComponentEx(pnl,"label","caption"," USB:x","left",385,"top",10,"width",60,"autosize",0,"color",0x0000ff,NULL); int txt3= CreateComponentEx(pnl,"label","caption","文件名称：","left",10,"top",40,"width",60,NULL); edt1= CreateComponentEx(pnl,"edit", "text","请输入文件名...","left",75,"top",38,"width",385,NULL); int txt4= CreateComponentEx(pnl,"label","caption","下载地址：","left",10,"top",68,"width",60,NULL); edt2= CreateComponentEx(pnl,"edit", "text","0x32000000","left",75,"top",65,"width",90,NULL); int txt5= CreateComponentEx(pnl,"label","caption","下载进度：","left",170,"top",68,"width",60,NULL); txt6= CreateComponentEx(pnl,"label","caption","0%","left",228,"top",68,"width",40,NULL); pgb1= CreateComponentEx(pnl,"progressbar","left",258,"top",65,"width",200,"height",20,"position",0,NULL); cb1= CreateComponentEx(pnl,"checkbox","left",460,"top",65,"width",90,"height",20,"caption","双击直接操作",NULL); int btn1= CreateComponentEx(pnl,"button","caption","...","left",465,"top",36,"width",65,"onclick",OpenFileClick,NULL); btn2= CreateComponentEx(pnl,"button","caption","通过USB下载","left",535,"top",10,"width",105,"height",50,"onclick",DownLoadClick,NULL); btn3= CreateComponentEx(pnl,"button","caption","取 消","left",555,"top",65,"width",85,"onclick",CancelClick,NULL); CreateComponentEx(pnl,"button","caption","删 除","left",555,"top",110,"width",85,"onclick",DelClick,NULL); CreateComponentEx(pnl,"button","caption","清 空","left",555,"top",140,"width",85,"onclick",ClearClick,NULL); CreateComponentEx(pnl,"button","caption","关 闭","left",555,"top",190,"width",85,"onclick",CloseClick,NULL); int key_left=370; int key_top=10; lv=CreateComponentEx(pnl,"listview","left",12,"top",95,"width",540,"height",125,"ondblclick",lvDbClick,NULL); AddListViewColumn(lv,"更新",40); AddListViewColumn(lv,"下载时间",115); AddListViewColumn(lv,"更新时间",115); AddListViewColumn(lv,"文件名称",880); tmr1=CreateComponentEx(p,"timer","interval",1000,"enabled",0,"ontimer",OnTimer,NULL);//创建按钮 //ShowVclWin(230+8); //ShowOutputWin(330); CloseCodeWin(); HideLeftTools(); HideRightTools(); ShowTerminalWin(); PrintToCommWin(" "); PrintToCommWin(" "); //PrintToCommWin("           "); //PrintToCommWin("              "); //PrintToCommWin("               "); //PrintToCommWin("             "); //PrintToCommWin("           "); //PrintToCommWin("             "); /**/ char s[200],s1[200],s2[200]; GetIniString("DNW","FileName",s,200); SetProperty(edt1,"text",s); GetIniString("DNW","Address",s,200); SetProperty(edt2,"text",s); AutoSetVclWinSize(); //printf("1..."); GetIniString("DNW","FileCount",s,200); //printf("2..."); //printf("s:%s",s); if(strlen(s)>0) { int count=StrToInt(s); //printf("2.1"); int i; for(i=0; i<count; i++) { //printf("2.i:%d",i); sprintf(s2,"FileName%d",i); GetIniString("DNW",s2,s,200); sprintf(s2,"FileDt%d",i); GetIniString("DNW",s2,s1,200); AddFileToLv(s,s1,0); } } //printf("3..."); UpdateLv(); char *IID="{8e120c45-4968-4188-ba19-9a82361c8fa8}";//usb 驱动程序 IID SetProperty(btn2,"enabled",0); int addCount=0; SetProperty(tmr1,"enabled",1); DragAcceptFiles(GetWinHandle(lv),1); DragAcceptFiles(GetWinHandle(edt1),1); SetMenuItemText(0,"tftp 快速传输"); printf("inited"); } void MenuItemClick(int idx) { printf("MenuItem %d clicked!",idx); if(idx==0) { char s[100]; int len=GetCommWinSelText(s,100); char buf[100]; sprintf(buf,"tftp -s -l ./%s 192.168.11.2\n",s); SendString(buf); } } void DropFile(int handle,unsigned char *filename) { if(handle==GetWinHandle(edt1)) { SetProperty(edt1,"text",filename); SaveIniString("DNW","FileName",filename); } else if(handle==GetWinHandle(lv)) { AddFileToLv(filename,0,1); } //printf("handle:%x,filename:%s",hd,filename); } void AddFileToLv(unsigned char* s,unsigned char *time,int save) { char s1[200],s2[200]; int i,idx; idx=-1; int count=GetListViewItemCount(lv); for(i=0; i<count; i++) { GetListViewItem(lv,i,2,s1,200); if(strcmp(s,s1)==0) { idx=i; break; } } if(idx==-1) { StringsAdd(lv,""); idx=GetListViewItemCount(lv)-1; } if(time!=0) { SetListViewItem(lv,idx,0,time); } else { GetDateTimeStr(s1,50); SetListViewItem(lv,idx,0,s1); } GetFileWriteTime(s,s1,200); SetListViewItem(lv,idx,1,s1);//"2011-05-12 16:23:56"); SetListViewItem(lv,idx,2,s); if(save) Save(); } void UpdateLv() { char s1[200],s2[200]; char fn[200]; int i,idx; idx=-1; int count=GetListViewItemCount(lv); for(i=0; i<count; i++) { GetListViewItem(lv,i,0,s1,200); GetListViewItem(lv,i,2,fn,200); GetFileWriteTime(fn,s2,200); SetListViewItem(lv,i,1,s2); //printf("%s ,%s",s1,s2); if(strcmp(s1,s2)<0) { SetListViewItem(lv,i,-1," Y"); } else SetListViewItem(lv,i,-1," "); } } void OpenFileClick(void *sender) { char s[200]; GetFileName(s,200,"*.*"); if(strlen(s)>0) { SetProperty(edt1,"text",s); SaveIniString("DNW","FileName",s); } SetFocusToCommWin(); } void DownLoadClick(void *sender) { DownLoad(); SetFocusToCommWin(); } void CancelClick(void *sender) { //char s[100]; cancel=1; //GetProperty(edt1,"text",s,100); //AddFileToLv(s,0,1); }" /> 
- <Command cmdname="GPRS的AT命令应用" cmdType="S" cmd="[S]new command">
- <Command cmdname="MC55 GPRS" cmdType="S" cmd="[S]none">
- <Command cmdname="TEXT方式发短信" cmdType="S" cmd="[S][E][E][E][E]none">
  <Command cmdname="取消指令回显" cmdType="S" cmd="[S]ATE0" /> 
  <Command cmdname="打开指令回显" cmdType="S" cmd="[S]ATE1" /> 
  <Command cmdname="设置TEXT方式发送短消息" cmdType="S" cmd="[S]AT+CMGF=1" /> 
  <Command cmdname="设置端消息中心" cmdType="S" cmd="[S]AT+CSCA="+8613800551500"" /> 
  <Command cmdname="发出短消息(ctrl^Z)" cmdType="H" cmd="[H]1a" /> 
  </Command>
  <Command cmdname="读出所有短信" cmdType="S" cmd="[S]AT+CMGL="ALL"" /> 
  <Command cmdname="打电话" cmdType="S" cmd="[S]ATD13905699792" /> 
- <Command cmdname="Socket通讯" cmdType="S" cmd="[S][E][E][E][E]none">
  <Command cmdname="AT测试" cmdType="S" cmd="[S]AT" /> 
  <Command cmdname="获取本机号码" cmdType="S" cmd="[S]AT+CNUM" /> 
  <Command cmdname="查看信号强度" cmdType="S" cmd="[S]at+csq" /> 
  <Command cmdname="设置连接方式" cmdType="S" cmd="[S]at^sics=0,conType,GPRS0" /> 
  <Command cmdname="设置用户名" cmdType="S" cmd="[S]at^sics=0,user,gprs" /> 
  <Command cmdname="设置口令" cmdType="S" cmd="[S]at^sics=0,passwd,gprs" /> 
  <Command cmdname="设置连接方式1" cmdType="S" cmd="[S]at^sics=0,apn,cmnet" /> 
  <Command cmdname="设置Socket" cmdType="S" cmd="[S]at^siss=1,srvType,socket" /> 
  <Command cmdname="设置Socket1" cmdType="S" cmd="[S]at^siss=1,conId,0" /> 
  <Command cmdname="设置目标IP地址、端口" cmdType="S" cmd="[S]at^siss=1,address,"socktcp://220.248.243.211:6666"" /> 
  <Command cmdname="设置目标IP地址、端口google" cmdType="S" cmd="[S]at^siss=1,address,"socktcp://210.45.246.4:80"" /> 
  <Command cmdname="打开socket连接" cmdType="S" cmd="[S]AT^SISO=1" /> 
  <Command cmdname="发出10个字节内容" cmdType="S" cmd="[S]AT^SISW=1,10" /> 
  <Command cmdname="具体内容" cmdType="S" cmd="[S]123456789s" /> 
  <Command cmdname="具体内容1A [^Z]" cmdType="H" cmd="[H]1A" /> 
  <Command cmdname="读出收到的内容" cmdType="S" cmd="[S]AT^SISR=1,10" /> 
  <Command cmdname="关闭socket连接" cmdType="S" cmd="[S]AT^SISC=1" /> 
  </Command>
  </Command>
- <Command cmdname="SIM300 GPRS" cmdType="S" cmd="[S]none">
- <Command cmdname="基本AT指令" cmdType="S" cmd="[S]new command">
  <Command cmdname="AT测试" cmdType="S" cmd="[S]AT" /> 
  <Command cmdname="AT测试" cmdType="P" cmd="[P]SendByte(0x41); Wait(2); SendByte(0x54); Wait(2); SendByte(0x0D); Wait(2);" /> 
  <Command cmdname="取消指令回显" cmdType="S" cmd="[S]ATE0" /> 
  <Command cmdname="打开指令回显" cmdType="S" cmd="[S]ATE1" /> 
  <Command cmdname="查询设备厂商" cmdType="T" cmd="[T]AT+CGMI\rAT+CGMM\r" /> 
  <Command cmdname="查询可用网络" cmdType="S" cmd="[S]at+cops=?" /> 
  </Command>
- <Command cmdname="GPRS Socket" cmdType="S" cmd="[S]new command">
  <Command cmdname="查看信号强度" cmdType="S" cmd="[S]at+csq" /> 
  <Command cmdname="设置连接方式0" cmdType="S" cmd="[S]AT+CIPMODE=0" /> 
  <Command cmdname="设置连接方式1" cmdType="S" cmd="[S]AT+CIPMODE=1" /> 
  <Command cmdname="设置目标IP地址、端口0" cmdType="S" cmd="[S]AT+CIPSTART="TCP","220.248.243.211","6666"" /> 
  <Command cmdname="设置目标IP地址、端口1" cmdType="S" cmd="[S]AT+CIPSTART="TCP","210.145.246.47","80"" /> 
  <Command cmdname="设置目标IP地址、端口2" cmdType="S" cmd="[S]AT+CIPSTART="TCP","210.145.246.4","6666"" /> 
  <Command cmdname="设置目标IP地址、端口1-google" cmdType="S" cmd="[S]AT+CIPSTART="TCP","203.208.137.104","80"" /> 
  <Command cmdname="设置目标IP地址、端口1-ustc telnet" cmdType="S" cmd="[S]AT+CIPSTART="TCP","202.38.164.9","23"" /> 
  <Command cmdname="发送5个字节" cmdType="S" cmd="[S]AT+CIPSEND=5" /> 
  <Command cmdname="发送http请求" cmdType="T" cmd="[T]GET /cgi-bin/qaweb.forte?inputXML=test.xml \r\n\r\n" /> 
  <Command cmdname="5个字节内容" cmdType="S" cmd="[S]12345" /> 
  <Command cmdname="发送数据，以1A结束" cmdType="S" cmd="[S]AT+CIPSEND" /> 
  <Command cmdname="发送数据" cmdType="P" cmd="[P]SendString(GetString('请输入发送内容','abcd'));SendByte(0x1a);" /> 
  <Command cmdname="结束符1a" cmdType="H" cmd="[H]1A" /> 
  <Command cmdname="关闭socket连接" cmdType="S" cmd="[S]AT+CIPSHUT" /> 
  </Command>
- <Command cmdname="GPRS连接到-Google网站" cmdType="S" cmd="[S]new command">
  <Command cmdname="1、查看信号强度" cmdType="S" cmd="[S]at+csq" /> 
  <Command cmdname="2、设置连接方式0" cmdType="S" cmd="[S]AT+CIPMODE=0" /> 
  <Command cmdname="3、显示接收数据的数据头" cmdType="S" cmd="[S]AT+CIPHEAD=1" /> 
  <Command cmdname="4、设置目标IP地址、端口:谷歌" cmdType="S" cmd="[S]AT+CIPSTART="TCP","203.208.37.104","80"" /> 
  <Command cmdname="5、发送数据，以1A结束" cmdType="S" cmd="[S]AT+CIPSEND" /> 
  <Command cmdname="6、发送http请求" cmdType="T" cmd="[T]GET /index.html \r\n\r\n\x1a" /> 
  <Command cmdname="6、发送http请求" cmdType="T" cmd="[T]GET /cgi-bin/qaweb.forte?inputXML=test.xml \r\n\r\n\x1a" /> 
  <Command cmdname="7、关闭socket连接" cmdType="S" cmd="[S]AT+CIPSHUT" /> 
  </Command>
- <Command cmdname="打电话" cmdType="S" cmd="[S]new command">
  <Command cmdname="call" cmdType="S" cmd="[S]ATD13305223456" /> 
  </Command>
- <Command cmdname="短信" cmdType="S" cmd="[S]new command">
  <Command cmdname="设置端消息中心" cmdType="S" cmd="[S]AT+CSCA="+8613800551500"" /> 
  <Command cmdname="设置文本短信方式" cmdType="S" cmd="[S]at+cmgf=1" /> 
  <Command cmdname="发短信" cmdType="S" cmd="[S]AT+CMGS="+8613901233442"" /> 
  <Command cmdname="所发短信内容" cmdType="T" cmd="[T]12345\x1a" /> 
  <Command cmdname="读出短信" cmdType="S" cmd="[S]at+cmgl="all"" /> 
  <Command cmdname="发送数据,以0x1A结尾" cmdType="P" cmd="[P]SendString(GetString('请输入发送内容','Hello!'));SendByte(0x1a);" /> 
  </Command>
  <Command cmdname="测试数据" cmdType="H" cmd="[H]3f 00 06 99 99 31 69" /> 
  <Command cmdname="setIP" cmdType="P" cmd="[P] local s; s=GetParam("ABC","IP"); --PrintToCommWin("config ip is:"..s); if s=="" then s="114.96.16.4"; end; -- s=GetString("设置IP地址:", s); SaveParam("ABC","IP",s); -- s="10.20.30.40"; val=inet_addr(s); data1= bit_shr(val,24); data2= bit_shr(val,16); data3= bit_shr(val,8); data4= bit_shr(val,0); s4=IntToStr(bit_and(data4,255)); len=#s4; for i=1,3-len do s4="0"..s4; end; s3=IntToStr(bit_and(data3,255)); len=#s3; for i=1,3-len do s3="0"..s3; end; s2=IntToStr(bit_and(data2,255)); len=#s2; for i=1,3-len do s2="0"..s2; end; s1=IntToStr(bit_and(data1,255)); len=#s1; for i=1,3-len do s1="0"..s1; end; s="IP"..s4..s3..s2..s1; PrintToCommWin("Input ip is:"..s); SendString(s);" /> 
  <Command cmdname="connect" cmdType="H" cmd="[H]01" /> 
  <Command cmdname="setIP" cmdType="S" cmd="[S]IP114096022016" /> 
  <Command cmdname="senddata" cmdType="H" cmd="[H]02" /> 
  <Command cmdname="close socket" cmdType="H" cmd="[H]04" /> 
  </Command>
- <Command cmdname="EM310" cmdType="P" cmd="[P] void click(int node) { char buf[20],buf1[20]; PrintToCommWin("aaaaaaaaabc"); GetTreeNodeValue(node,buf,20); GetTreeNodeCaption(node,buf1,20); printf("%s:%s",buf1,buf); } void main() { ClearTreeNode(); int a=AddButtonTreeNode(0,"串口命令" ,0); int b=AddButtonTreeNode(0,"网络命令" ,0); AddSpinTreeNode(a,"1. 设串口号" ,click,5,1,10); //name,event,value,min,max AddTextTreeNode(a,"2. IP地址" ,click,"192.168.1.1"); AddPickTreeNode(a,"3. 设波特率" ,click,"9600","1200","2400","4800","9600","19200",0); AddCheckTreeNode(a,"4. 设串口号" ,click,1); //name,event,value,min,max AddButtonTreeNode(a,"5. 发送地址" ,click); AddButtonTreeNode(b,"1. ping" ,click); }">
- <Command cmdname="初始化" cmdType="S" cmd="[S]数据发送区">
  <Command cmdname="AT" cmdType="S" cmd="[S]AT" /> 
  <Command cmdname="测试SIM 卡是否存在" cmdType="S" cmd="[S]AT%TSIM" /> 
  <Command cmdname="SIM 卡在位和PIN1 码状态查询" cmdType="S" cmd="[S]AT+CPIN?" /> 
  <Command cmdname="检查当地的网络信号强度，31最大，0最小" cmdType="S" cmd="[S]AT+CSQ" /> 
  <Command cmdname="启用网络注册非请求结果码" cmdType="S" cmd="[S]AT+CREG=1" /> 
  <Command cmdname="网络运营商注册查询" cmdType="S" cmd="[S]AT+COPS?" /> 
  <Command cmdname="启用GPRS网络注册非请求结果码" cmdType="S" cmd="[S]AT+CGATT=1" /> 
  <Command cmdname="设备厂商" cmdType="S" cmd="[S]AT+GMI" /> 
  <Command cmdname="版本号查询" cmdType="S" cmd="[S]AT+CGMR" /> 
  <Command cmdname="GSN" cmdType="S" cmd="[S]AT+GSN" /> 
  <Command cmdname="查询模块当前的IMSI号" cmdType="S" cmd="[S]AT+CIMI" /> 
  </Command>
- <Command cmdname="TCP/IP" cmdType="S" cmd="[S]new command">
  <Command cmdname="初始化_不缓冲" cmdType="S" cmd="[S]AT%IOMODE=1,1,1" /> 
  <Command cmdname="注册移动的CMNET网关" cmdType="S" cmd="[S]AT+CGDCONT=1,"IP","CMNET"" /> 
  <Command cmdname="注册用户名密码，并等分配IP" cmdType="S" cmd="[S]AT%ETCPIP="user","gprs"" /> 
  <Command cmdname="查询GPRS 初始化是否成功" cmdType="S" cmd="[S]AT%ETCPIP?" /> 
  <Command cmdname="设置TCP、ip、port" cmdType="S" cmd="[S]AT%IPOPEN="TCP","61.144.176.175",3000" /> 
  <Command cmdname="设置TCP、ip、port[1]" cmdType="S" cmd="[S]AT%IPOPEN="TCP","220.248.243.211",6666" /> 
  <Command cmdname="发送数据12345AB" cmdType="S" cmd="[S]AT%IPSEND="31323334354142"" /> 
  <Command cmdname="读取数据" cmdType="S" cmd="[S]AT%IPDR" /> 
  <Command cmdname="关闭" cmdType="S" cmd="[S]AT%IPCLOSE=1" /> 
  <Command cmdname="模块从GPRS 网络注销" cmdType="S" cmd="[S]AT%IPCLOSE=5" /> 
  </Command>
  </Command>
  </Command>
- <Command cmdname="ARM开发板命令" cmdType="S" cmd="[S]new command">
- <Command cmdname="Mini2440" cmdType="S" cmd="[S]ERROR">
- <Command cmdname="Set parameter" cmdType="S" cmd="[S]new command">
  <Command cmdname="mach_type" cmdType="S" cmd="[S]mach_type" /> 
  <Command cmdname="media_type" cmdType="S" cmd="[S]media_type" /> 
  <Command cmdname="boot_mem_base" cmdType="S" cmd="[S]boot_mem_base" /> 
  <Command cmdname="baudrate" cmdType="S" cmd="[S]baudrate" /> 
  <Command cmdname="xmodem" cmdType="S" cmd="[S]xmodem" /> 
  <Command cmdname="xmodem_one_nak" cmdType="S" cmd="[S]xmodem_one_nak" /> 
  <Command cmdname="xmodem_initial_timeout" cmdType="S" cmd="[S]xmodem_initial_timeout" /> 
  <Command cmdname="xmodem_timeout" cmdType="S" cmd="[S]xmodem_timeout" /> 
  <Command cmdname="boot_delay" cmdType="S" cmd="[S]boot_delay" /> 
  <Command cmdname="Linux command line" cmdType="S" cmd="[S]Linux command line" /> 
  </Command>
- <Command cmdname="parameter value" cmdType="S" cmd="[S]new command">
  <Command cmdname="MACH_TYPE [782]" cmdType="S" cmd="[S]782" /> 
  <Command cmdname="Linux command line" cmdType="S" cmd="[S]"noinitrd root=/dev/mtdblock2 init=/linuxrc console=ttySAC1,115200"" /> 
  </Command>
- <Command cmdname="通过串口终端操作开发板" cmdType="S" cmd="[S]new command">
  <Command cmdname="2.5.1 播放mp3" cmdType="S" cmd="[S]madplay your.mp3" /> 
  <Command cmdname="2.5.2 如何中止程序的运行" cmdType="H" cmd="[H]03" /> 
  <Command cmdname="2.5.5 如何通过串口与PC 互相传送文件" cmdType="P" cmd="[P]void main() { //char ss[]="请使用本工具右侧工具栏的【ZModem接收】与【ZModem发送】来测试本命令"; //ShowMessage(ss); ShowMessage("请使用本工具右侧工具栏的【ZModem接收】与【ZModem发送】来测试本命令"); }" /> 
- <Command cmdname="2.5.6 控制板上的LED" cmdType="S" cmd="[S]new command">
  <Command cmdname="4 个用户led 将会以每个间隔0.2 秒的时间运行跑马灯" cmdType="S" cmd="[S]echo 0 0.2 > /tmp/led-control" /> 
  <Command cmdname="4 个用户led 将会以间隔0.2 秒的时间运行累加器" cmdType="S" cmd="[S]echo 1 0.2 >/tmp/led-control" /> 
  <Command cmdname="4 个用户led 将会停止闪动" cmdType="S" cmd="[S]etc/rc.d/init.d/leds stop" /> 
  <Command cmdname="4 个用户led 将会重新开始闪动" cmdType="S" cmd="[S]etc/rc.d/init.d/leds start" /> 
  </Command>
  <Command cmdname="2.5.7 测试板上的按键" cmdType="S" cmd="[S]buttons" /> 
  <Command cmdname="2.5.8 串口2 和3 的测试" cmdType="S" cmd="[S]armcomtest Cd /dev/ttySAC0 -o" /> 
  <Command cmdname="2.5.9 测试蜂鸣器" cmdType="S" cmd="[S]pwm_test" /> 
- <Command cmdname="2.5.10 控制LCD 的背光" cmdType="S" cmd="[S]new command">
  <Command cmdname="关闭LCD 背光" cmdType="S" cmd="[S]echo 0 > /dev/backlight" /> 
  <Command cmdname="打开LCD 背光" cmdType="S" cmd="[S]echo 1 > /dev/backlight" /> 
  </Command>
  <Command cmdname="2.5.11 测试I2C－EEPROM" cmdType="S" cmd="[S]i2c Cw" /> 
  <Command cmdname="2.5.13 如何设置网络以访问互联网网址" cmdType="S" cmd="[S]route add default gw 192.168.1.1" /> 
  <Command cmdname="2.5.14 如何设置MAC 地址" cmdType="S" cmd="[S]ifconfig ifconfig eth0 down ifconfig eth0 hw ether 00:11:AA:BB:CC:DD ifconfig eth0 up ifconfig ping 192.168.1.1" /> 
  <Command cmdname="2.5.15 如何使用Telnet 远程登录开发板" cmdType="P" cmd="[P]main() { char s[200]="请先使用本工具的【控制菜单】->【新建窗口】命令来新建一个窗口，\r\n"; char *s1="然后使用本工具的【控制菜单】->【通讯类型】->【Telnet客户端】 命令进行Telnet测试！"; strcat(s,s1); ShowMessage(s); }" /> 
- <Command cmdname="2.5.17 通过网页控制板上的LED" cmdType="S" cmd="[S]new command">
  <Command cmdname="要停止 web 服务器" cmdType="S" cmd="[S]etc/rc.d/init.d/httpd stop" /> 
  <Command cmdname="重新启动" cmdType="S" cmd="[S]etc/rc.d/init.d/httpd start" /> 
  </Command>
- <Command cmdname="2.5.18 如何挂接使用网络文件系统NFS" cmdType="S" cmd="[S]new command">
  <Command cmdname="挂接" cmdType="S" cmd="[S]mount Ct nfs Co nolock 192.168.1.111:/opt/FriendlyARM/mini2440/root_nfs /mnt" /> 
  <Command cmdname="取消挂接" cmdType="S" cmd="[S]umount /mnt" /> 
  </Command>
- <Command cmdname="2.5.19 设置并保存系统实时时钟" cmdType="S" cmd="[S]new command">
  <Command cmdname="设置时间为 2007-04-29 16:34" cmdType="S" cmd="[S]date -s 042916352007" /> 
  <Command cmdname="把刚刚设置的时间存入S3C2440 内部的RTC" cmdType="S" cmd="[S]hwclock -w" /> 
  <Command cmdname="恢复 linux 系统时钟为RTC" cmdType="S" cmd="[S]hwclock -s" /> 
  </Command>
  </Command>
  <Command cmdname="5.5.3 通过NFS 启动系统" cmdType="S" cmd="[S]param set linux_cmd_line "console=ttySAC0 root=/dev/nfs nfsroot=192.168.1.111:/opt/FriendlyARM/mini2440/root_qtopia ip=192.168.1.70:192.168.1.111:192.168.1.111:255.255.255.0:sbc2440.arm9.net:eth0:off"" /> 
  </Command>
- <Command cmdname="VIVI-TE2410" cmdType="S" cmd="[S]none">
- <Command cmdname="分区操作" cmdType="S" cmd="[S]none">
  <Command cmdname="显示分区" cmdType="S" cmd="[S]part show" /> 
  <Command cmdname="添加jffs2分区" cmdType="S" cmd="[S]part add mypart 0x500000 0x100000 JFFS2" /> 
  <Command cmdname="添加分区" cmdType="P" cmd="[P]name=GetString("分区名称","usr"); offset=GetString("起始地址","0x00600000"); size=GetString("分区大小","0x03a00000"); flag=GetString("分区类型","0"); cmd="part add "..name.." "..offset.." "..size.." "..flag; SendString(cmd);" /> 
  <Command cmdname="删除分区" cmdType="P" cmd="[P]name=GetString('分区名称','usr'); cmd='part del '..name; SendString(cmd);" /> 
  <Command cmdname="擦除分区" cmdType="P" cmd="[P]name=GetString('分区名称','usr'); cmd='part erase '..name; SendString(cmd);" /> 
  <Command cmdname="恢复分区表" cmdType="P" cmd="[P]SendString('part reset');" /> 
  <Command cmdname="保存分区" cmdType="P" cmd="[P]SendString('part save');" /> 
  </Command>
- <Command cmdname="文件操作" cmdType="S" cmd="[S]none">
  <Command cmdname="load flash" cmdType="S" cmd="[S]load flash kernel t" /> 
  <Command cmdname="load flash" cmdType="S" cmd="[S]load ram 0X30008000 t" /> 
  <Command cmdname="boot" cmdType="S" cmd="[S]boot ram" /> 
  </Command>
- <Command cmdname="参数操作" cmdType="S" cmd="[S]none">
  <Command cmdname="help" cmdType="S" cmd="[S]param help" /> 
  <Command cmdname="show" cmdType="S" cmd="[S]param show" /> 
  <Command cmdname="reset" cmdType="S" cmd="[S]param reset" /> 
  <Command cmdname="save" cmdType="S" cmd="[S]param save" /> 
  <Command cmdname="设置参数" cmdType="P" cmd="[P]name=GetString('参数名称','ip'); val=GetString('值','192.168.0.253'); cmd='param set '..name..' '..val; SendString(cmd);" /> 
  <Command cmdname="set ip" cmdType="S" cmd="[S]param set ip 192.168.0.253" /> 
  <Command cmdname="set mac" cmdType="S" cmd="[S]param set mac 00:01:02:03:04:05" /> 
  <Command cmdname="linux_cmd_line" cmdType="S" cmd="[S]param set linux_cmd_line noinitrd root=/dev/mtdblock/3 init=/linuxrc console=ttyS0" /> 
  <Command cmdname="wince_part_name" cmdType="S" cmd="[S]param set wince_part_name wince" /> 
  </Command>
  </Command>
- <Command cmdname="DevKit8000 OMAP3530" cmdType="S" cmd="[S]none">
- <Command cmdname="4.3"LCD" cmdType="S" cmd="[S]none">
- <Command cmdname="NandFlash" cmdType="S" cmd="[S]none">
  <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 ubi.mtd=4 root=ubi0:rootfs rootfstype=ubifs video=omapfb:mode:4.3inch_LCD" /> 
  <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd nand read.i 80300000 280000 200000\;bootm 80300000" /> 
  <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv" /> 
  </Command>
- <Command cmdname="SD Card" cmdType="S" cmd="[S]none">
  <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 root=/dev/ram initrd=0x81600000,40M video=omapfb:mode:4.3inch_LCD" /> 
  <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd 'mmcinit;fatload mmc 0 80300000 uImage;fatload mmc 0 81600000 ramdisk.gz;bootm 80300000'" /> 
  <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv" /> 
  </Command>
  </Command>
- <Command cmdname="7"LCD" cmdType="S" cmd="[S]none">
- <Command cmdname="NandFlash" cmdType="S" cmd="[S]none">
  <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 ubi.mtd=4 root=ubi0:rootfs rootfstype=ubifs video=omapfb:mode:7inch_LCD" /> 
  <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd nand read.i 80300000 280000 200000\;bootm 80300000" /> 
  <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv" /> 
  </Command>
- <Command cmdname="SD Card" cmdType="S" cmd="[S]none">
  <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 root=/dev/ram initrd=0x81600000,40M video=omapfb:mode:7inch_LCD" /> 
  <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd 'mmcinit;fatload mmc 0 80300000 uImage;fatload mmc 0 81600000 ramdisk.gz;bootm 80300000'" /> 
  <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv" /> 
  </Command>
  </Command>
- <Command cmdname="DVI" cmdType="S" cmd="[S]none">
- <Command cmdname="NandFlash" cmdType="S" cmd="[S]none">
  <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 ubi.mtd=4 root=ubi0:rootfs rootfstype=ubifs video=omapfb:mode:720p60" /> 
  <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd nand read.i 80300000 280000 200000\;bootm 80300000" /> 
  <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv" /> 
  </Command>
- <Command cmdname="SD Card" cmdType="S" cmd="[S]none">
  <Command cmdname="bootargs" cmdType="S" cmd="[S]setenv bootargs console=ttyS2,115200n8 root=/dev/ram initrd=0x81600000,40M video=omapfb:mode:720p60" /> 
  <Command cmdname="bootcmd" cmdType="S" cmd="[S]setenv bootcmd 'mmcinit;fatload mmc 0 80300000 uImage;fatload mmc 0 81600000 ramdisk.gz;bootm 80300000'" /> 
  <Command cmdname="saveenv" cmdType="S" cmd="[S]saveenv" /> 
  </Command>
  </Command>
- <Command cmdname="测试程序" cmdType="S" cmd="[S]none">
  <Command cmdname="点亮led3" cmdType="S" cmd="[S]echo -n 1 >/sys/class/leds/led3/brightness" /> 
  <Command cmdname="熄灭led3" cmdType="S" cmd="[S]echo -n 0 >/sys/class/leds/led3/brightness" /> 
  <Command cmdname="KEYPAD 测试" cmdType="S" cmd="[S]evtest /dev/input/event0" /> 
  <Command cmdname="触摸屏校正" cmdType="S" cmd="[S]ts_calibrate" /> 
  <Command cmdname="触摸屏测试" cmdType="S" cmd="[S]ts_test" /> 
  <Command cmdname="RTC 测试" cmdType="S" cmd="[S] date 080820002008" /> 
  <Command cmdname="系统时钟写入RTC" cmdType="S" cmd="[S] hwclock Cw" /> 
  <Command cmdname="读取RTC" cmdType="S" cmd="[S] hwclock" /> 
  </Command>
- <Command cmdname="Angstrom(GPE)桌面发布版本演示" cmdType="S" cmd="[S]none">
- <Command cmdname="make sd card" cmdType="S" cmd="[S]none">
  <Command cmdname="cp" cmdType="S" cmd="[S]cp /media/cdrom/linux/demo/angstrom/MLO /media/LABEL1" /> 
  <Command cmdname="cp" cmdType="S" cmd="[S]cp /media/cdrom/linux/demo/angstrom/u-boot.bin /media/LABEL1" /> 
  <Command cmdname="cp" cmdType="S" cmd="[S]cp /media/cdrom/linux/demo/angstrom/uImage /media/LABEL1" /> 
  <Command cmdname="rm" cmdType="S" cmd="[S]rm Crf /media/LABEL2/*" /> 
  <Command cmdname="tar" cmdType="S" cmd="[S]sudo tar jxvf linux/demo/angstrom/Angstrom-DevKit8000-demo-image-glibc-ipk-2008.1-test-2 0080111-DevKit8000.rootfs.tar.bz2 CC /media/LABEL2" /> 
  <Command cmdname="sync" cmdType="S" cmd="[S]sync" /> 
  <Command cmdname="umount" cmdType="S" cmd="[S]umount /media/LABEL1" /> 
  <Command cmdname="umount" cmdType="S" cmd="[S]umount /media/LABEL2" /> 
  </Command>
- <Command cmdname="4.3"lcd" cmdType="S" cmd="[S]none">
  <Command cmdname="set bootargs" cmdType="S" cmd="[S]set bootargs mem=128M console=ttyS2,115200n8 root=/dev/mmcblk0p2 rw noinitrd rootdelay=1" /> 
  <Command cmdname="mmcinit" cmdType="S" cmd="[S] mmcinit" /> 
  <Command cmdname="fatload" cmdType="S" cmd="[S] fatload mmc 0 80300000 uimage" /> 
  <Command cmdname="bootm" cmdType="S" cmd="[S] bootm 80300000" /> 
  </Command>
- <Command cmdname="7"lcd" cmdType="S" cmd="[S]none">
  <Command cmdname="set bootargs" cmdType="S" cmd="[S] set bootargs mem=128M console=ttyS2,115200n8 root=/dev/mmcblk0p2 rw noinitrd rootdelay=1 video=omapfb:mode:7inch_LCD" /> 
  <Command cmdname="mmcinit" cmdType="S" cmd="[S] mmcinit" /> 
  <Command cmdname="fatload" cmdType="S" cmd="[S] fatload mmc 0 80300000 uimage" /> 
  <Command cmdname="bootm" cmdType="S" cmd="[S] bootm 80300000" /> 
  </Command>
- <Command cmdname="DVI" cmdType="S" cmd="[S]none">
  <Command cmdname="set bootargs" cmdType="S" cmd="[S]set bootargs mem=128M console=ttyS2,115200n8 root=/dev/mmcblk0p2 rw noinitrd rootdelay=1 video=omapfb:mode:720p60" /> 
  <Command cmdname="mmcinit" cmdType="S" cmd="[S] mmcinit" /> 
  <Command cmdname="fatload" cmdType="S" cmd="[S] fatload mmc 0 80300000 uimage" /> 
  <Command cmdname="bootm" cmdType="S" cmd="[S] bootm 80300000" /> 
  </Command>
  </Command>
  </Command>
- <Command cmdname="UBOOT" cmdType="S" cmd="[S]none">
  <Command cmdname="打印环境变量" cmdType="S" cmd="[S]printenv" /> 
  <Command cmdname="设置新的变量" cmdType="S" cmd="[S]setenv myboard AT91RM9200DK" /> 
  <Command cmdname="设置MAC地址" cmdType="S" cmd="[S]setenv ethaddr 12:34:56:78:9A:BC" /> 
  <Command cmdname="设置IP地址" cmdType="S" cmd="[S]setenv serverip 192.168.1.254" /> 
  <Command cmdname="设置服务器IP地址" cmdType="S" cmd="[S]setenv ipaddr 192.168.1.1" /> 
  <Command cmdname="设置服务器IP地址" cmdType="S" cmd="[S]tftp 20000000 application.bin" /> 
  </Command>
  </Command>
- <Command cmdname="UsbGadget_udisk" cmdType="S" cmd="[S]new command">
  <Command cmdname="insmod s3c2410_udc.ko" cmdType="S" cmd="[S]insmod s3c2410_udc.ko" /> 
  <Command cmdname="insmod g_file_storage.ko" cmdType="S" cmd="[S]insmod g_file_storage.ko file=/dev/mmcblk0p1 stall=0 removable=1" /> 
  <Command cmdname="insmod g_file_storage.ko1" cmdType="S" cmd="[S]insmod g_file_storage.ko file=/dev/sdcard stall=0 removable=1" /> 
  <Command cmdname="mount sd" cmdType="S" cmd="[S]cd / umount sd mount /dev/mmcblk0p1 /sd cd /sd" /> 
  <Command cmdname="umount sd" cmdType="S" cmd="[S]cd / umount /sd" /> 
  <Command cmdname="./testapp" cmdType="S" cmd="[S]./testapp" /> 
  <Command cmdname="re mount & run" cmdType="S" cmd="[S]cd / umount /sd mount /dev/mmcblk0p1 /sd cd /sd ./testapp" /> 
  <Command cmdname="test data" cmdType="H" cmd="[H]F1 F2 06 F9 00 00 30 00 AA BB 95" /> 
  <Command cmdname="remount & Run1" cmdType="S" cmd="[S]umount /sdcard mount /dev/sdcard /sdcard /sdcard/testapp" /> 
  <Command cmdname="==========" cmdType="S" cmd="[S]数据发送区" /> 
  <Command cmdname="umount" cmdType="S" cmd="[S]umount /sdcard" /> 
  <Command cmdname="mount" cmdType="S" cmd="[S] mount /dev/sdcard /sdcard" /> 
  <Command cmdname="run" cmdType="S" cmd="[S]/sdcard/testapp" /> 
  <Command cmdname="Auto" cmdType="P" cmd="[P]void main() { SendByte(0x03); // --Ctrl+C Wait(20); SendString("umount /sdcard\r\n"); Wait(1000); SendString("mount /dev/sdcard /sdcard\r\n"); Wait(1000); SendString("/sdcard/testapp\r\n"); }" /> 
  <Command cmdname="^C" cmdType="H" cmd="[H]03" /> 
  </Command>
  </Command>
- <Command cmdname="例子命令" cmdType="S" cmd="[S]none">
- <Command cmdname="基本命令" cmdType="S" cmd="[S]new command">
  <Command cmdname="字符串命令" cmdType="S" cmd="[S]12345 -"abcd" 56789\ llll" /> 
  <Command cmdname="十六进制命令" cmdType="H" cmd="[H]0001020304aabbccdd" /> 
  <Command cmdname="转义命令" cmdType="T" cmd="[T]abc\x34\123\r\xyzabcdef" /> 
  <Command cmdname="脚本命令0" cmdType="P" cmd="[P]main() { PrintfToCommWin("12345:%08d,%02x",666,0x83); }" /> 
  <Command cmdname="脚本命令2" cmdType="P" cmd="[P]void main() { int i; PrintToCommWin("下面发送100个字节:"); for(i=1; i<=100; i++) SendByte(i); }" /> 
  </Command>
- <Command cmdname="控件示例" cmdType="S" cmd="[S]new command">
  <Command cmdname="扩展树节点" cmdType="P" cmd="[P]int c; void NodeClick(int node) { char buf[20],buf1[20],buf2[40]; GetTreeNodeValue(node,buf,20); GetTreeNodeCaption(node,buf1,20); sprintf(buf2,"%s:%s",buf1,buf); printf("%s",buf2); PrintToCommWin(buf2); } void NodeClick1(int node) { char buf[20],buf1[20],buf2[40]; GetTreeNodeValue(node,buf,20); sprintf(buf2,"设置的串口波特率为:%s",buf); printf("%s",buf2); PrintToCommWin(buf2); ShowMessage(buf2); } void TreeNodeDbClick(int node) { if(node==c) NodeClick1(node); else NodeClick(node); } void main() { ClearTreeNode(); int a=AddButtonTreeNode(0,"串口命令" ,0); int b=AddButtonTreeNode(0,"网络命令" ,0); AddSpinTreeNode(a,"1. 设串口号" ,5,1,10); //name,event,value,min,max c=AddTextTreeNode(a,"2. IP地址" ,"192.168.1.1"); SetTreeNodeBkColor(c,0xffff00); //SetTreeNodeCaption(c,"1. ip address"); SetTreeNodeValue(c,"3"); c=AddPickTreeNode(a,"3. 设波特率" ,"9600","1200","2400","4800","9600","19200",0); SetTreeNodeValue(c,"1200"); SetTreeNodeBkColor(c,0x0000ff); int d=AddCheckTreeNode(a,"4. 设串口号" ,1); SetTreeNodeValue(d,"False"); c=AddButtonTreeNode(a,"5. 发送地址(双击发送)" ); SetTreeNodeBkColor(d,0x00ff00); AddButtonTreeNode(b,"1. ping" ); AddButtonTreeNode(b,"2. ping2" ); AddButtonTreeNode(b,"3. ping3" ); ShowLeftToolPage(1); ExplandAllTreeNode(); }" /> 
  <Command cmdname="控件示例" cmdType="P" cmd="[P]#include "windows.h" void click(int btn) { char s[20]; printf("clicked"); //SetProperty(btn,"enabled","false"); GetProperty(btn,"caption",s,20); printf("button caption is '%s'",s); }; void click1(int btn) { char s[20]; printf("clicked"); //SetProperty(btn,"enabled","false"); GetProperty(btn,"text",s,20); printf("edit text is '%s'",s); }; void main() { int i; int btn; int node; char s[100]; ClearVclControls(); ShowVclWin(150); ShowOutputWin(300); int p=GetGuiWin(); for( i=0; i<3; i++) { sprintf(s,"按钮:%d",i); btn=CreateComponentEx(p,"button","caption",s,0); SetProperty(btn,"left",10+i*70); SetPropertyList(btn,"top",30,"width",65,"onclick",click,NULL);//创建按钮 } for( i=0; i<3; i++) { sprintf(s,"Text:%d",i); btn=CreateComponentEx(p,"edit","text",s,0); SetProperty(btn,"left",10+i*70); SetPropertyList(btn,"top",60,"width",65,"onclick",click1,NULL);//创建按钮 } for( i=0; i<3; i++) { sprintf(s,"check:%d",i); btn=CreateComponentEx(p,"checkbox","caption",s,0); SetProperty(btn,"left",10+i*70); SetPropertyList(btn,"top",90,"width",65,"onclick",click,NULL);//创建按钮 } };" /> 
  <Command cmdname="KS8995MA" cmdType="P" cmd="[P]#include"windows.h" int rootNode; unsigned char Data[200]; unsigned char skip=1; void ReadDataFromFile(unsigned char *filename) { char s[100]; HANDLE Handle=CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL); printf("读取文件名称：%s",filename); if(Handle<=0) { sprintf(s,"打开文件【%s】错误！",s); ShowMessage(s);//"打开文件【"..pb.edit1.text.."】错误！"); return ; } int BytesRead ; ReadFile(Handle, Data,128,&BytesRead,NULL); CloseHandle(Handle); } void WriteDataToFile(unsigned char *filename) { char s[100]; HANDLE Handle=CreateFile(filename, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL); printf("保存文件名称：%s",filename); if(Handle<=0) { sprintf(s,"打开文件【%s】错误！",s); ShowMessage(s);//"打开文件【"..pb.edit1.text.."】错误！"); return ; } int BytesWrite ; WriteFile(Handle, Data,128,&BytesWrite,NULL); CloseHandle(Handle); } int GetRegisterIdx(int node) { char buf[50],buf1[20]; int i,j,k,idx; GetTreeNodeCaption(node,buf,50); j=0; if(buf[0]!='(') return -1; for(i=1; i<50; i++) if( ((buf[i]>='0')&&(buf[i]<='9')) || ((buf[i]=='x')||(buf[i]=='X')) || ((buf[i]>='a')&&(buf[i]=='f')) || ((buf[i]>='A')&&(buf[i]=='F')) ) { buf1[j++]=buf[i]; } else if(buf[i]==')') { if(j==0) return -1; buf1[j++]=0; idx=HexStrToInt(buf1); return idx; } else return -1; } int GetRegistBits(int node,int *start,int *len) { char buf[50],buf1[20]; int i,j,k,idx; *start=-1; j=0; GetTreeNodeCaption(node,buf,50); for(i=0; i<50; i++) if((buf[i]>='0')&&(buf[i]<='9')) { buf1[j++]=buf[i]; } else if(buf[i]=='-') { if(j==0) return -1; if(*start!=-1) return -1; idx=0; for(k=0; k<j; k++) idx=idx*10+buf1[k]-'0'; *start=idx; j=0; } else if(buf[i]==' ') { if(j==0) return -1; idx=0; for(k=0; k<j; k++) idx=idx*10+buf1[k]-'0'; if(*start==-1) { *start=idx; *len=1; return len; } else { if(idx>*start) return -1; k=*start; *start=idx; idx=k;//swap *len=idx-*start+1; return len; } } else return -1; } unsigned int BinStrToInt(char *str) { int i,j,k; unsigned int val=0; for(i=0; i<10; i++) if(str[i]=='0') val=val<<1; else if(str[i]=='1') val=(val<<1)|1; else return val; return val; } void NodeProc(int node,int ReadOrWrite,int loop) { char buf[50],buf1[50]; int idx,i; int start,len; unsigned char bits,val; unsigned char mask; int nd=node; int value=0x85; int set=ReadOrWrite; if(node==0) return; do { idx=GetRegisterIdx(nd); // printf("idx:%d",idx); if(idx>=0) { if(set) { sprintf(buf,"%02X",Data[idx]);//; SetTreeNodeValue(nd,buf);// set value } int child=GetFirstChild(nd); int start,len; while(child!=0) { if(GetRegistBits(child,&start,&len)>=0) { //sprintf(buf,"(%d-%d) ",start,start+len-1);PrintToCommWin(buf); GetTreeNodeValue(child,buf,20); bits=BinStrToInt(buf); //sprintf(buf1,"%d ", bits);PrintToCommWin(buf1); mask=0xff>>start; mask=mask<<start; mask=mask<<(7-(start+len-1)); mask=mask>>(7-(start+len-1)); if(set) { bits=Data[idx]&mask; bits>>=start; for(i=0; i<len; i++) if(bits&(1<<i))buf[len-i-1]='1'; else buf[len-i-1]='0'; buf[len]=0; SetTreeNodeValue(child,buf); } else { bits<<=start; GetTreeNodeValue(nd,buf,20); val=HexStrToInt(buf); val=val&(~mask); val=val|(bits&mask); sprintf(buf,"%02X",val);//PrintToCommWin(buf); SetTreeNodeValue(nd,buf); } } child=GetNextSibing(child); } if(!set) { GetTreeNodeValue(nd,buf,20); val=HexStrToInt(buf); Data[idx]=val; SetHexEditorDat(idx,val); SetHexEditorSelection(idx,1); } } nd=GetNextSibing(nd); } while((nd!=0)&&(loop)); } void NodeProcAll(int rdwr) { int child; char buf[20],buf1[200]; int nd=rootNode; while(nd!=0) { NodeProc(GetFirstChild(nd),rdwr,1); nd=GetNextSibing(nd); } nd=rootNode; while(nd!=0) { buf1[0]=0; child=GetFirstChild(nd); while(child!=0) { GetTreeNodeValue(child,buf,20); if(buf1[0]!=0) sprintf(buf1,"%s,%s",buf1,buf); else sprintf(buf1,"%s",buf); child=GetNextSibing(child); } SetTreeNodeValue(nd,buf1); nd=GetNextSibing(nd); } } void NodeClick(int node) { node=GetNodeParent(node); if(node==0)return; int idx=GetRegisterIdx(node); // printf("idx:%d",idx); if(idx<0) return; NodeProc(node,0,0); node=GetNodeParent(node); if(node==0)return; int nd=node; char buf[20],buf1[200]; buf1[0]=0; int child=GetFirstChild(nd); while(child!=0) { GetTreeNodeValue(child,buf,20); if(buf1[0]!=0) sprintf(buf1,"%s,%s",buf1,buf); else sprintf(buf1,"%s",buf); child=GetNextSibing(child); } SetTreeNodeValue(nd,buf1); } void TreeNodeDbClick(int node) { NodeClick(node); } void TreeNodeEdited(int node) { char buf[20]; int val; if(node==0)return; int idx=GetRegisterIdx(node); // printf("idx:%d",idx); if(idx<0) NodeClick(node); else { GetTreeNodeValue(node,buf,20); int val=HexStrToInt(buf); Data[idx]=val; NodeProc(node,1,0); SetHexEditorDat(idx,val); SetHexEditorSelection(idx,1); } } void HexEditorChanged(int editor) { int i; if(skip) return; for(i=0; i<200; i++) Data[i]=GetHexEditorDat(i); NodeProcAll(1); } void BtnClick0() { skip=1; ReadDataFromFile("c:\\zz.bin"); HexEditorLoadFromFile("c:\\zz.bin"); NodeProcAll(1); skip=0; } void BtnClick1() { int i; //NodeProcAll(0); for(i=0; i<20; i++) printf("%d",Data[i]); WriteDataToFile("c:\\zz.bin"); } void main() { char buf[50],buf1[50]; ClearVclControls(); ShowVclWin(80); CloseInputWin(); ShowOutputWin(300); int p=GetGuiWin(); int btn=CreateComponentEx(p,"button","caption","读取文件",0); SetPropertyList(btn,"left",10+0*90,"top",30,"width",85,"onclick",BtnClick0,NULL);//创建按钮 btn=CreateComponentEx(p,"button","caption","输出文件",0); SetPropertyList(btn,"left",10+1*90,"top",30,"width",85,"onclick",BtnClick1,NULL);//创建按钮 ClearTreeNode(); int i,node0,node1; for(i=0; i<200; i++)Data[i]=rand(255); int a=AddTextTreeNode(0,"0-1 字节：Chip ID Registers" ,""); int b=AddTextTreeNode(0,"2-11 字节：Global Control Registers" ,""); int c=AddTextTreeNode(0,"12-15 字节：保留" ,""); int d=AddTextTreeNode(0,"16-29 Port 1 Control Registers" ,""); int e=AddTextTreeNode(0,"30-31 Port 1 Status Registers" ,""); int f=AddTextTreeNode(0,"32-45 Port 2 Control Registers" ,""); int g=AddTextTreeNode(0,"46-47 Port 2 Status Registers" ,""); int h=AddTextTreeNode(0,"48-61 Port 3 Control Registers" ,""); int i=AddTextTreeNode(0,"62-63 Port 3 Status Registers" ,""); int j=AddTextTreeNode(0,"64-77 Port 4 Control Registers" ,""); int k=AddTextTreeNode(0,"78-79 Port 4 Status Registers" ,""); int l=AddTextTreeNode(0,"80-93 Port 5 Control Registers" ,""); int m=AddTextTreeNode(0,"94-95 Port 5 Status Registers" ,""); c=AddTextTreeNode(a,"(0x00): 第0字节" ,"0"); //name,event,value,min,max node0=AddTextTreeNode(a,"(01): 第1字节 / Start Switch" ,"0"); node1=AddTextTreeNode(node0,"7-4 Chip ID" ,"000"); node1=AddTextTreeNode(node0,"3-1 Revision ID" ,"000"); node1=AddTextTreeNode(node0,"0 Start Switch" ,"0"); node0=AddTextTreeNode(b,"(0x02): Global Control 0" ,"0"); node1=AddTextTreeNode(node0,"7-3 hour" ,"00000"); node1=AddTextTreeNode(node0,"2-0 min hi3bit" ,"000"); node0=AddTextTreeNode(b,"(0x03): Global Control 1" ,"0"); node1=AddTextTreeNode(node0,"7-5 min low3 bit" ,"0"); node1=AddTextTreeNode(node0,"4-0 sec hi 5bit " ,"0"); node0=AddTextTreeNode(b,"(0x04): Global Control 2" ,"0"); node1=AddTextTreeNode(node0,"7 sec low 1 bit " ,"0"); node1=AddTextTreeNode(node0,"6 Multicast Storm" ,"0"); node1=AddTextTreeNode(node0,"5 Back Pressure Mode" ,"0"); node1=AddTextTreeNode(node0,"4 Flow Control and Back" ,"0"); node1=AddTextTreeNode(node0,"3 No Excessive Collision Drop" ,"0"); node1=AddTextTreeNode(node0,"2 Huge Packet Support" ,"0"); node1=AddTextTreeNode(node0,"1 Legal Maximum Packet" ,"0"); node1=AddTextTreeNode(node0,"0 Priority Buffer Reserve" ,"0"); node0=AddTextTreeNode(d,"(0x10): Port 1 Control 0" ,"0"); node1=AddTextTreeNode(node0,"7 Broadcast Storm" ,"0"); node1=AddTextTreeNode(node0,"6 DiffServ Priority" ,"0"); node1=AddTextTreeNode(node0,"5 802.1p Priority" ,"0"); node1=AddTextTreeNode(node0,"4 Port-Based Priority" ,"0"); node1=AddTextTreeNode(node0,"3 Reserved" ,"0"); node1=AddTextTreeNode(node0,"2 Tag Insertion" ,"0"); node1=AddTextTreeNode(node0,"1 Tag Removal" ,"0"); node1=AddTextTreeNode(node0,"0 Priority Enable" ,"0"); node0=AddTextTreeNode(d,"(0x20): Port 2 Control 0" ,"0"); node1=AddTextTreeNode(node0,"7 Broadcast Storm" ,"0"); node1=AddTextTreeNode(node0,"6 DiffServ Priority" ,"0"); node1=AddTextTreeNode(node0,"5 802.1p Priority" ,"0"); node1=AddTextTreeNode(node0,"4 Port-Based Priority" ,"0"); node1=AddTextTreeNode(node0,"3 Reserved" ,"0"); node1=AddTextTreeNode(node0,"2 Tag Insertion" ,"0"); node1=AddTextTreeNode(node0,"1 Tag Removal" ,"0"); node1=AddTextTreeNode(node0,"0 Priority Enable" ,"0"); node0=AddTextTreeNode(f,"(0x20): Port 2 Control 0" ,"0"); node1=AddTextTreeNode(node0,"7 Broadcast Storm" ,"0"); node1=AddTextTreeNode(node0,"6 DiffServ Priority" ,"0"); node1=AddTextTreeNode(node0,"5 802.1p Priority" ,"0"); node1=AddTextTreeNode(node0,"4 Port-Based Priority" ,"0"); node1=AddTextTreeNode(node0,"3 Reserved" ,"0"); node1=AddTextTreeNode(node0,"2 Tag Insertion" ,"0"); node1=AddTextTreeNode(node0,"1 Tag Removal" ,"0"); node1=AddTextTreeNode(node0,"0 Priority Enable" ,"0"); node0=AddTextTreeNode(h,"(0x30): Port 3 Control 0" ,"0"); node1=AddTextTreeNode(node0,"7 Broadcast Storm" ,"0"); node1=AddTextTreeNode(node0,"6 DiffServ Priority" ,"0"); node1=AddTextTreeNode(node0,"5 802.1p Priority" ,"0"); node1=AddTextTreeNode(node0,"4 Port-Based Priority" ,"0"); node1=AddTextTreeNode(node0,"3 Reserved" ,"0"); node1=AddTextTreeNode(node0,"2 Tag Insertion" ,"0"); node1=AddTextTreeNode(node0,"1 Tag Removal" ,"0"); node1=AddTextTreeNode(node0,"0 Priority Enable" ,"0"); node0=AddTextTreeNode(j,"(0x40): Port 4 Control 0" ,"0"); node1=AddTextTreeNode(node0,"7 Broadcast Storm" ,"0"); node1=AddTextTreeNode(node0,"6 DiffServ Priority" ,"0"); node1=AddTextTreeNode(node0,"5 802.1p Priority" ,"0"); node1=AddTextTreeNode(node0,"4 Port-Based Priority" ,"0"); node1=AddTextTreeNode(node0,"3 Reserved" ,"0"); node1=AddTextTreeNode(node0,"2 Tag Insertion" ,"0"); node1=AddTextTreeNode(node0,"1 Tag Removal" ,"0"); node1=AddTextTreeNode(node0,"0 Priority Enable" ,"0"); rootNode=a; NodeProcAll(1); SetHexEditorDataList(0,Data,200); skip=0; ShowLeftToolPage(1); ShowDispMode(2); ShowMessage("试试修改左侧树中的数据或右侧十六进制数。两侧数据会同步显示。\r\n[左侧]：为数据含义\r\n[右侧]：为数据内容"); }" /> 
  <Command cmdname="GB/T19056汽车行驶记录仪" cmdType="P" cmd="[P]#include "windows.h" //////////////// 接收队列处理 /////////////////////////////////// #define MAXRXBUFLEN (1024*20) #define GetRxBufLen() ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN) #define IsRxBufEmpty() (RxBufHead==RxBufTail) #define IsRxBufFull() ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead) #define ClearRxBuf() RxBufHead=RxBufTail=0 void main() { int pfm=CreateComponentEx(0,"form","caption","form1","Width",400,"height",300,"BorderIcons","[biSystemMenu]","position","poMainFormCenter","formstyle","fsstayontop","visible",1,NULL); }; BYTE RxBuf[MAXRXBUFLEN]; BYTE RxBufHead=0; BYTE RxBufTail=0; BYTE GetRxBufByte(void) { BYTE dat; dat=RxBuf[RxBufHead]; RxBufHead++; RxBufHead%=MAXRXBUFLEN; return dat; } void DiscardRxBufBytes(BYTE count) { RxBufHead+=count; RxBufHead%=MAXRXBUFLEN; } BYTE PeekRxBufByte(BYTE idx) { BYTE tmpHead=RxBufHead; tmpHead+=idx; tmpHead%=MAXRXBUFLEN; return RxBuf[tmpHead]; } void PutRxBufByte(BYTE dat) { RxBuf[RxBufTail]=dat; RxBufTail++; RxBufTail%=MAXRXBUFLEN; } ////////////////////////////////////////////////////////////////// //////////////// 队列处理 /////////////////////////////////// //#define MAXRXBUFLEN (1024*20) #define GetPrtclBufLen() ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN) #define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail) #define IsPrtclBufFull() ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead) #define ClearPrtclBuf() PrtclBufHead=PrtclBufTail=0 BYTE PrtclBuf[MAXRXBUFLEN]; BYTE PrtclBufHead=0; BYTE PrtclBufTail=0; BYTE GetPrtclBufByte(void) { BYTE dat; dat=PrtclBuf[PrtclBufHead]; PrtclBufHead++; PrtclBufHead%=MAXRXBUFLEN; return dat; } void DiscardPrtclBufBytes(BYTE count) { PrtclBufHead+=count; PrtclBufHead%=MAXRXBUFLEN; } BYTE PeekPrtclBufByte(BYTE idx) { BYTE tmpHead=PrtclBufHead; tmpHead+=idx; tmpHead%=MAXRXBUFLEN; return PrtclBuf[tmpHead]; } void PutPrtclBufByte(BYTE dat) { PrtclBuf[PrtclBufTail]=dat; PrtclBufTail++; PrtclBufTail%=MAXRXBUFLEN; } //////////////////////////////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////////////////////////////////// #define MAXCMDLEN 200 BYTE cmdData[MAXCMDLEN]; BYTE cmdLen; void ProcessRecvCmd(int node,int cmd,unsigned char *dat,int len) { unsigned char s[100]; if(cmd==0x00) { dat[len]=0; sprintf(s,"%s",dat); AddPrtclDetailNode(node,s,0,0); } } void EncodePrtclData(void)//包裹解码 { int i,len; int cmd; int node; unsigned char s[100]; BYTE cs; AddPrtclDetailNode(NULL,"起始字头",PrtclBufHead,2); GetPrtclBufByte();//丢弃一个字节; 55 GetPrtclBufByte();//丢弃一个字节; 7a AddPrtclDetailNode(NULL,"命令字",PrtclBufHead,1); cmd=GetPrtclBufByte();//丢弃一个字节; len int node=AddPrtclDetailNode(NULL,"长度",PrtclBufHead,2); len=GetPrtclBufByte(); len=len*256+GetPrtclBufByte(); sprintf(s,"长度为:%d",len); AddPrtclDetailNode(node,s,0,0); AddPrtclDetailNode(NULL,"保留",PrtclBufHead,1); GetPrtclBufByte();//丢弃一个字节; node=AddPrtclDetailNode(NULL,"数据块",PrtclBufHead,len); for(i=0; i<len; i++) cmdData[i]=GetPrtclBufByte(); AddPrtclDetailNode(NULL,"校验",PrtclBufHead,1); GetPrtclBufByte(); //cs cmdLen=len; printf("Recv a command!"); ProcessRecvCmd(node,cmd,cmdData,cmdLen); } //通讯处理 void ProcessRxComm(void) { BYTE len; unsigned char cs; int i; while(GetRxBufLen()>=7) { if(PeekRxBufByte(0)!=0x55) { DiscardRxBufBytes(1); } else if(PeekRxBufByte(1)!=0x7a) { DiscardRxBufBytes(2); } else { len=PeekRxBufByte(3)*256+PeekRxBufByte(4); if(GetRxBufLen()>=len+7) { cs=0; for(i=0; i<len+7-1; i++) cs=cs^PeekRxBufByte(i); if(cs!=PeekRxBufByte(len+6)) { printf("校验出错!"); DiscardRxBufBytes(2); } else { if(PeekRxBufByte(2)==0x00) { printf("采集执行标准版本号"); AddPrtclDataNode(NULL,"采集执行标准版本号",&RxBuf[RxBufHead],len+7,0); } else if(PeekRxBufByte(2)==0x01) { printf("采集当前驾驶人信息"); AddPrtclDataNode(NULL,"采集当前驾驶人信息",&RxBuf[RxBufHead],len+7,0); } else if(PeekRxBufByte(2)==0x02) { printf("采集实时时钟"); AddPrtclDataNode(NULL,"采集实时时钟",&RxBuf[RxBufHead],len+7,0); } //else if(...) //继续扩充 //{ ... } DiscardRxBufBytes(len+7); } } else { break; } } } //while } void ProcessPrtclData(void) { EncodePrtclData(); } ////////////////////////////////////////////////////////////////////// void RecvSerialData(char *buf,int count) { int i; for(i=0; i<count; i++) { PutRxBufByte(buf[i]); } printf("RecvSerialData,len(%d)",count); ProcessRxComm(); } void AnaProtocolData(char *buf,int count) { int node; int i; printf("AnaProtocolData,len(%d) ",count ); ClearPrtclBuf(); for(i=0; i<count; i++) PutPrtclBufByte(buf[i]); ProcessPrtclData(); } void click(int btn) { unsigned char s0[]= {0x55 ,0x7A ,0x00 ,0x00 ,0x0e ,0x00 ,0x47 ,0x42 ,0x2F ,0x54 ,0x31 ,0x39 ,0x30 ,0x35 ,0x36 ,0x2D ,0x32 ,0x30 ,0x30 ,0x39,0x42}; //char s1[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x02 ,0x02 ,0xf3 ,0xf7 ,0x03}; RecvSerialData(s0,sizeof(s0)); //RecvSerialData(s1,sizeof(s1)); }; void SendCmd(unsigned char cmd,unsigned char *data,int len) { int i; unsigned char buf[1024]; unsigned char s[1024]; unsigned char tmp[10]; unsigned char cs=0; buf[0]=0xAA; buf[1]=0x75; buf[2]=cmd; buf[3]=(len>>8)&0xff; buf[4]=len&0xff; buf[5]=0; for(i=0; i<len; i++) buf[6+i]=data[i]; for(i=0; i<7+len; i++) cs=cs^buf[i]; buf[6+len]=cs; SendBuffer(buf,7+len); s[0]=0; for(i=0; i<7+len; i++) { sprintf(tmp,"%02X,",buf[i]); strcat(s,tmp); } printf("send cmd: %s",s); } void TreeNodeDbClick(int node) { char buf[80]; unsigned char data[100]; int DatCount=0; GetTreeNodeCaption(node,buf+2,80); if(GetNodeParent(node)!=0) return; buf[0]='0'; buf[1]='x'; buf[4]=0; int cmd=StrToInt(buf); int nd=GetFirstChild(node); while(nd!=0) { GetTreeNodeValue(nd,buf,80); //printf("data %d is:%d %d",DatCount,buf[0]&0xff,buf[1]&0xff); data[DatCount++]=StrToInt(buf); nd=GetNextSibing(nd); } //printf("cmd is %d",cmd); SendCmd(cmd,data,DatCount); } void main0() { int i,btn,node; ShowProtocolWin(); ClearVclControls(); ShowOutputWin(700); ShowVclWin(140); int p=GetGuiWin(0); btn=CreateComponentEx(p,"button","caption","模拟数据","left",10,"top",30,"width",85,"onclick",click,NULL);//创建按钮 ClearProtocolTree(); click(0); }; void main() { int node; ShowOutputWin(-1); main0(); ClearTreeNode(); node =AddButtonTreeNode(0,"00.采集记录仪执行标准版本号" ,0); SetTreeNodeBkColor(node,0x0000ff); int b=AddButtonTreeNode(0,"01.采集当前驾驶人信息" ,0); AddButtonTreeNode(0,"02.采集记录仪的实时时钟" ,0); AddButtonTreeNode(0,"03.采集累计行驶里程" ,0); AddButtonTreeNode(0,"04.采集记录仪速度脉冲系数" ,0); AddButtonTreeNode(0,"06.采集车辆信息" ,0); AddButtonTreeNode(0,"08.采集记录仪状态信号配置信息" ,0); AddButtonTreeNode(0,"16.采集记录仪唯一性编号" ,0); node=AddButtonTreeNode(0,"09.采集指定的每秒钟平均速度记录" ,0); AddSpinTreeNode(node,"起始年" ,11,0,99); AddSpinTreeNode(node,"月" ,10,1,12); AddSpinTreeNode(node,"日" ,11,1,21); AddSpinTreeNode(node,"时" ,16,0,23); AddSpinTreeNode(node,"分" ,11,0,59); AddSpinTreeNode(node,"秒" ,16,0,59); AddSpinTreeNode(node,"结束年" ,11,0,99); AddSpinTreeNode(node,"月" ,10,1,12); AddSpinTreeNode(node,"日" ,11,1,21); AddSpinTreeNode(node,"时" ,16,0,23); AddSpinTreeNode(node,"分" ,11,0,59); AddSpinTreeNode(node,"秒",16 ,0,59); AddSpinTreeNode(node,"最大单位数据块个数N(高字节)" ,0,59,16); AddSpinTreeNode(node,"最大单位数据块个数N(低字节)" ,0,59,16); AddButtonTreeNode(0,"05.采集指定的每分钟平均速度记录" ,0); AddButtonTreeNode(0,"13.采集指定的位置信息记录" ,0); AddButtonTreeNode(0,"07.采集指定的事故疑点记录" ,0); AddButtonTreeNode(0,"11.采集指定的疲劳驾驶记录" ,0); AddButtonTreeNode(0,"10.采集指定的登录退出记录" ,0); AddButtonTreeNode(0,"14.采集指定的外部供电记录" ,0); AddButtonTreeNode(0,"15.采集指定的参数修改记录" ,0); node=AddButtonTreeNode(0,"82.设置车辆信息" ,0); SetTreeNodeBkColor(node,0x0000ff); AddButtonTreeNode(0,"83.设置记录仪初次安装日期" ,0); AddButtonTreeNode(0,"84.设置状态量信息" ,0); AddButtonTreeNode(0,"C2.设置记录仪时钟" ,0); AddButtonTreeNode(0,"C3.设置记录仪速度脉冲系数" ,0); node=AddButtonTreeNode(0,"E0.检定控制命令" ,0); SetTreeNodeBkColor(node,0x0000ff); AddButtonTreeNode(0,"E1.记录仪发送速度里程数据" ,0); AddButtonTreeNode(0,"E2.检定模式保持命令" ,0); ShowLeftToolPage(1); //ExplandAllTreeNode(); }" /> 
  <Command cmdname="创建PageControl控件" cmdType="P" cmd="[P]void main() { ClearVclControls(); ShowVclWin(150); ShowOutputWin(300); int p=GetGuiWin(0); int pnl=CreateComponentEx(p,"panel","left",10,"top",10,"width",350,"height",200,0); int pc=CreateComponentEx(p,"PageControl","left",10,"top",10,"width",350,"height",200,0); int AxlerPpm=CreateComponentEx(p,"PopupMenu","AutoHotKeys","maManual",0); int mi=CreateComponentEx(AxlerPpm,"MenuItem","caption","计轴器关闭","OnClick",0,0); AddMenuItem(AxlerPpm,mi); mi=CreateComponentEx(AxlerPpm,"MenuItem","caption","计轴器开启","OnClick",0,0); AddMenuItem(AxlerPpm,mi); mi=CreateComponentEx(AxlerPpm,"MenuItem","caption","模拟过轴","OnClick",0,0); // // int pnl=CreateComponentEx(p,"panel","left",10,"top",10,"width",350,"height",200,"popupmenu",AxlerPpm,0); int ts=CreateComponentEx(p,"tabsheet","caption","abc","PageControl",pc,0); ts=CreateComponentEx(p,"tabsheet","caption","2222343243","PageControl",pc,0); CreateComponentEx(ts,"button","caption","aaa","left",10,"top",10,"width",50,"height",20,0); AutoSetVclWinSize(); }" /> 
  </Command>
- <Command cmdname="嵌入C编译器特性" cmdType="S" cmd="[S]ERROR">
  <Command cmdname="#pragma：添加包含目录" cmdType="P" cmd="[P]#pragma comment(add_include_path,"dat") //添加包含目录 #pragma comment(add_library_path,"dat") //添加库目录 #include "abc.h" #pragma comment(lib,"glGraphLib.o"); //添加库 void main() { };" /> 
  </Command>
  </Command>
- <Command cmdname="操作系统相关" cmdType="P" cmd="[P]void main() { float a; float b; char s[100]; a=1.22; b=3.442; printf("%e",a/b); PrintfToCommWin("%e",a/b); }">
  <Command cmdname="浮点运算" cmdType="P" cmd="[P]void main() { float a; float b; char s[100]; a=1.22; b=3.442; printf("%e",a/b); PrintfToCommWin("%e",a/b); }" /> 
  <Command cmdname="调用动态链接库DLL示例1" cmdType="P" cmd="[P]#include "windows.h" typedef __stdcall DWORD(*Msg)(HWND hWnd, unsigned char *lpText,unsigned char * Caption, unsigned int uType); //宏定义函数指针类型 int main() { HINSTANCE hDll; //DLL句柄 Msg msgFunc; //函数指针 int result; hDll = LoadLibrary("user32.dll"); if(hDll != NULL) { msgFunc = (Msg)GetProcAddress(hDll, "MessageBoxA"); if (msgFunc != NULL) { result =msgFunc(0,"调用user32.dll动态链接库中的MessageBox函数成功！","调用DLL动态链接库示例",3); printf("%d", result); } } else printf("dll not found!"); FreeLibrary(hDll); return 0; }" /> 
  <Command cmdname="调用动态链接库DLL示例2" cmdType="P" cmd="[P]#include <stdio.h> #include <string.h> #include "windows.h" typedef __stdcall DWORD(*ShellExec)(HWND hWnd, unsigned char *Operation,unsigned char *FileName, unsigned char *Parameters, unsigned char *Directory, int uType); //宏定义函数指针类型 int run() { HINSTANCE hDll; //DLL句柄 ShellExec msgFunc; //函数指针 int result; hDll = LoadLibrary("shell32.dll"); if(hDll != NULL) { msgFunc = (ShellExec)GetProcAddress(hDll, "ShellExecuteA"); if (msgFunc != NULL) { result =msgFunc(0,"open","c:\\dd.scf",0,0,1); } } else printf("dll not found!"); FreeLibrary(hDll); return 0; } void main() { FILE *dest; if( (dest=fopen( "c:\\dd.scf", "wb+")) == NULL ) { return; } fprintf(dest,"[Shell]\r\n"); fprintf(dest,"Command=2\r\n"); fprintf(dest,"IconFile=explorer.exe,3\r\n"); fprintf(dest,"[Taskbar]\r\n"); fprintf(dest,"Command=ToggleDesktop\r\n"); fclose(dest); ShowMessage("下面调用Shell32.dll中的ShellExecute API函数，实现显示桌面!"); run(); }" /> 
  <Command cmdname="IE--21ic" cmdType="P" cmd="[P]void main() { ShellExecute(0,"open","IEXPLORE.EXE","http://bbs.21ic.com/icview-266971-1-1.html",0,1); }" /> 
  <Command cmdname="嵌入汇编" cmdType="P" cmd="[P]void main() { unsigned short val; unsigned int a,b; __asm__("fstcw %0":"m"(val)); printf("val0:%x",val); a=123; asm("mov %0,%%eax\r\n mov %%eax,%1":"r"(b):"r"(a)); printf("val1:%d",b); };" /> 
  <Command cmdname="显示桌面" cmdType="P" cmd="[P]#include <stdio.h> unsigned char s[]="[Shell]\r\n"\ "Command=2\r\n"\ "IconFile=explorer.exe,3\r\n"\ "[Taskbar]\r\n"\ "Command=ToggleDesktop\r\n"; void main() { FILE *dest; if( (dest=fopen( "c:\\DispDesktop.scf", "wb+")) == NULL ) return; fprintf(dest,"%s",s); fclose(dest); ShellExecute(0,"open","c:\\DispDesktop.scf",0,0,1); }" /> 
- <Command cmdname="uc/osII" cmdType="S" cmd="[S]ERROR">
  <Command cmdname="UCOSII实验" cmdType="P" cmd="[P]#pragma comment(add_library_path,"script\\ucosii") #pragma comment(add_include_path,"script\\ucosii") #include "includes.h" #pragma comment(lib,"os_cpu_c.c") #pragma comment(lib,"os_dbg_r.c") #pragma comment(lib,"os_trace.c") #pragma comment(lib,"ucos_ii.c") #define TASK_STK_SIZE 128 //extern INT32U OSTerminateCtxSwW32; OS_STK AppStk_one[TASK_STK_SIZE]; OS_STK AppStk_two[TASK_STK_SIZE]; OS_STK AppStk_three[TASK_STK_SIZE]; //int stop=0; static void App_one(void *p_arg); static void App_two(void *p_arg); static void App_three(void *p_arg); static void print_task_ready_tab(void); int btn; void OnTerminate() { OS_STOP(); printf("terminate"); } void CreateGui() { int p; ClearVclControls(); ShowVclWin(300); ShowOutputWin(-1); ClearOutputWin(); p=GetGuiWin(0); btn=CreateComponentEx(p,"button","caption","终止UCOS","left",10,"top",5,"width",80,"height",20,"OnClick",OnTerminate,0); AutoSetVclWinWidth(); } void main(int argc, char *argv[]) { CreateGui(); printf("CommBox ucos ver2.80 start..."); OSInit();// /* Initialize "uC/OS-II"*/ OSTaskCreate(App_one,NULL,(OS_STK *)&AppStk_one[TASK_STK_SIZE-1],(INT8U)11); OSTaskCreate(App_two,NULL,(OS_STK *)&AppStk_two[TASK_STK_SIZE-1],(INT8U)30); OSTaskCreate(App_three,NULL,(OS_STK *)&AppStk_three[TASK_STK_SIZE-1],(INT8U)50); OSStart(); /* Start multitasking */ printf("CommBox ucos end"); SetProperty(btn,"enabled",0); } void App_one(void *p_arg) { p_arg = p_arg; printf("current prio=%d,OSPrioHighRdy=%d\n",OSPrioCur,OSPrioHighRdy); while (TRUE) { printf(""); OS_Printf("\nthis is App_one, Delay 6 second and start again\n"); printf("current prio=%d,OSPrioHighRdy=%d\n",OSPrioCur,OSPrioHighRdy); //OS_Printf("Resume prio=30 task\n"); //OSTaskResume(30); //print_task_ready_tab(); OSTimeDlyHMSM(0, 0, 2, 0); } } void App_two(void *p_arg) { p_arg = p_arg; while (TRUE) { printf(""); OS_Printf("\n\nthis is App_two,Delay 5 second and start again\n"); printf("current prio=%d,OSPrioHighRdy=%d\n",OSPrioCur,OSPrioHighRdy); OS_Printf("suspend prio=30 task\n"); OSTaskSuspend(10); //print_task_ready_tab(); OSTimeDlyHMSM(0, 0, 1, 0); } } void App_three(void *p_arg) { p_arg = p_arg; while (TRUE) { printf(""); OS_Printf("\nthis is App_three, Delay 8 second and start again\n"); printf("current prio=%d,OSPrioHighRdy=%d\n",OSPrioCur,OSPrioHighRdy); //print_task_ready_tab(); //getchar(); OSTimeDlyHMSM(0, 0, 3, 0); } } void print_task_ready_tab(void) { int i; printf("OSRdyGrp=%u\n",OSRdyGrp); for(i=0; i<8; i++) printf("OSRdyTbl[%d]=%d\n",i,OSRdyTbl[i]); printf("\n"); }" /> 
  </Command>
- <Command cmdname="图形化数据分析(GDI、OpenGL)" cmdType="S" cmd="[S]数据发送区/C语言脚本编辑区，[F5]键发送/执行。">
  <Command cmdname="Font" cmdType="P" cmd="[P]#include <windows.h> // Header File For Windows #include <stdio.h> // Header File For Standard Input/Output #include <gl\gl.h> // Header File For The OpenGL32 Library #include <gl\glu.h> // Header File For The GLu32 Library #include <gl\glaux.h> // Header File For The Glaux Library #include"libtcc1.c" #include"math.h" #define bool unsigned char int closing=0; // Private GDI Device Context HGLRC hRC=NULL; // Permanent Rendering Context HWND hWnd=NULL; // Holds Our Window Handle HINSTANCE hInstance; // Holds The Instance Of The Application GLuint base; // Base Display List For The Font Set GLfloat cnt1; // 1st Counter Used To Move Text & For Coloring GLfloat cnt2; // 2nd Counter Used To Move Text & For Coloring bool keys[256]; // Array Used For The Keyboard Routine bool active=TRUE; // Window Active Flag Set To TRUE By Default bool fullscreen=TRUE; // Fullscreen Flag Set To Fullscreen Mode By Default HGLRC hglrc; HDC hdc; int img; int pnl; int GuiMode=2,pfm; void formcreate() { hdc=GetDC(GetFormHandle(pfm)); //hdc=(HANDLE)GetProperty(pnl,"dc",0,0,0); int nPixelFormat; /* static PIXELFORMATDESCRIPTOR pfd= { sizeof(PIXELFORMATDESCRIPTOR), 1, PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER, PFD_TYPE_RGBA, 24, 0,0,0,0,0, 0,0, 0,0,0,0,0, 32, 0, 0, PFD_MAIN_PLANE, 0, 0,0,0 };*/ static PIXELFORMATDESCRIPTOR pfd= // pfd Tells Windows How We Want Things To Be { sizeof(PIXELFORMATDESCRIPTOR), // Size Of This Pixel Format Descriptor 1, // Version Number PFD_DRAW_TO_WINDOW | // Format Must Support Window PFD_SUPPORT_OPENGL | // Format Must Support OpenGL PFD_DOUBLEBUFFER, // Must Support Double Buffering PFD_TYPE_RGBA, // Request An RGBA Format 24, // Select Our Color Depth 0, 0, 0, 0, 0, 0, // Color Bits Ignored 0, // No Alpha Buffer 0, // Shift Bit Ignored 0, // No Accumulation Buffer 0, 0, 0, 0, // Accumulation Bits Ignored 16, // 16Bit Z-Buffer (Depth Buffer) 0, // No Stencil Buffer 0, // No Auxiliary Buffer PFD_MAIN_PLANE, // Main Drawing Layer 0, // Reserved 0, 0, 0 // Layer Masks Ignored }; nPixelFormat=ChoosePixelFormat(hdc,&pfd); SetPixelFormat(hdc,nPixelFormat,&pfd); hglrc=wglCreateContext(hdc); wglMakeCurrent(hdc,hglrc); } //--------------------------------------------------------------------------- GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } void FormDestroy() { closing=1; Wait(1); wglMakeCurrent(NULL,NULL); wglDeleteContext(hglrc); DeleteObject(hdc); printf("destroy"); } void OnClose() { closing=1; Wait(1); if((GuiMode==0)||(GuiMode==1)) { ClearVclControls(); HideVclWin(200); } else { CloseForm(pfm); } } GLvoid BuildFont(GLvoid) // Build Our Bitmap Font { HFONT font; // Windows Font ID HFONT oldfont; // Used For Good House Keeping base = glGenLists(96); // Storage For 96 Characters font = CreateFont( -24, // Height Of Font 0, // Width Of Font 0, // Angle Of Escapement 0, // Orientation Angle FW_BOLD, // Font Weight FALSE, // Italic FALSE, // Underline FALSE, // Strikeout ANSI_CHARSET, // Character Set Identifier OUT_TT_PRECIS, // Output Precision CLIP_DEFAULT_PRECIS, // Clipping Precision ANTIALIASED_QUALITY, // Output Quality FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch "Courier New"); // Font Name printf("font:%x",font); oldfont = (HFONT)SelectObject(hdc, font); // Selects The Font We Want wglUseFontBitmaps(hdc, 32, 96, base); // Builds 96 Characters Starting At Character 32 SelectObject(hdc, oldfont); // Selects The Font We Want DeleteObject(font); // Delete The Font } GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } GLvoid glPrint(const char *fmt, ...) // Custom GL "Print" Routine { char text[256]; // Holds Our String va_list ap; // Pointer To List Of Arguments if (fmt == NULL) // If There's No Text return; // Do Nothing va_start(ap, fmt); // Parses The String For Variables vsprintf(text, fmt, ap); // And Converts Symbols To Actual Numbers va_end(ap); // Results Are Stored In Text //printf(text); glPushAttrib(GL_LIST_BIT); // Pushes The Display List Bits glListBase(base - 32); // Sets The Base Character to 32 glCallLists(strlen(text), GL_UNSIGNED_BYTE, text); // Draws The Display List Text glPopAttrib(); // Pops The Display List Bits } GLvoid ReSizeGLScene(GLsizei width, GLsizei height) // Resize And Initialize The GL Window { if (height==0) // Prevent A Divide By Zero By { height=1; // Making Height Equal One } glViewport(0,0,width,height); // Reset The Current Viewport glMatrixMode(GL_PROJECTION); // Select The Projection Matrix glLoadIdentity(); // Reset The Projection Matrix // Calculate The Aspect Ratio Of The Window gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f); glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix glLoadIdentity(); // Reset The Modelview Matrix } int InitGL(GLvoid) // All Setup For OpenGL Goes Here { glShadeModel(GL_SMOOTH); // Enable Smooth Shading glClearColor(0.0f, 0.0f, 0.0f, 0.5f); // Black Background glClearDepth(1.0f); // Depth Buffer Setup glEnable(GL_DEPTH_TEST); // Enables Depth Testing glDepthFunc(GL_LEQUAL); // The Type Of Depth Testing To Do glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Really Nice Perspective Calculations BuildFont(); // Build The Font return TRUE; // Initialization Went OK } int DrawGLScene(GLvoid) // Here's Where We Do All The Drawing { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear Screen And Depth Buffer glLoadIdentity(); // Reset The Current Modelview Matrix glTranslatef(0.0f,0.0f,-6.0f); // Move One Unit Into The Screen // Pulsing Colors Based On Text Position glColor3f(1.0f ,1.0f ,1.0f ); // Position The Text On The Screen glRasterPos2f(0, 0); glPrint("Active OpenGL Text With NeHe - "); // Print GL Text To The Screen cnt1+=0.051f; // Increase The First Counter cnt2+=0.005f; SwapBuffers(hdc); // Increase The First Counter return TRUE; // Everything Went OK } void OnTimer() { DrawGLScene(); } void OnTest() { DrawGLScene(); } void OnResize() { int x,y; x=GetProperty(pfm,"width",0,0); y=GetProperty(pfm,"height",0,0); ReSizeGLScene(x,y); } void main() { int i,j; int mi,mi1; //HideLeftTools(); ClearVclControls(); //ShowVclWin(-1); if((GuiMode==0)||(GuiMode==1)) pfm=GetGuiWin(GuiMode); else pfm=CreateComponentEx(0,"form","caption","调幅-正弦波","Width",600,"height",300,"BorderIcons","[biSystemMenu,biMaximize]","position","poMainFormCenter","formstyle","fsstayontop","OnClose",FormDestroy,"OnResize",OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] int btn=CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); CreateComponentEx(pfm,"SpeedButton","caption","test","left",80,"top",5,"width",60,"height",20,"OnClick",OnTest,0); //img=CreateComponentEx(pfm,"Image","left",10,"top",10,"width",200,"height",200,0); SetProperty(pfm,"visible",1);//// formcreate(); OnResize(); InitGL(); DrawGLScene(); int count=0; while(!closing) { DrawGLScene(); count++; if(count%5==4) { Wait(1); } } printf("exit"); }" /> 
  <Command cmdname="粒子运动" cmdType="P" cmd="[P]#include <windows.h> // Header File For Windows #include <stdio.h> // Header File For Standard Input/Output #include <gl\gl.h> // Header File For The OpenGL32 Library #include <gl\glu.h> // Header File For The GLu32 Library #include <gl\glaux.h> // Header File For The Glaux Library #define bool unsigned char HDC hDC=NULL; // Private GDI Device Context HGLRC hRC=NULL; // Permanent Rendering Context HWND hWnd=NULL; // Holds Our Window Handle HINSTANCE hInstance; // Holds The Instance Of The Application bool keys[256]; // Array Used For The Keyboard Routine bool active=TRUE; // Window Active Flag Set To TRUE By Default bool fullscreen=TRUE; // Fullscreen Flag Set To Fullscreen Mode By Default bool twinkle; // Twinkling Stars bool tp; // 'T' Key Pressed? bool closing=0; #define num 80 // Number Of Stars To Draw typedef struct aaaa // Create A Structure For Star { int r, g, b; // Stars Color GLfloat dist, // Stars Distance From Center angle; // Stars Current Angle } stars; stars star[num]; // Need To Keep Track Of 'num' Stars GLfloat zoom=-15.0f; // Distance Away From Stars GLfloat tilt=90.0f; // Tilt The View GLfloat spin; // Spin Stars GLuint loop; // General Loop Variable GLuint texture[1]; // Storage For One textures LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); // Declaration For WndProc HGLRC hglrc; HDC hdc; int img; int pnl; int GuiMode=2,pfm; void formcreate() { hdc=GetDC(GetFormHandle(pfm)); //hdc=(HANDLE)GetProperty(pnl,"dc",0,0,0); int nPixelFormat; static PIXELFORMATDESCRIPTOR pfd= { sizeof(PIXELFORMATDESCRIPTOR), 1, PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER, PFD_TYPE_RGBA, 24, 0,0,0,0,0, 0,0, 0,0,0,0,0, 32, 0, 0, PFD_MAIN_PLANE, 0, 0,0,0 }; nPixelFormat=ChoosePixelFormat(hdc,&pfd); SetPixelFormat(hdc,nPixelFormat,&pfd); hglrc=wglCreateContext(hdc); wglMakeCurrent(hdc,hglrc); } //--------------------------------------------------------------------------- void FormDestroy() { closing=1; Wait(1); wglMakeCurrent(NULL,NULL); wglDeleteContext(hglrc); DeleteObject(hdc); printf("destroy"); } void OnClose() { closing=1; Wait(1); if((GuiMode==0)||(GuiMode==1)) { ClearVclControls(); HideVclWin(200); } else { CloseForm(pfm); } } AUX_RGBImageRec *LoadBMP(char *Filename) // Loads A Bitmap Image { FILE *File=NULL; // File Handle if (!Filename) // Make Sure A Filename Was Given { return NULL; // If Not Return NULL } File=fopen(Filename,"r"); // Check To See If The File Exists if (File) // Does The File Exist? { fclose(File); // Close The Handle return auxDIBImageLoad(Filename); // Load The Bitmap And Return A Pointer } return NULL; // If Load Failed Return NULL } int LoadGLTextures() // Load Bitmaps And Convert To Textures { int Status=FALSE; // Status Indicator AUX_RGBImageRec *TextureImage[1]; // Create Storage Space For The Texture memset(TextureImage,0,sizeof(void *)*1); // Set The Pointer To NULL // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit if (TextureImage[0]=LoadBMP("dat/star.bmp")) { Status=TRUE; // Set The Status To TRUE glGenTextures(1, &texture[0]); // Create One Texture // Create Linear Filtered Texture glBindTexture(GL_TEXTURE_2D, texture[0]); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data); } if (TextureImage[0]) // If Texture Exists { if (TextureImage[0]->data) // If Texture Image Exists { free(TextureImage[0]->data); // Free The Texture Image Memory } free(TextureImage[0]); // Free The Image Structure } return Status; // Return The Status } GLvoid ReSizeGLScene(GLsizei width, GLsizei height) // Resize And Initialize The GL Window { if (height==0) // Prevent A Divide By Zero By { height=1; // Making Height Equal One } glViewport(0,0,width,height); // Reset The Current Viewport glMatrixMode(GL_PROJECTION); // Select The Projection Matrix glLoadIdentity(); // Reset The Projection Matrix // Calculate The Aspect Ratio Of The Window gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f); glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix glLoadIdentity(); // Reset The Modelview Matrix } int InitGL(GLvoid) // All Setup For OpenGL Goes Here { if (!LoadGLTextures()) // Jump To Texture Loading Routine { printf("LoadGLTextures error!"); return FALSE; // If Texture Didn't Load Return FALSE } glEnable(GL_TEXTURE_2D); // Enable Texture Mapping glShadeModel(GL_SMOOTH); // Enable Smooth Shading glClearColor(0.0f, 0.0f, 0.0f, 0.5f); // Black Background glClearDepth(1.0f); // Depth Buffer Setup glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Really Nice Perspective Calculations glBlendFunc(GL_SRC_ALPHA,GL_ONE); // Set The Blending Function For Translucency glEnable(GL_BLEND); for (loop=0; loop<num; loop++) { star[loop].angle=0.0f; star[loop].dist=( (loop*1.0)/num)*5.0f; star[loop].r=rand()%256; star[loop].g=rand()%256; star[loop].b=rand()%256; } return TRUE; // Initialization Went OK } int DrawGLScene(GLvoid) // Here's Where We Do All The Drawing { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear The Screen And The Depth Buffer glBindTexture(GL_TEXTURE_2D, texture[0]); // Select Our Texture for (loop=0; loop<num; loop++) // Loop Through All The Stars { glLoadIdentity(); // Reset The View Before We Draw Each Star glTranslatef(0.0f,0.0f,zoom); // Zoom Into The Screen (Using The Value In 'zoom') glRotatef(tilt,1.0f,0.0f,0.0f); // Tilt The View (Using The Value In 'tilt') glRotatef(star[loop].angle,0.0f,1.0f,0.0f); // Rotate To The Current Stars Angle glTranslatef(star[loop].dist,0.0f,0.0f); // Move Forward On The X Plane glRotatef(-star[loop].angle,0.0f,1.0f,0.0f); // Cancel The Current Stars Angle glRotatef(-tilt,1.0f,0.0f,0.0f); // Cancel The Screen Tilt if (twinkle) { glColor4ub(star[(num-loop)-1].r,star[(num-loop)-1].g,star[(num-loop)-1].b,255); glBegin(GL_QUADS); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f,-1.0f, 0.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f,-1.0f, 0.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 0.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 0.0f); glEnd(); } glRotatef(spin,0.0f,0.0f,1.0f); glColor4ub(star[loop].r,star[loop].g,star[loop].b,255); glBegin(GL_QUADS); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f,-1.0f, 0.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f,-1.0f, 0.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 0.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 0.0f); glEnd(); spin+=0.01f; star[loop].angle+= (loop*1.0)/num; star[loop].dist-=0.01f; if (star[loop].dist<0.0f) { star[loop].dist+=5.0f; star[loop].r=rand()%256; star[loop].g=rand()%256; star[loop].b=rand()%256; } } SwapBuffers(hdc); return TRUE; // Everything Went OK } void OnTimer() { DrawGLScene(); } void OnTest() { DrawGLScene(); } void main() { int i,j; int mi,mi1; //HideLeftTools(); ClearVclControls(); ShowVclWin(-1); if((GuiMode==0)||(GuiMode==1)) { pfm=GetGuiWin(GuiMode); } else pfm=CreateComponentEx(0,"form","caption","粒子运动","Width",660,"height",370,"BorderIcons","[biSystemMenu]","position","poMainFormCenter","formstyle","fsstayontop","OnDestroy",FormDestroy,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] //CreateComponentEx(pfm,"timer","interval",100,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 ////pnl=CreateComponentEx(pfm,"panel","left",10,"top",40,"width",200,"height",200,"OnPaint",FormPaint,0); int btn=CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); CreateComponentEx(pfm,"SpeedButton","caption","test","left",80,"top",5,"width",60,"height",20,"OnClick",OnTest,0); //img=CreateComponentEx(pfm,"Image","left",10,"top",10,"width",200,"height",200,0); SetProperty(pfm,"visible",1);//// formcreate(); ReSizeGLScene(660,370); InitGL(); DrawGLScene(); int count=0; while(!closing) { DrawGLScene(); count++; if(count%5==4) { //Invalidate(btn); Wait(1); } } }" /> 
  <Command cmdname="正方体" cmdType="P" cmd="[P]#include <windows.h> // Header File For Windows #include <stdio.h> // Header File For Standard Input/Output #include <gl\gl.h> // Header File For The OpenGL32 Library #include <gl\glu.h> // Header File For The GLu32 Library #include <gl\glaux.h> // Header File For The Glaux Library #include"libtcc1.c" #include"math.h" #define bool unsigned char HDC hDC=NULL; // Private GDI Device Context HGLRC hRC=NULL; // Permanent Rendering Context HWND hWnd=NULL; // Holds Our Window Handle HINSTANCE hInstance; // Holds The Instance Of The Application bool keys[256]; // Array Used For The Keyboard Routine bool active=TRUE; // Window Active Flag Set To TRUE By Default bool fullscreen=TRUE; // Fullscreen Flag Set To Fullscreen Mode By Default GLuint base; bool twinkle; // Twinkling Stars bool tp; // 'T' Key Pressed? bool closing=0; #define num 360 // Number Of Stars To Draw GLfloat cnt1=0.0f; // 1st Counter Used To Move Text & For Coloring GLfloat cnt2=0.0f; // 2nd Counter Used To Move Text & For Coloring GLfloat xrot; // X Rotation ( NEW ) GLfloat yrot; // Y Rotation ( NEW ) GLfloat zrot; // Z Rotation ( NEW ) typedef struct aaaa // Create A Structure For Star { int r, g, b; // Stars Color GLfloat dist, // Stars Distance From Center angle; // Stars Current Angle } stars; stars star[num]; // Need To Keep Track Of 'num' Stars GLfloat zoom=-15.0f; // Distance Away From Stars GLfloat tilt=90.0f; // Tilt The View GLfloat spin; // Spin Stars GLuint loop; // General Loop Variable GLuint texture[1]; // Storage For One textures LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); // Declaration For WndProc HGLRC hglrc; HDC hdc; int img; int pnl; int GuiMode=2,pfm; void formcreate() { hdc=GetDC(GetFormHandle(pfm)); //hdc=(HANDLE)GetProperty(pnl,"dc",0,0,0); int nPixelFormat; static PIXELFORMATDESCRIPTOR pfd= { sizeof(PIXELFORMATDESCRIPTOR), 1, PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER, PFD_TYPE_RGBA, 24, 0,0,0,0,0, 0,0, 0,0,0,0,0, 32, 0, 0, PFD_MAIN_PLANE, 0, 0,0,0 }; nPixelFormat=ChoosePixelFormat(hdc,&pfd); SetPixelFormat(hdc,nPixelFormat,&pfd); hglrc=wglCreateContext(hdc); wglMakeCurrent(hdc,hglrc); } //--------------------------------------------------------------------------- GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } void FormDestroy() { closing=1; Wait(1); wglMakeCurrent(NULL,NULL); wglDeleteContext(hglrc); DeleteObject(hdc); printf("destroy"); } void OnClose() { closing=1; Wait(1); if((GuiMode==0)||(GuiMode==1)) { ClearVclControls(); HideVclWin(200); } else { CloseForm(pfm); } } GLvoid BuildFont(GLvoid) // Build Our Bitmap Font { HFONT font; // Windows Font ID HFONT oldfont; // Used For Good House Keeping base = glGenLists(96); // Storage For 96 Characters font = CreateFont( -24, // Height Of Font 0, // Width Of Font 0, // Angle Of Escapement 0, // Orientation Angle FW_BOLD, // Font Weight FALSE, // Italic FALSE, // Underline FALSE, // Strikeout ANSI_CHARSET, // Character Set Identifier OUT_TT_PRECIS, // Output Precision CLIP_DEFAULT_PRECIS, // Clipping Precision ANTIALIASED_QUALITY, // Output Quality FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch "Courier New"); // Font Name oldfont = (HFONT)SelectObject(hDC, font); // Selects The Font We Want wglUseFontBitmaps(hDC, 32, 96, base); // Builds 96 Characters Starting At Character 32 SelectObject(hDC, oldfont); // Selects The Font We Want DeleteObject(font); // Delete The Font } GLvoid glPrint(const char *fmt, ...) // Custom GL "Print" Routine { char text[256]; // Holds Our String va_list ap; // Pointer To List Of Arguments if (fmt == NULL) // If There's No Text return; // Do Nothing va_start(ap, fmt); // Parses The String For Variables vsprintf(text, fmt, ap); // And Converts Symbols To Actual Numbers va_end(ap); // Results Are Stored In Text glPushAttrib(GL_LIST_BIT); // Pushes The Display List Bits glListBase(base - 32); // Sets The Base Character to 32 glCallLists(strlen(text), GL_UNSIGNED_BYTE, text); // Draws The Display List Text glPopAttrib(); // Pops The Display List Bits } AUX_RGBImageRec *LoadBMP(char *Filename) // Loads A Bitmap Image { FILE *File=NULL; // File Handle if (!Filename) // Make Sure A Filename Was Given { return NULL; // If Not Return NULL } File=fopen(Filename,"r"); // Check To See If The File Exists if (File) // Does The File Exist? { fclose(File); // Close The Handle return auxDIBImageLoad(Filename); // Load The Bitmap And Return A Pointer } return NULL; // If Load Failed Return NULL } int LoadGLTextures1() // Load Bitmaps And Convert To Textures { int Status=FALSE; // Status Indicator AUX_RGBImageRec *TextureImage[1]; // Create Storage Space For The Texture memset(TextureImage,0,sizeof(void *)*1); // Set The Pointer To NULL // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit if (TextureImage[0]=LoadBMP("dat\\mf.BMP")) { Status=TRUE; // Set The Status To TRUE glGenTextures(1, &texture[0]); // Create One Texture // Create Linear Filtered Texture glBindTexture(GL_TEXTURE_2D, texture[0]); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data); } if (TextureImage[0]) // If Texture Exists { if (TextureImage[0]->data) // If Texture Image Exists { free(TextureImage[0]->data); // Free The Texture Image Memory } free(TextureImage[0]); // Free The Image Structure } return Status; // Return The Status } int LoadGLTextures() // Load Bitmaps And Convert To Textures { int Status=FALSE; // Status Indicator AUX_RGBImageRec *TextureImage[1]; // Create Storage Space For The Texture memset(TextureImage,0,sizeof(void *)*1); // Set The Pointer To NULL // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit if (TextureImage[0]=LoadBMP("dat\\mf.BMP")) { Status=TRUE; // Set The Status To TRUE glGenTextures(1, &texture[0]); // Create The Texture // Typical Texture Generation Using Data From The Bitmap glBindTexture(GL_TEXTURE_2D, texture[0]); glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); } else printf("load bmp error"); if (TextureImage[0]) // If Texture Exists { if (TextureImage[0]->data) // If Texture Image Exists { free(TextureImage[0]->data); // Free The Texture Image Memory } free(TextureImage[0]); // Free The Image Structure } return Status; // Return The Status } GLvoid ReSizeGLScene(GLsizei width, GLsizei height) // Resize And Initialize The GL Window { if (height==0) // Prevent A Divide By Zero By { height=1; // Making Height Equal One } glViewport(0,0,width,height); // Reset The Current Viewport glMatrixMode(GL_PROJECTION); // Select The Projection Matrix glLoadIdentity(); // Reset The Projection Matrix // Calculate The Aspect Ratio Of The Window gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f); glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix glLoadIdentity(); // Reset The Modelview Matrix } int InitGL(GLvoid) // All Setup For OpenGL Goes Here { if (!LoadGLTextures()) // Jump To Texture Loading Routine ( NEW ) { return FALSE; // If Texture Didn't Load Return FALSE } glEnable(GL_TEXTURE_2D); // Enable Texture Mapping ( NEW ) glShadeModel(GL_SMOOTH); // Enable Smooth Shading glClearColor(0.0f, 0.0f, 0.0f, 0.5f); // Black Background glClearDepth(1.0f); // Depth Buffer Setup glEnable(GL_DEPTH_TEST); // Enables Depth Testing glDepthFunc(GL_LEQUAL); // The Type Of Depth Testing To Do glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Really Nice Perspective Calculations return TRUE; // Initialization Went OK } unsigned int Start=0; int DrawGLScene1(GLvoid) // Here's Where We Do All The Drawing { int i; if(closing) return 0; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear The Screen And The Depth Buffer glBindTexture(GL_TEXTURE_2D, texture[0]); // Select Our Texture Start+=1; Start%=720; glEnable(GL_LINE_SMOOTH); glDisable(GL_TEXTURE_2D); for(i=1; i<5; i++) { glLoadIdentity(); // glTranslatef(-12.5f,3.0f,-22.0f ); glLineWidth(1.2f*(5-i)); // 设置线宽为2.0f glColor4f(0.0f,1.0f,0.0f,0.10f*i); glBegin(GL_LINE_STRIP ); // 绘制当前的线段 for (loop=0; loop<num; loop++) // Loop Through All The Stars { // glVertex3f((loop+0)*0.3-22,5.0*sin(3.14*4.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14f*4*loop/num)+6,zoom*2); glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14*3.0*Start/360.0+3.14f*3*loop/num)+6,zoom*2); } glEnd(); glBegin(GL_LINE_STRIP ); // 绘制当前的线段 for (loop=0; loop<num; loop+=1) // Loop Through All The Stars { glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))-6,zoom*2); } glEnd(); glColor4f(1.0f,0.0f,1.0f,0.10f*i); glBegin(GL_LINE_STRIP ); // 绘制当前的线段 for (loop=0; loop<num; loop+=4) // Loop Through All The Stars { glVertex3f((loop+0)*0.2-22,2.0*sin(3.14f*6*loop/num)-18,zoom*2); } glEnd(); } glEnable(GL_TEXTURE_2D); glLoadIdentity(); // // Reset The View Before We Draw Each Star glTranslatef(-1.5f,0.0f,-6.0f); glColor4ub(0,150,0,255); for(i=0; i<5; i++) { glBegin(GL_QUADS); glTexCoord2f(0.0f, 0.0f); glVertex3f(-20.0f,-0.0f+i*1.0-2, 0.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 25.0f,-0.0f+i*1.0-2, 0.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 25.0f, 0.1f+i*1.0-2, 0.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-20.0f, 0.1f+i*1.0-2, 0.0f); glEnd(); } glLoadIdentity(); // // Reset The View Before We Draw Each Star glTranslatef(-2.5f,0.0f,-6.0f); glColor4ub(0,150,0,255); for(i=0; i<10; i++) { glBegin(GL_QUADS); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.5f+i*1.0,-10.0f, 0.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( -1.6f+i*1.0,-10.0f, 0.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( -1.6f+i*1.0, 10.1f, 0.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.5f+i*1.0, 10.1f, 0.0f); glEnd(); } SwapBuffers(hdc); return TRUE; // Everything Went OK } int DrawGLScene(GLvoid) // Here's Where We Do All The Drawing { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear The Screen And The Depth Buffer glLoadIdentity(); // Reset The View glTranslatef(0.0f,-0.2f,-5.0f); glRotatef(xrot,1.0f,0.0f,0.0f); glRotatef(yrot,0.0f,1.0f,0.0f); glRotatef(zrot,0.0f,0.0f,1.0f); glBindTexture(GL_TEXTURE_2D, texture[0]); glBegin(GL_QUADS); // Front Face glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); // Back Face glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); // Top Face glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, 1.0f, 1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, 1.0f, 1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); // Bottom Face glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, -1.0f, -1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); // Right face glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); // Left Face glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); glEnd(); xrot+=0.3f; yrot+=0.2f; zrot+=0.4f; SwapBuffers(hdc); return TRUE; // Keep Going } void OnTimer() { DrawGLScene(); } void OnTest() { DrawGLScene(); } void OnResize() { int x,y; x=GetProperty(pfm,"width",0,0); y=GetProperty(pfm,"height",0,0); ReSizeGLScene(x,y); } void main() { int i,j; int mi,mi1; //HideLeftTools(); ClearVclControls(); HideVclWin(-1); if((GuiMode==0)||(GuiMode==1)) pfm=GetGuiWin(GuiMode); else pfm=CreateComponentEx(0,"form","caption","正方体","Width",300,"height",340,"BorderIcons","[biSystemMenu,biMaximize]","position","poMainFormCenter","formstyle","fsstayontop","OnClose",FormDestroy,"OnResize",OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] int btn=CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); CreateComponentEx(pfm,"SpeedButton","caption","test","left",80,"top",5,"width",60,"height",20,"OnClick",OnTest,0); //img=CreateComponentEx(pfm,"Image","left",10,"top",10,"width",200,"height",200,0); SetProperty(pfm,"visible",1);//// formcreate(); OnResize(); InitGL(); DrawGLScene(); int count=0; while(!closing) { DrawGLScene(); count++; if(count%2==1) { Wait(5); } } printf("exit"); }" /> 
  <Command cmdname="OpenGL例子1" cmdType="P" cmd="[P]#include <windows.h> // Header File For Windows #include <stdio.h> // Header File For Standard Input/Output #include <gl\gl.h> // Header File For The OpenGL32 Library #include <gl\glu.h> // Header File For The GLu32 Library #include <gl\glaux.h> // Header File For The Glaux Library //#include"libtcc1.c" #include"math.h" #define bool unsigned char int closing=0; // Private GDI Device Context HGLRC hRC=NULL; // Permanent Rendering Context HWND hWnd=NULL; // Holds Our Window Handle HINSTANCE hInstance; // Holds The Instance Of The Application GLuint base; // Base Display List For The Font Set GLfloat cnt1; // 1st Counter Used To Move Text & For Coloring GLfloat cnt2; // 2nd Counter Used To Move Text & For Coloring bool keys[256]; // Array Used For The Keyboard Routine bool active=TRUE; // Window Active Flag Set To TRUE By Default bool fullscreen=TRUE; // Fullscreen Flag Set To Fullscreen Mode By Default int ElapsedTime, AppStart, LastTime ; // Timing variables HGLRC hglrc; HDC hdc; int img; int pnl; int GuiMode=2,pfm; int *ft; void formcreate() { hdc=GetDC(GetFormHandle(pfm)); //hdc=(HANDLE)GetProperty(pnl,"dc",0,0,0); int nPixelFormat; /* static PIXELFORMATDESCRIPTOR pfd= { sizeof(PIXELFORMATDESCRIPTOR), 1, PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER, PFD_TYPE_RGBA, 24, 0,0,0,0,0, 0,0, 0,0,0,0,0, 32, 0, 0, PFD_MAIN_PLANE, 0, 0,0,0 };*/ static PIXELFORMATDESCRIPTOR pfd= // pfd Tells Windows How We Want Things To Be { sizeof(PIXELFORMATDESCRIPTOR), // Size Of This Pixel Format Descriptor 1, // Version Number PFD_DRAW_TO_WINDOW | // Format Must Support Window PFD_SUPPORT_OPENGL | // Format Must Support OpenGL PFD_DOUBLEBUFFER, // Must Support Double Buffering PFD_TYPE_RGBA, // Request An RGBA Format 24, // Select Our Color Depth 0, 0, 0, 0, 0, 0, // Color Bits Ignored 0, // No Alpha Buffer 0, // Shift Bit Ignored 0, // No Accumulation Buffer 0, 0, 0, 0, // Accumulation Bits Ignored 16, // 16Bit Z-Buffer (Depth Buffer) 0, // No Stencil Buffer 0, // No Auxiliary Buffer PFD_MAIN_PLANE, // Main Drawing Layer 0, // Reserved 0, 0, 0 // Layer Masks Ignored }; nPixelFormat=ChoosePixelFormat(hdc,&pfd); SetPixelFormat(hdc,nPixelFormat,&pfd); hglrc=wglCreateContext(hdc); wglMakeCurrent(hdc,hglrc); } //--------------------------------------------------------------------------- GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } void FormDestroy() { closing=1; Wait(1); wglMakeCurrent(NULL,NULL); wglDeleteContext(hglrc); DeleteObject(hdc); printf("destroy"); } void OnClose() { closing=1; Wait(1); if((GuiMode==0)||(GuiMode==1)) { ClearVclControls(); HideVclWin(200); } else { CloseForm(pfm); } } GLvoid BuildFont(GLvoid) // Build Our Bitmap Font { HFONT font; // Windows Font ID HFONT oldfont; // Used For Good House Keeping base = glGenLists(96); // Storage For 96 Characters font = CreateFont( -24, // Height Of Font 0, // Width Of Font 0, // Angle Of Escapement 0, // Orientation Angle FW_BOLD, // Font Weight FALSE, // Italic FALSE, // Underline FALSE, // Strikeout ANSI_CHARSET, // Character Set Identifier OUT_TT_PRECIS, // Output Precision CLIP_DEFAULT_PRECIS, // Clipping Precision ANTIALIASED_QUALITY, // Output Quality FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch "Courier New"); // Font Name printf("font:%x",font); oldfont = (HFONT)SelectObject(hdc, font); // Selects The Font We Want wglUseFontBitmaps(hdc, 32, 96, base); // Builds 96 Characters Starting At Character 32 SelectObject(hdc, oldfont); // Selects The Font We Want DeleteObject(font); // Delete The Font } GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } void DrawLine(double x0,double y0,double x1,double y1) { glBegin(GL_LINES); glVertex3f(x0,y0, 0.0f); glVertex3f(x1,y1, 0.0f); glEnd(); } GLvoid glPrint(const char *fmt, ...) // Custom GL "Print" Routine { char text[256]; // Holds Our String va_list ap; // Pointer To List Of Arguments if (fmt == NULL) // If There's No Text return; // Do Nothing va_start(ap, fmt); // Parses The String For Variables vsprintf(text, fmt, ap); // And Converts Symbols To Actual Numbers va_end(ap); // Results Are Stored In Text //printf(text); glPushAttrib(GL_LIST_BIT); // Pushes The Display List Bits glListBase(base - 32); // Sets The Base Character to 32 glCallLists(strlen(text), GL_UNSIGNED_BYTE, text); // Draws The Display List Text glPopAttrib(); // Pops The Display List Bits } GLvoid ReSizeGLScene(GLsizei width, GLsizei height) // Resize And Initialize The GL Window { if (height==0) // Prevent A Divide By Zero By { height=1; // Making Height Equal One } glViewport(0,0,width,height); // Reset The Current Viewport glMatrixMode(GL_PROJECTION); // Select The Projection Matrix glLoadIdentity(); // Reset The Projection Matrix // Calculate The Aspect Ratio Of The Window gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f); glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix glLoadIdentity(); // Reset The Modelview Matrix } #define FT_ENC_TAG( value, a, b, c, d ) \ unsigned int value = ( ( (int)(a) << 24 ) | \ ( (int)(b) << 16 ) | \ ( (int)(c) << 8 ) | \ (int)(d) ) FT_ENC_TAG( FT_ENCODING_UNICODE, 'u', 'n', 'i', 'c' ); int InitGL(GLvoid) // All Setup For OpenGL Goes Here { int r; glShadeModel(GL_SMOOTH); // Enable Smooth Shading glClearColor(0.0f, 0.0f, 0.0f, 0.5f); // Black Background glClearDepth(1.0f); // Depth Buffer Setup glEnable(GL_DEPTH_TEST); // Enables Depth Testing glDepthFunc(GL_LEQUAL); // The Type Of Depth Testing To Do glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Really Nice Perspective Calculations BuildFont(); // Build The Font return TRUE; // Initialization Went OK } int AnsiToUnicode(unsigned char *pszA, unsigned char* ppszW) { ULONG cCharacters; DWORD dwError; if (NULL == pszA) { *ppszW = NULL; printf("ERROR0"); return NOERROR; } cCharacters = strlen(pszA)+1; if (NULL == ppszW) return E_OUTOFMEMORY; // Covert to Unicode. if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, -1, ppszW, cCharacters)) { dwError = GetLastError(); free(ppszW); ppszW = NULL; printf("ERROR"); return HRESULT_FROM_WIN32(dwError); } return NOERROR; } #define Sin sin #define Cos cos int DrawGLScene(GLvoid) // Here's Where We Do All The Drawing { char buf[]= {0x31,0,0x32,0,0x8d,0x9c,0,0}; char buf1[100]; int i,I; float S; float R,G,B; float P180 = 3.1415/180; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear Screen And Depth Buffer glLoadIdentity(); // Reset The Current Modelview Matrix glTranslatef(-1.0f,0.0f,-6.0f); // Move One Unit Into The Screen // Pulsing Colors Based On Text Position glColor3f(1.0f ,0.0f ,1.0f ); // Position The Text On The Screen glTranslatef(0, 0, -5); glRotatef(ElapsedTime/40.0, 1, 1, 1); glScalef(2,2,1); glDisable(GL_TEXTURE_2D); glBegin(GL_TRIANGLE_STRIP); for(I= 0; I<= 72; I++) { S = 0.5+Sin(ElapsedTime/465.0)*0.2+Cos(ElapsedTime/657.0)*0.1; R = 0.5+Sin(ElapsedTime/100.0+I/1.6)*0.5; G = 0.5+Sin(ElapsedTime/200.0+720+I/1.6)*0.5; B = 0.5+Sin(ElapsedTime/100.0+720+I/1.6)*0.5; glColor3f(R,G,B); glVertex3f(Sin(P180*I*5.0)*S, Cos(P180*I*5.0)*S, Sin(P180*(I*10+ElapsedTime/500.0))*(0.5+sin(ElapsedTime/300.0)*0.3)); glColor3f(B,G,R); glVertex3f(Sin(P180*I*5.0)*S*2, Cos(P180*I*5.0)*S*2, 1+Sin(P180*(I*(20)+ElapsedTime/500.0))*(0.5+sin(ElapsedTime/800.0)*0.4+cos(ElapsedTime/450.0)*0.4)); } glEnd(); SwapBuffers(hdc); // Increase The First Counter return TRUE; // Everything Went OK } void OnTimer() { LastTime =ElapsedTime; ElapsedTime =GetTickCount() - AppStart; // Calculate Elapsed Time ElapsedTime =(LastTime + ElapsedTime) / 2; // Average it out for smoother movement DrawGLScene(); } void OnTest() { DrawGLScene(); } void OnResize() { int x,y; x=GetProperty(pfm,"width",0,0); y=GetProperty(pfm,"height",0,0); ReSizeGLScene(x,y); } void main() { int i,j; int mi,mi1; //HideLeftTools(); ClearVclControls(); //ShowVclWin(-1); if((GuiMode==0)||(GuiMode==1)) pfm=GetGuiWin(GuiMode); else pfm=CreateComponentEx(0,"form","caption","调幅-正弦波","Width",600,"height",300,"BorderIcons","[biSystemMenu,biMaximize]","position","poMainFormCenter","formstyle","fsstayontop","OnClose",FormDestroy,"OnResize",OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] int btn=CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); CreateComponentEx(pfm,"SpeedButton","caption","test","left",80,"top",5,"width",60,"height",20,"OnClick",OnTest,0); //img=CreateComponentEx(pfm,"Image","left",10,"top",10,"width",200,"height",200,0); SetProperty(pfm,"visible",1);//// formcreate(); OnResize(); InitGL(); DrawGLScene(); //ReaderShxFile("dat\\txt.shx"); int count=0; while(!closing) { OnTimer(); //DrawGLScene(); count++; if(count%5==4) { //printf("count:%d",count); Wait(1); } } printf("exit"); }" /> 
  <Command cmdname="OpenGL例子2" cmdType="P" cmd="[P] #include "windows.h" #include <gl/gl.h> HGLRC hglrc; HDC hdc; int img; int pnl; int GuiMode=2,pfm; void formcreate() { hdc=GetDC(GetFormHandle(pfm)); //hdc=(HANDLE)GetProperty(pnl,"dc",0,0,0); int nPixelFormat; static PIXELFORMATDESCRIPTOR pfd= { sizeof(PIXELFORMATDESCRIPTOR), 1, PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER, PFD_TYPE_RGBA, 24, 0,0,0,0,0, 0,0, 0,0,0,0,0, 32, 0, 0, PFD_MAIN_PLANE, 0, 0,0,0 }; nPixelFormat=ChoosePixelFormat(hdc,&pfd); SetPixelFormat(hdc,nPixelFormat,&pfd); hglrc=wglCreateContext(hdc); wglMakeCurrent(hdc,hglrc); } //--------------------------------------------------------------------------- void FormDestroy() { wglMakeCurrent(NULL,NULL); wglDeleteContext(hglrc); DeleteObject(hdc); printf("destroy"); } void OnClose() { if((GuiMode==0)||(GuiMode==1)) { ClearVclControls(); HideVclWin(200); } else { CloseForm(pfm); } } int N=5; void Point(float x,float y) { glBegin( GL_POINTS); glVertex2f(x, y); glEnd(); } void Line (float x1, float y1, float x2, float y2) { glBegin( GL_LINES); glVertex2f(x1, y1); glVertex2f(x2, y2); glEnd(); } void triangle(float x1, float y1, float x2, float y2,float x3, float y3) { glBegin(GL_POLYGON); glColor3f(1.0f,0.0f,0.0f); glVertex2f(x1,y1); glVertex2f(x2,y2); glVertex2f(x3,y3); glEnd(); } void S_Gasket(float x1, float y1, float x2, float y2,float x3, float y3,int n) { float x12,y12,x13,y13,x23,y23; if(n>0) { x12=(x1+x2)/2; y12=(y1+y2)/2; x13=(x1+x3)/2; y13=(y1+y3)/2; x23=(x2+x3)/2; y23=(y2+y3)/2; S_Gasket(x1,y1,x12,y12,x13,y13,n-1); S_Gasket(x12,y12,x2,y2,x23,y23,n-1); S_Gasket(x13,y13,x23,y23,x3,y3,n-1); } else { triangle(x1,y1,x2,y2,x3,y3); } } //---------------int fm------------------------------------------------------------ void FormPaint() { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glBegin(GL_TRIANGLES); glColor3f(0.0f,0.0f,1.0f); glVertex3f(0.2f,0.7f,0.0f); glColor3f(0.0f,1.0f,0.0f); glVertex3f(0.5,-0.3f,0.0f); glColor3f(1.0f,0.0f,0.0f); glVertex3f(-0.5f,-0.3f,0.0f); glEnd(); S_Gasket(0,0.5,-0.5,-0.5,0.5,-0.5,N); SwapBuffers(hdc); } void OnTimer() { FormPaint(); } void OnTest() { FormPaint(); } void main() { int i,j; int mi,mi1; ClearVclControls(); if((GuiMode==0)||(GuiMode==1)) { pfm=GetGuiWin(GuiMode); } else pfm=CreateComponentEx(0,"form","caption","OpenGL","Width",660,"height",370,"BorderIcons","[biSystemMenu]","position","poMainFormCenter","formstyle","fsstayontop","OnDestroy",FormDestroy,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); CreateComponentEx(pfm,"SpeedButton","caption","test","left",80,"top",5,"width",60,"height",20,"OnClick",OnTest,0); SetProperty(pfm,"visible",1);//// formcreate(); FormPaint(0); }" /> 
  <Command cmdname="调幅-正弦波" cmdType="P" cmd="[P]#include <windows.h> // Header File For Windows #include <stdio.h> // Header File For Standard Input/Output #include <gl\gl.h> // Header File For The OpenGL32 Library #include <gl\glu.h> // Header File For The GLu32 Library #include <gl\glaux.h> // Header File For The Glaux Library #include"libtcc1.c" #include"math.h" #define bool unsigned char HDC hDC=NULL; // Private GDI Device Context HGLRC hRC=NULL; // Permanent Rendering Context HWND hWnd=NULL; // Holds Our Window Handle HINSTANCE hInstance; // Holds The Instance Of The Application bool keys[256]; // Array Used For The Keyboard Routine bool active=TRUE; // Window Active Flag Set To TRUE By Default bool fullscreen=TRUE; // Fullscreen Flag Set To Fullscreen Mode By Default GLuint base; bool twinkle; // Twinkling Stars bool tp; // 'T' Key Pressed? bool closing=0; #define num 360 // Number Of Stars To Draw GLfloat cnt1=0.0f; // 1st Counter Used To Move Text & For Coloring GLfloat cnt2=0.0f; // 2nd Counter Used To Move Text & For Coloring typedef struct aaaa // Create A Structure For Star { int r, g, b; // Stars Color GLfloat dist, // Stars Distance From Center angle; // Stars Current Angle } stars; stars star[num]; // Need To Keep Track Of 'num' Stars GLfloat zoom=-15.0f; // Distance Away From Stars GLfloat tilt=90.0f; // Tilt The View GLfloat spin; // Spin Stars GLuint loop; // General Loop Variable GLuint texture[1]; // Storage For One textures LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); // Declaration For WndProc HGLRC hglrc; HDC hdc; int img; int pnl; int GuiMode=2,pfm; void formcreate() { hdc=GetDC(GetFormHandle(pfm)); //hdc=(HANDLE)GetProperty(pnl,"dc",0,0,0); int nPixelFormat; static PIXELFORMATDESCRIPTOR pfd= { sizeof(PIXELFORMATDESCRIPTOR), 1, PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER, PFD_TYPE_RGBA, 24, 0,0,0,0,0, 0,0, 0,0,0,0,0, 32, 0, 0, PFD_MAIN_PLANE, 0, 0,0,0 }; nPixelFormat=ChoosePixelFormat(hdc,&pfd); SetPixelFormat(hdc,nPixelFormat,&pfd); hglrc=wglCreateContext(hdc); wglMakeCurrent(hdc,hglrc); } //--------------------------------------------------------------------------- GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } void FormDestroy() { closing=1; Wait(1); wglMakeCurrent(NULL,NULL); wglDeleteContext(hglrc); DeleteObject(hdc); printf("destroy"); } void OnClose() { KillFont(); closing=1; Wait(1); if((GuiMode==0)||(GuiMode==1)) { ClearVclControls(); HideVclWin(200); } else { CloseForm(pfm); } } GLvoid glPrint(const char *fmt, ...) // Custom GL "Print" Routine { char text[256]; // Holds Our String va_list ap; // Pointer To List Of Arguments if (fmt == NULL) // If There's No Text return; // Do Nothing va_start(ap, fmt); // Parses The String For Variables vsprintf(text, fmt, ap); // And Converts Symbols To Actual Numbers va_end(ap); // Results Are Stored In Text glPushAttrib(GL_LIST_BIT); // Pushes The Display List Bits glListBase(base - 32); // Sets The Base Character to 32 glCallLists(strlen(text), GL_UNSIGNED_BYTE, text); // Draws The Display List Text glPopAttrib(); // Pops The Display List Bits } AUX_RGBImageRec *LoadBMP(char *Filename) // Loads A Bitmap Image { FILE *File=NULL; // File Handle if (!Filename) // Make Sure A Filename Was Given { return NULL; // If Not Return NULL } File=fopen(Filename,"r"); // Check To See If The File Exists if (File) // Does The File Exist? { fclose(File); // Close The Handle return auxDIBImageLoad(Filename); // Load The Bitmap And Return A Pointer } return NULL; // If Load Failed Return NULL } int LoadGLTextures() // Load Bitmaps And Convert To Textures { int Status=FALSE; // Status Indicator AUX_RGBImageRec *TextureImage[1]; // Create Storage Space For The Texture memset(TextureImage,0,sizeof(void *)*1); // Set The Pointer To NULL // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit if (TextureImage[0]=LoadBMP("dat/star.bmp")) { Status=TRUE; // Set The Status To TRUE glGenTextures(1, &texture[0]); // Create One Texture // Create Linear Filtered Texture glBindTexture(GL_TEXTURE_2D, texture[0]); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data); } if (TextureImage[0]) // If Texture Exists { if (TextureImage[0]->data) // If Texture Image Exists { free(TextureImage[0]->data); // Free The Texture Image Memory } free(TextureImage[0]); // Free The Image Structure } return Status; // Return The Status } GLvoid BuildFont(GLvoid) // Build Our Bitmap Font { HFONT font; // Windows Font ID HFONT oldfont; // Used For Good House Keeping base = glGenLists(96); // Storage For 96 Characters font = CreateFont( -16, // Height Of Font 0, // Width Of Font 0, // Angle Of Escapement 0, // Orientation Angle FW_BOLD, // Font Weight FALSE, // Italic FALSE, // Underline FALSE, // Strikeout ANSI_CHARSET, // Character Set Identifier OUT_TT_PRECIS, // Output Precision CLIP_DEFAULT_PRECIS, // Clipping Precision ANTIALIASED_QUALITY, // Output Quality FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch "Courier New"); // Font Name printf("font:%x",font); oldfont = (HFONT)SelectObject(hdc, font); // Selects The Font We Want wglUseFontBitmaps(hdc, 32, 96, base); // Builds 96 Characters Starting At Character 32 SelectObject(hdc, oldfont); // Selects The Font We Want DeleteObject(font); // Delete The Font } GLvoid ReSizeGLScene(GLsizei width, GLsizei height) // Resize And Initialize The GL Window { if (height==0) // Prevent A Divide By Zero By { height=1; // Making Height Equal One } glViewport(0,0,width,height); // Reset The Current Viewport glMatrixMode(GL_PROJECTION); // Select The Projection Matrix glLoadIdentity(); // Reset The Projection Matrix // Calculate The Aspect Ratio Of The Window gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f); glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix glLoadIdentity(); // Reset The Modelview Matrix } int InitGL(GLvoid) // All Setup For OpenGL Goes Here { if (!LoadGLTextures()) // Jump To Texture Loading Routine { printf("LoadGLTextures error!"); return FALSE; // If Texture Didn't Load Return FALSE } glEnable(GL_TEXTURE_2D); // Enable Texture Mapping glShadeModel(GL_SMOOTH); // Enable Smooth Shading glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Black Background glClearDepth(1.0f); // Depth Buffer Setup glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Really Nice Perspective Calculations glBlendFunc(GL_SRC_ALPHA,GL_ONE); // Set The Blending Function For Translucency glEnable(GL_BLEND); for (loop=0; loop<num; loop++) { star[loop].angle=0.0f; star[loop].dist=( (loop*1.0)/num)*5.0f; star[loop].r=00;//rand()%256; star[loop].g=255;//rand()%256; star[loop].b=10;//rand()%256; } BuildFont(); return TRUE; // Initialization Went OK } unsigned int Start=0; int DrawGLScene(GLvoid) // Here's Where We Do All The Drawing { int i; if(closing) return 0; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear The Screen And The Depth Buffer glBindTexture(GL_TEXTURE_2D, texture[0]); // Select Our Texture Start+=1; Start%=720; glEnable(GL_LINE_SMOOTH); glDisable(GL_TEXTURE_2D); for(i=1; i<5; i++) { glLoadIdentity(); // glTranslatef(-12.5f,3.0f,-22.0f ); glLineWidth(1.2f*(5-i)); // 设置线宽为2.0f glColor4f(0.0f,1.0f,0.0f,0.10f*i); glBegin(GL_LINE_STRIP ); // 绘制当前的线段 for (loop=0; loop<num; loop++) // Loop Through All The Stars { // glVertex3f((loop+0)*0.3-22,5.0*sin(3.14*4.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14f*4*loop/num)+6,zoom*2); glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*sin(3.14*3.0*Start/360.0+3.14f*3*loop/num)+6,zoom*2); } glEnd(); glBegin(GL_LINE_STRIP ); // 绘制当前的线段 for (loop=0; loop<num; loop+=1) // Loop Through All The Stars { glVertex3f((loop+0)*0.2-22,5.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))-6,zoom*2); } glEnd(); glLoadIdentity(); // glTranslatef(-12.5f+5.0*sin(3.14*3.0*Start/360.0),3.0f,-22.0f ); glColor4f(1.0f,0.0f,1.0f,0.10f*i); glBegin(GL_LINE_STRIP ); // 绘制当前的线段 for (loop=0; loop<num; loop+=4) // Loop Through All The Stars { glVertex3f((loop+0)*0.2-22,2.0*sin(3.14f*6*loop/num)-18,zoom*2); } glEnd(); } glEnable(GL_TEXTURE_2D); glLoadIdentity(); // // Reset The View Before We Draw Each Star glTranslatef(-1.5f,0.0f,-6.0f); glColor4ub(0,150,0,255); for(i=0; i<5; i++) { glBegin(GL_QUADS); glTexCoord2f(0.0f, 0.0f); glVertex3f(-20.0f,-0.0f+i*1.0-2, 0.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 25.0f,-0.0f+i*1.0-2, 0.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 25.0f, 0.1f+i*1.0-2, 0.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-20.0f, 0.1f+i*1.0-2, 0.0f); glEnd(); } glLoadIdentity(); // // Reset The View Before We Draw Each Star glTranslatef(-2.5f,0.0f,-6.0f); glColor4ub(0,150,0,255); for(i=0; i<10; i++) { glBegin(GL_QUADS); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.5f+i*1.0,-10.0f, 0.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( -1.6f+i*1.0,-10.0f, 0.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( -1.6f+i*1.0, 10.1f, 0.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.5f+i*1.0, 10.1f, 0.0f); glEnd(); } //glDisable(GL_LINE_SMOOTH); glDisable(GL_TEXTURE_2D); gluOrtho2D(-20.0f,-20.0f,20.0f,20.0f); glLoadIdentity(); // Reset The Current Modelview Matrix glTranslatef(-1.5f+0.40*sin(3.14*3.0*Start/360.0),-1.6f,-4.0f); // Move One Unit Into The Screen glColor4f(0.0f ,1.0f ,0.0f,0.4f ); glBegin(GL_QUADS); glVertex3f(0.0f,0.0f, 0.0f); glVertex3f(0.2f,0.0f, 0.0f); glVertex3f(0.2f,4.0f,0.0f); glVertex3f(0.0f,4.0f,0.0f); glEnd(); glColor4f(0.0f ,1.0f ,0.0f,0.6f ); glRasterPos2f(0, 0); glPrint("COMMBOX V1.256 - SIN WAVE - %03d",Start); // Print GL Text To The Screen cnt1+=0.051f; // Increase The First Counter cnt2+=0.005f; SwapBuffers(hdc); return TRUE; // Everything Went OK } void OnTimer() { DrawGLScene(); } void OnTest() { DrawGLScene(); } void OnResize() { int x,y; x=GetProperty(pfm,"width",0,0); y=GetProperty(pfm,"height",0,0); ReSizeGLScene(x,y); } void main() { int i,j; int mi,mi1; //HideLeftTools(); ClearVclControls(); HideVclWin(-1); if((GuiMode==0)||(GuiMode==1)) pfm=GetGuiWin(GuiMode); else pfm=CreateComponentEx(0,"form","caption","调幅-正弦波","Width",600,"height",300,"BorderIcons","[biSystemMenu,biMaximize]","position","poMainFormCenter","formstyle","fsstayontop","OnClose",FormDestroy,"OnResize",OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] int btn=CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); CreateComponentEx(pfm,"SpeedButton","caption","test","left",80,"top",5,"width",60,"height",20,"OnClick",OnTest,0); //img=CreateComponentEx(pfm,"Image","left",10,"top",10,"width",200,"height",200,0); SetProperty(pfm,"visible",1);//// formcreate(); OnResize(); InitGL(); DrawGLScene(); int count=0; while(!closing) { DrawGLScene(); sleep(1); count++; if(count%5==4) { Wait(1); } } printf("exit"); }" /> 
  <Command cmdname="调幅正弦波(正向)" cmdType="P" cmd="[P]#include "windows.h" // Header File For Windows #include <stdio.h> // Header File For Standard Input/Output #include <gl\gl.h> // Header File For The OpenGL32 Library #include <gl\glu.h> // Header File For The GLu32 Library #include <gl\glaux.h> // Header File For The Glaux Library #include"libtcc1.c" #include"math.h" #define bool unsigned char HDC hDC=NULL; // Private GDI Device Context HGLRC hRC=NULL; // Permanent Rendering Context HWND hWnd=NULL; // Holds Our Window Handle HINSTANCE hInstance; // Holds The Instance Of The Application int starttime; unsigned int framecount=0; bool keys[256]; // Array Used For The Keyboard Routine bool active=TRUE; // Window Active Flag Set To TRUE By Default bool fullscreen=TRUE; // Fullscreen Flag Set To Fullscreen Mode By Default GLuint base; bool twinkle; // Twinkling Stars bool tp; // 'T' Key Pressed? bool closing=0; #define num 360 // Number Of Stars To Draw GLfloat cnt1=0.0f; // 1st Counter Used To Move Text & For Coloring GLfloat cnt2=0.0f; // 2nd Counter Used To Move Text & For Coloring int mx=0,my=0; int mdx=-1,mdy=-1; int mux=-1,muy=-1; int md=0; GLfloat zoom=-15.0f; // Distance Away From Stars GLfloat tilt=90.0f; // Tilt The View GLfloat spin; // Spin Stars GLuint loop; // General Loop Variable GLuint texture[1]; // Storage For One textures HGLRC hglrc; HDC hdc; int img; int pnl; int GuiMode=2,pfm; typedef struct { float x; float y; float z; } POINT3D; void SwapFolat(float *a,float *b) { float tmp=*a; *a=*b; *b=tmp; } void formcreate() { hdc=GetDC(GetFormHandle(pfm)); //hdc=(HANDLE)GetProperty(pnl,"dc",0,0,0); int nPixelFormat; static PIXELFORMATDESCRIPTOR pfd= { sizeof(PIXELFORMATDESCRIPTOR), 1, PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER, PFD_TYPE_RGBA, 24, 0,0,0,0,0, 0,0, 0,0,0,0,0, 32, 0, 0, PFD_MAIN_PLANE, 0, 0,0,0 }; nPixelFormat=ChoosePixelFormat(hdc,&pfd); SetPixelFormat(hdc,nPixelFormat,&pfd); hglrc=wglCreateContext(hdc); wglMakeCurrent(hdc,hglrc); } //--------------------------------------------------------------------------- GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } void FormDestroy() { closing=1; Wait(1); wglMakeCurrent(NULL,NULL); wglDeleteContext(hglrc); DeleteObject(hdc); printf("destroy"); } void OnClose() { KillFont(); closing=1; Wait(1); if((GuiMode==0)||(GuiMode==1)) { ClearVclControls(); HideVclWin(200); } else { CloseForm(pfm); } } GLvoid glPrint(const char *fmt, ...) // Custom GL "Print" Routine { char text[256]; // Holds Our String va_list ap; // Pointer To List Of Arguments if (fmt == NULL) // If There's No Text return; // Do Nothing va_start(ap, fmt); // Parses The String For Variables vsprintf(text, fmt, ap); // And Converts Symbols To Actual Numbers va_end(ap); // Results Are Stored In Text glPushAttrib(GL_LIST_BIT); // Pushes The Display List Bits glListBase(base - 32); // Sets The Base Character to 32 glCallLists(strlen(text), GL_UNSIGNED_BYTE, text); // Draws The Display List Text glPopAttrib(); // Pops The Display List Bits } AUX_RGBImageRec *LoadBMP(char *Filename) // Loads A Bitmap Image { FILE *File=NULL; // File Handle if (!Filename) // Make Sure A Filename Was Given { return NULL; // If Not Return NULL } File=fopen(Filename,"r"); // Check To See If The File Exists if (File) // Does The File Exist? { fclose(File); // Close The Handle return auxDIBImageLoad(Filename); // Load The Bitmap And Return A Pointer } return NULL; // If Load Failed Return NULL } int LoadGLTextures() // Load Bitmaps And Convert To Textures { int Status=FALSE; // Status Indicator AUX_RGBImageRec *TextureImage[1]; // Create Storage Space For The Texture memset(TextureImage,0,sizeof(void *)*1); // Set The Pointer To NULL // Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit if (TextureImage[0]=LoadBMP("dat/mf.bmp")) { Status=TRUE; // Set The Status To TRUE glGenTextures(1, &texture[0]); // Create One Texture // Create Linear Filtered Texture glBindTexture(GL_TEXTURE_2D, texture[0]); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data); } if (TextureImage[0]) // If Texture Exists { if (TextureImage[0]->data) // If Texture Image Exists { free(TextureImage[0]->data); // Free The Texture Image Memory } free(TextureImage[0]); // Free The Image Structure } return Status; // Return The Status } GLvoid BuildFont(GLvoid) // Build Our Bitmap Font { HFONT font; // Windows Font ID HFONT oldfont; // Used For Good House Keeping base = glGenLists(96); // Storage For 96 Characters font = CreateFont( -16, // Height Of Font 0, // Width Of Font 0, // Angle Of Escapement 0, // Orientation Angle FW_BOLD, // Font Weight TRUE, // Italic FALSE, // Underline FALSE, // Strikeout ANSI_CHARSET, // Character Set Identifier OUT_TT_PRECIS, // Output Precision CLIP_DEFAULT_PRECIS, // Clipping Precision ANTIALIASED_QUALITY, // Output Quality FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch //"Courier New"); // Font Name "Bodoni MT Black"); printf("font:%x",font); oldfont = (HFONT)SelectObject(hdc, font); // Selects The Font We Want wglUseFontBitmaps(hdc, 32, 96, base); // Builds 96 Characters Starting At Character 32 SelectObject(hdc, oldfont); // Selects The Font We Want DeleteObject(font); // Delete The Font } GLvoid ReSizeGLScene1(GLsizei width, GLsizei height) // Resize And Initialize The GL Window { if (height==0) // Prevent A Divide By Zero By { height=1; // Making Height Equal One } glViewport(0,0,width,height); // Reset The Current Viewport glMatrixMode(GL_PROJECTION); // Select The Projection Matrix glLoadIdentity(); // Reset The Projection Matrix // Calculate The Aspect Ratio Of The Window gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f); glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix glLoadIdentity(); // Reset The Modelview Matrix } GLvoid ReSizeGLScene(GLsizei width, GLsizei height) // Resize And Initialize The GL Window { char s[100]; if (height==0) // Prevent A Divide By Zero By { height=1; // Making Height Equal One } glViewport(0, 0, (GLsizei)width, (GLsizei)height); glMatrixMode(GL_PROJECTION); glLoadIdentity(); if (width/2 <= height) { glOrtho(-20.5, 20.5, -20.5 * (GLfloat)height*1.0/(GLfloat)width, 20.5 * (GLfloat)height*1.0/(GLfloat)width, -20.0, 20.0); sprintf(s,"%d,%d:%f,%f,%f,%f",width,height,-10.5, 10.5, -10.5 * (GLfloat)height*1.0/(GLfloat)width, 10.5 * (GLfloat)height*1.0/(GLfloat)width); } else { glOrtho(-10.5*(GLfloat)width/(GLfloat)height, 10.5*(GLfloat)width/(GLfloat)height, -10.5, 10.5, -20.0, 20.0); sprintf(s,"%d,%d:%f,%f,%f,%f",width,height,-10.5*(GLfloat)width/(GLfloat)height, 10.5*(GLfloat)width/(GLfloat)height, -10.5, 10.5); } SetProperty(pfm,"caption",s); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glDrawBuffer(GL_BACK); // added code // Reset The Modelview Matrix } POINT3D pot3d; POINT3D ScreenToGL(int x,int y) { glMatrixMode(GL_MODELVIEW); glPushMatrix(); GLint viewport[4]; GLdouble modelview[16]; GLdouble projection[16]; GLfloat winX, winY, winZ; GLdouble posX, posY, posZ; glGetDoublev( GL_MODELVIEW_MATRIX, modelview ); glGetDoublev( GL_PROJECTION_MATRIX, projection ); glGetIntegerv( GL_VIEWPORT, viewport ); winX = x; winY = viewport[3] - y; glReadPixels( x, (winY), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &winZ ); gluUnProject( winX, winY, winZ, modelview, projection, viewport, &posX, &posY, &posZ); pot3d.x = (float)posX; pot3d.y = (float)posY; pot3d.z = (float)posZ; return pot3d; } int InitGL(GLvoid) // All Setup For OpenGL Goes Here { if (!LoadGLTextures()) // Jump To Texture Loading Routine { printf("LoadGLTextures error!"); return FALSE; // If Texture Didn't Load Return FALSE } glEnable(GL_TEXTURE_2D); // Enable Texture Mapping glShadeModel(GL_SMOOTH); // Enable Smooth Shading glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Black Background glClearDepth(1.0f); // Depth Buffer Setup glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Really Nice Perspective Calculations glBlendFunc(GL_SRC_ALPHA,GL_ONE); // Set The Blending Function For Translucency glEnable(GL_BLEND); BuildFont(); return TRUE; // Initialization Went OK } GLvoid glDrawCube() // 绘制立方体 { glBegin(GL_QUADS); // 前面 glNormal3f( 0.0f, 0.0f, 1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); // 后面 glNormal3f( 0.0f, 0.0f,-1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); // 上面 glNormal3f( 0.0f, 1.0f, 0.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, 1.0f, 1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, 1.0f, 1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); // 下面 glNormal3f( 0.0f,-1.0f, 0.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, -1.0f, -1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); // 右面 glNormal3f( 1.0f, 0.0f, 0.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); // 左面 glNormal3f(-1.0f, 0.0f, 0.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); glEnd(); } unsigned int Start=0; int DrawGLScene(GLvoid) // Here's Where We Do All The Drawing { int i,j; char s[40]; if(closing) return 0; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear The Screen And The Depth Buffer glBindTexture(GL_TEXTURE_2D, texture[0]); // Select Our Texture Start+=1; Start%=720; glEnable(GL_LINE_SMOOTH); glDisable(GL_TEXTURE_2D); for(i=1; i<5; i++) { glLoadIdentity(); // glTranslatef(-12.5f,3.0f,-2.0f ); glLineWidth(1.2f*(5-i)); glColor4f(0.0f,1.0f,0.0f,0.10f*i); glBegin(GL_LINE_STRIP ); for (loop=0; loop<num*2; loop++) //调制 sine wave glVertex3f((loop+0)*0.05-5,2.5*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))*(0.7-0.3*sin(3.14*12.0*Start/360.0+3.14f*6*loop/num))+1,0); glEnd(); glBegin(GL_LINE_STRIP ); for (loop=0; loop<num; loop+=1) //非调制 sine wave glVertex3f((loop+0)*0.1-5,2.0*sin(3.14*3.0*Start/360.0+3.141*4.0*((loop+0)*12.0/num))-5,0); glEnd(); glLoadIdentity(); glTranslatef(-12.5f+1.4*sin(3.14*3.0*Start/360.0),3.0f,0.0f ); glColor4f(0.0f,1.0f,0.0f,0.10f*i); glBegin(GL_LINE_STRIP ); for (loop=0; loop<num; loop+=6)//水平sine wave0 glVertex3f((loop+0)*0.1-5,1.0*sin(3.14f*6*loop/num)-10 ,0); glEnd(); glBegin(GL_LINE_STRIP ); //水平sine wave1 for (loop=0; loop<num; loop+=6) glVertex3f((loop+0)*0.1-5,1.0*sin(3.14f*6*loop/num)-9.7 ,0); glEnd(); } glDisable(GL_TEXTURE_2D); for(j=0; j<3; j++) //draw grid { glLoadIdentity(); // // Reset The View Before We Draw Each Star glTranslatef(-1.5f,0.0f,-1.0f); glLineWidth(1.2f*(3-j)); // 设置线宽为2.0f glColor4f(0.0f,1.0f,0.0f,0.20f*j); for(i=0; i<10; i++) { glBegin(GL_LINES); glVertex3f(-130.0f,-0.0f+i*4.0-19, 0.0f); glVertex3f( 135.0f,-0.0f+i*4.0-19, 0.0f); glEnd(); } glLoadIdentity(); // // Reset The View Before We Draw Each Star glTranslatef(-2.5f,0.0f,0.0f); for(i=0; i<12; i++) { glBegin(GL_LINES); glVertex3f( -19.6f+i*4.0,-110.0f, 0.0f); glVertex3f( -19.6f+i*4.0, 110.1f, 0.0f); glEnd(); } } glEnable(GL_TEXTURE_2D); //glDisable(GL_BLEND); glColor4f(0.3f,0.3f,1.0f,0.6f); glLoadIdentity(); // // Reset The View Before We Draw Each Star glTranslatef(-18.0f, 1.0f,0.0f); glScalef(2,2,2); glRotatef(framecount*1,framecount*1,framecount*2,1.0f); glDrawCube(); // glEnable(GL_BLEND); glDisable(GL_TEXTURE_2D); glLoadIdentity(); // glLineWidth(1.0f); // 设置线宽为2.0f POINT3D p3=ScreenToGL(mx,my); POINT3D pd3=ScreenToGL(mdx,mdy); POINT3D pu3=ScreenToGL(mux,muy); glLoadIdentity(); glTranslatef(p3.x,p3.y,0.0f); if(md) glRotatef(framecount*3,0,0,1.0f); glColor4f(1.0f,0.0f,0.0f,0.6f); //fill mouse glBegin(GL_QUADS); glVertex3f(0.3f,-0.3f, -20.0f); glVertex3f(-0.3f,-0.3f, -20.0f); glVertex3f(-0.3f,0.3f,-20.0f); glVertex3f(0.3f,0.3f,-20.0f); glEnd(); glColor4f(1.0f,0.0f,0.0f,1.0f); //frame mouse glLineWidth(1.5f); glBegin(GL_LINE_LOOP); glVertex3f(-0.45f,-0.45f, 0.0f); glVertex3f(0.45f,-0.45f, 0.0f); glVertex3f(0.45f,0.45f,0.0f); glVertex3f(-0.45f,0.45f,0.0f); glEnd(); glLineWidth(1.0f); glBegin(GL_LINES); //mouse cross line glVertex3f(-1.9f,0, 0.0f); glVertex3f(1.9f,0, 0.0f); glVertex3f(0,-1.9f,0.0f); glVertex3f(0,1.9f,0.0f); glVertex3f(-1.9f,0, 0.0f); glVertex3f(0+1.9f,0, 0.0f); glVertex3f(0,-1.9f,0.0f); glVertex3f(0,1.9f,0.0f); glEnd(); glLoadIdentity(); if(mdx!=-1) { glColor4f(0.0f,1.0f,0.0f,0.3f); glBegin(GL_QUADS); glVertex3f(pu3.x,pu3.y, -10.0f); glVertex3f(pd3.x,pu3.y, -10.0f); glVertex3f(pd3.x,pd3.y, -10.0f); glVertex3f(pu3.x,pd3.y, -10.0f); glEnd(); glLineWidth(1.5f); glColor4f(1.0f,0.0f,0.0f,1.0f); if(pu3.x<pd3.x)SwapFolat(&(pu3.x),&(pd3.x)); if(pu3.y>pd3.y)SwapFolat(&pu3.y,&pd3.y); if((pu3.x-pd3.x<2.0f)||(pd3.y-pu3.y<2.0f)) { glBegin(GL_LINE_LOOP); glVertex3f(pu3.x,pu3.y, -10.0f); glVertex3f(pd3.x,pu3.y, -10.0f); glVertex3f(pd3.x,pd3.y, -10.0f); glVertex3f(pu3.x,pd3.y, -10.0f); glEnd(); } else { glBegin(GL_LINES); glVertex3f(pd3.x,pd3.y, -10.0f); glVertex3f(pd3.x+1,pd3.y, -10.0f); glVertex3f(pd3.x,pd3.y, -10.0f); glVertex3f(pd3.x,pd3.y-1, -10.0f); glVertex3f(pu3.x,pd3.y, -10.0f); glVertex3f(pu3.x-1,pd3.y, -10.0f); glVertex3f(pu3.x,pd3.y, -10.0f); glVertex3f(pu3.x,pd3.y-1, -10.0f); glVertex3f(pu3.x,pu3.y, -10.0f); glVertex3f(pu3.x-1,pu3.y, -10.0f); glVertex3f(pu3.x,pu3.y, -10.0f); glVertex3f(pu3.x,pu3.y+1, -10.0f); glVertex3f(pd3.x,pu3.y, -10.0f); glVertex3f(pd3.x+1,pu3.y, -10.0f); glVertex3f(pd3.x,pu3.y, -10.0f); glVertex3f(pd3.x,pu3.y+1, -10.0f); glEnd(); } } glLineWidth(1.0f); glDisable(GL_TEXTURE_2D); glLoadIdentity(); glColor4f(1.0f ,0.0f ,0.0f,1.0f ); glRasterPos2f(p3.x+0.53,p3.y+0.17); glPrint("%d,%d",mx,my); glColor4f(0.0f ,1.0f ,0.0f,0.8f ); GetTimeStr(s,20); glRasterPos2f(-17,-8); glPrint(s); GLUquadricObj *quadObj3; quadObj3 = gluNewQuadric(); //glPushMatrix(); glTranslatef(-15.0,-7.0,0.0); glColor4f(0.1f ,1.0f,0.1f ,1.0f ); gluQuadricDrawStyle(quadObj3, GLU_LINE);// gluDisk(quadObj3, 0.12,0.12,8.0,1.0); //gluDisk(quadObj3, 0.12,0.12,8.0,1.0); glScalef(1.0,0.8,1); glColor4f(0.0f ,1.0f ,0.0f,0.4f ); gluQuadricDrawStyle(quadObj3, GLU_FILL);// gluDisk(quadObj3,3.0,3.3,45.0,1.0); glColor4f(0.0f ,1.0f ,0.0f,0.9f ); gluQuadricDrawStyle(quadObj3, GLU_LINE);// gluDisk(quadObj3,3.0,3.3,45.0,1.0); gluQuadricDrawStyle(quadObj3,GLU_FILL);//GLU_LINE glColor4f(0.0f ,1.0f ,0.0f,0.3f ); gluDisk(quadObj3,0.0,3.0,45.0,1.0); gluDeleteQuadric(quadObj3); ////////////clock //////////////////////// glLoadIdentity(); glColor4f(0.0f ,1.0f,0.0f ,0.2f ); glTranslatef(-15,-7,0); glRotatef(-1.0*framecount,0,0,1); glScalef(2.0,2.0,1); glBegin(GL_POLYGON); glVertex3f(0,-0.4, -10.0f); glVertex3f(0.25,-0.3, -10.0f); glVertex3f(0,3.5, -10.0f); //glVertex3f(-0.25,-0.3, -10.0f); glEnd(); glColor4f(0.0f ,1.0f,0.0f ,0.3f ); glBegin(GL_POLYGON); glVertex3f(0,-0.4, -10.0f); //glVertex3f(0.25,-0.3, -10.0f); glVertex3f(0,3.5, -10.0f); glVertex3f(-0.25,-0.3, -10.0f); glEnd(); glColor4f(0.0f ,1.0f,0.0f ,0.8f ); glBegin(GL_LINE_LOOP); glVertex3f(0,-0.4, -10.0f); glVertex3f(0.25,-0.3, -10.0f); glVertex3f(0,3.5, -10.0f); glVertex3f(-0.25,-0.3, -10.0f); glEnd(); //----------------------------- glLoadIdentity(); glColor4f(0.0f ,1.0f ,0.0f,0.2f ); glTranslatef(-15,-7,0); glRotatef(-0.1*framecount,0,0,1); glScalef(0.9*2,0.8*2,1); glBegin(GL_POLYGON); glVertex3f(0,-0.4, -10.0f); glVertex3f(0.25,-0.3, -10.0f); glVertex3f(0,3.5, -10.0f); //glVertex3f(-0.25,-0.3, -10.0f); glEnd(); glColor4f(0.0f ,1.0f ,0.0f,0.3f ); glBegin(GL_POLYGON); glVertex3f(0,-0.4, -10.0f); //glVertex3f(0.25,-0.3, -10.0f); glVertex3f(0,3.5, -10.0f); glVertex3f(-0.25,-0.3, -10.0f); glEnd(); glColor4f(0.0f ,1.0f ,0.0f,0.8f ); glBegin(GL_LINE_LOOP); glVertex3f(0,-0.4, -10.0f); glVertex3f(0.25,-0.3, -10.0f); glVertex3f(0,3.5, -10.0f); glVertex3f(-0.25,-0.3, -10.0f); glEnd(); //-------------- glLoadIdentity(); glColor4f(0.0f ,1.0f ,0.0f,0.2f ); glTranslatef(-15,-7,0); glRotatef(-0.01*framecount,0,0,1); glScalef(0.8*2,0.7*2,1); glBegin(GL_POLYGON); glVertex3f(0,-0.4, -10.0f); glVertex3f(0.25,-0.3, -10.0f); glVertex3f(0,3.5, -10.0f); //glVertex3f(-0.25,-0.3, -10.0f); glEnd(); glColor4f(0.0f ,1.0f ,0.0f,0.3f ); glBegin(GL_POLYGON); glVertex3f(0,-0.4, -10.0f); //glVertex3f(0.25,-0.3, -10.0f); glVertex3f(0,3.5, -10.0f); glVertex3f(-0.25,-0.3, -10.0f); glEnd(); glColor4f(0.0f ,1.0f ,0.0f,0.8f ); glBegin(GL_LINE_LOOP); glVertex3f(0,-0.4, -10.0f); glVertex3f(0.25,-0.3, -10.0f); glVertex3f(0,3.5, -10.0f); glVertex3f(-0.25,-0.3, -10.0f); glEnd(); ///////////////////////////////////////////////////// glLoadIdentity(); // Reset The Current Modelview Matrix glTranslatef(-1.5f+1.40*sin(3.14*3.0*Start/360.0),-1.6f,-4.0f); // Move One Unit Into The Screen glColor4f(0.0f ,1.0f ,0.0f,0.3f ); for(i=0; i<8; i++) { glBegin(GL_QUADS); glVertex3f(-6.0+0.0f+i*2,-7.0f, 0.0f); glVertex3f(-6.0+1.2f+i*2,-7.0f, 0.0f); glVertex3f(-6.0+1.2f+i*2,8.5f+2*sin(i)*sin(3.14*3.0*Start/360.0),0.0f); glVertex3f(-6.0+0.0f+i*2,8.5f+2*sin(i)*sin(3.14*3.0*Start/360.0),0.0f); glEnd(); } glColor4f(0.0f ,1.0f ,0.0f,0.6f ); glRasterPos2f(-9, -8); framecount++; printf("starttime:%d",starttime); int sec=(GetTickCount()-starttime)/1000; if(sec==0)sec=1; glPrint("COMMBOX V1.256 - SIN WAVE - %03d,%d,%d,fps:%d",Start,mx,my,framecount/sec); // Print GL Text To The Screen cnt1+=0.051f; // Increase The First Counter cnt2+=0.005f; SwapBuffers(hdc); return TRUE; // Everything Went OK } void OnTimer() { DrawGLScene(); } void OnTest() { DrawGLScene(); } void OnResize() { int x,y; x=GetProperty(pfm,"width",0,0); y=GetProperty(pfm,"height",0,0); ReSizeGLScene(x,y); } void OnMouseMove(int id,int state,int x,int y) { mx=x; my=y+30; if(md) { mux=mx; muy=my; } } void OnMouseDown(int id,int btn,int state,int x,int y) { mdx=x; mdy=y+30; mux=x; muy=y+30; md=1; } void OnMouseUp(int id,int btn,int state,int x,int y) { mux=x; muy=y+30; md=0; } void main() { int i,j; int mi,mi1; //HideLeftTools(); ClearVclControls(); HideVclWin(-1); if((GuiMode==0)||(GuiMode==1)) pfm=GetGuiWin(GuiMode); else pfm=CreateComponentEx(0,"form","caption","调幅-正弦波","Width",900,"height",400,"BorderIcons","[biSystemMenu,biMaximize]","position","poMainFormCenter","formstyle","fsstayontop","cursor",-1,"OnClose",FormDestroy,"OnResize",OnResize,"OnMouseDown",OnMouseDown,"OnMouseUp",OnMouseUp,"OnMouseMove",OnMouseMove,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] int btn=CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); CreateComponentEx(pfm,"SpeedButton","caption","test","left",80,"top",5,"width",60,"height",20,"OnClick",OnTest,0); //img=CreateComponentEx(pfm,"Image","left",10,"top",10,"width",200,"height",200,0); formcreate(); OnResize(); InitGL(); DrawGLScene(); starttime=GetTickCount(); SetProperty(pfm,"visible",1);//// int count=0; while(!closing) { DrawGLScene(); sleep(1); count++; if(count%2==1) { Wait(1); } } printf("exit"); }" /> 
  <Command cmdname="GDI绘图-在窗体下方显示" cmdType="P" cmd="[P]#include "windows.h" #include"libtcc1.c" #include"math.h" int p; int img; HANDLE dc; int start=0; void OnTimer() { double y; int yy,i; char s[100]; RECT rect= {0,0,340,300}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0); FillRect(dc,&rect,brush); start++;start++; start%=80; HPEN pen=CreatePen(PS_SOLID,1,0x104010); SelectObject(dc,pen); MoveToEx(dc,5, 70,0); LineTo(dc,330, 70); MoveToEx(dc,5, 71,0); LineTo(dc,330, 71); for(i=0; i<9; i++) { MoveToEx(dc,20, 10-2,0); LineTo(dc,20-3+i, 10+12); } for(i=0; i<9; i++) { MoveToEx(dc,330, 70,0); LineTo(dc,330-12, 70-3+i); } MoveToEx(dc,20, 10,0); LineTo(dc,20, 140); MoveToEx(dc,21, 10,0); LineTo(dc,21, 140); DeleteObject(pen); HPEN pen=CreatePen(PS_SOLID,1,0xff00); SelectObject(dc,pen); for(i=20; i<320; i++) // { y=sin(3.14*2*(i+start)/80) ; yy=y*20; //dc=GetProperty(img,"dc",0,0,0); if(i==20) MoveToEx(dc,i,yy+70,0); else LineTo(dc,i,yy+70); } sprintf(s,"%03d",start); SetBkColor(dc,0); SetTextColor(dc,0xff00); TextOutA(dc,110,10,s,3); TextOutA(dc,13,71,"0",1); TextOutA(dc,11,10,"y",1); TextOutA(dc,320,75,"x",1); Invalidate(img); DeleteObject(pen); DeleteObject(brush); } void OnClose() { HideVclWin(); CloseVclWin(); } void main() { HideLeftTools(); ClearVclControls(); ShowVclWin(200); p=GetGuiWin(0); CreateComponentEx(p,"timer","interval",20,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 CreateComponentEx(p,"button","caption","关闭","left",10,"top",5,"width",140,"height",20,"OnClick",OnClose,0); img=CreateComponentEx(p,"Image","left",10,"top",40,"width",340,"height",150, 0); }" /> 
  <Command cmdname="GDI绘图-独立窗口" cmdType="P" cmd="[P]#include "windows.h" #include"libtcc1.c" #include"math.h" int p; int img; HANDLE dc; int start=0; void OnTimer() { double y; int yy,i; char s[100]; RECT rect= {0,0,340,300}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0); FillRect(dc,&rect,brush); start++;start++; start%=80; HPEN pen=CreatePen(PS_SOLID,1,0x104010); SelectObject(dc,pen); MoveToEx(dc,5, 70,0); LineTo(dc,330, 70); MoveToEx(dc,5, 71,0); LineTo(dc,330, 71); for(i=0; i<9; i++) { MoveToEx(dc,20, 10-2,0); LineTo(dc,20-3+i, 10+12); } for(i=0; i<9; i++) { MoveToEx(dc,330, 70,0); LineTo(dc,330-12, 70-3+i); } MoveToEx(dc,20, 10,0); LineTo(dc,20, 140); MoveToEx(dc,21, 10,0); LineTo(dc,21, 140); DeleteObject(pen); HPEN pen=CreatePen(PS_SOLID,1,0xff00); SelectObject(dc,pen); for(i=20; i<320; i++) // { y=sin(3.14*2*(i+start)/80) ; yy=y*20; //dc=GetProperty(img,"dc",0,0,0); if(i==20) MoveToEx(dc,i,yy+70,0); else LineTo(dc,i,yy+70); } sprintf(s,"%03d",start); SetBkColor(dc,0); SetTextColor(dc,0xff00); TextOutA(dc,110,10,s,3); TextOutA(dc,13,71,"0",1); TextOutA(dc,11,10,"y",1); TextOutA(dc,320,75,"x",1); Invalidate(img); DeleteObject(pen); DeleteObject(brush); } void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; if(dstPort!=80) return; if(strstr(buf,"passw")!=0) { char *p=strstr(buf,"passw"); printf("find:%s",p); } else { return; } } void OnClose() { CloseForm(p); } void OnMouseMove(int obj,int state,int x,int y) { char s[32]; sprintf(s,"GDI绘图:%d,%d",x,y); SetProperty(p,"caption",s,strlen(s)); } void main() { //HideLeftTools(); ClearVclControls(); HideVclWin(200); //p=GetGuiWin(0); p=CreateComponentEx(0,"form","caption","GDI绘图","Width",380,"height",250,"position","poMainFormCenter","BorderIcons","[biSystemMenu]","formstyle","fsstayontop","OnMouseMove",OnMouseMove,"OnMouseMove",OnMouseMove,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] CreateComponentEx(p,"timer","interval",20,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 CreateComponentEx(p,"button","caption","关闭","left",10,"top",5,"width",140,"height",20,"OnClick",OnClose,0); img=CreateComponentEx(p,"Image","left",10,"top",40,"width",340,"height",150,"OnMouseMove",OnMouseMove,0); SetProperty(p,"visible",1); }" /> 
  <Command cmdname="方波-傅立叶变换" cmdType="P" cmd="[P]#include "windows.h" #include"libtcc1.c" #include"math.h" int p; int img; HANDLE dc; int start=0; int level=1; char *title="方波-傅立叶级数"; void OnTimer() { double y; int yy,i,j; char s[100]; RECT rect= {0,0,340,300}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0); FillRect(dc,&rect,brush); start++; start++; start%=80; HPEN pen=CreatePen(PS_SOLID,1,0x106010); SelectObject(dc,pen); MoveToEx(dc,5, 70,0); LineTo(dc,330, 70); MoveToEx(dc,5, 71,0); LineTo(dc,330, 71); for(i=0; i<9; i++) { MoveToEx(dc,20, 10-2,0); LineTo(dc,20-3+i, 10+12); } for(i=0; i<9; i++) { MoveToEx(dc,330, 70,0); LineTo(dc,330-12, 70-3+i); } MoveToEx(dc,20, 10,0); LineTo(dc,20, 140); MoveToEx(dc,21, 10,0); LineTo(dc,21, 140); DeleteObject(pen); HPEN pen=CreatePen(PS_SOLID,1,0x00af); SelectObject(dc,pen); #define PI 3.1415929 double fby; double T=160.0; double w=2*PI/T; double h=25; for(i=20; i<320; i++) // { fby=0; for(j=1; j<level*2-2; j+=2) fby+=sin(j*w*i)/j; fby*=4.0*h/PI; yy=fby; if(i==20) MoveToEx(dc,i,yy+70,0); else LineTo(dc,i,yy+70); } for(i=20; i<320; i++) // { j=level*2-1; fby=sin(j*w*i)/j; fby*=4.0*h/PI; yy=fby; if(i==20) MoveToEx(dc,i,yy+70,0); else LineTo(dc,i,yy+70); } DeleteObject(pen); pen=CreatePen(PS_SOLID,1,0xff00); SelectObject(dc,pen); for(i=20; i<320; i++) // { fby=0; for(j=1; j<level*2; j+=2) fby+=sin(j*w*i)/j; fby*=4.0*h/PI; yy=fby; if(i==20) MoveToEx(dc,i,yy+70,0); else LineTo(dc,i,yy+70); } for(i=20; i<320; i++) //波形加粗 { fby=0; for(j=1; j<level*2; j+=2) fby+=sin(j*w*i)/j; fby*=4.0*h/PI; yy=fby; if(i==20) MoveToEx(dc,i+1,yy+70,0); else LineTo(dc,i+1,yy+70); } sprintf(s,"%03d",start); SetBkColor(dc,0); SetTextColor(dc,0xff00); char *s="f(t)=(4h/PI)(sin(wt)+(1/3)sin(3wt)+(1/5)sin(5wt)+(1/7)sin(7wt)..."; TextOutA(dc,30,12,s,strlen(s)); TextOutA(dc,13,71,"0",1); TextOutA(dc,11,10,"y",1); TextOutA(dc,320,75,"x",1); Invalidate(img); DeleteObject(pen); DeleteObject(brush); char s1[50]; sprintf(s1,"%s,级数：%d",title,level); SetProperty(p,"caption",s1,strlen(s1)); } void formclose() { } void OnClose() { CloseForm(p); } void cbClick() { level++; OnTimer(); } void cbClick1() { if(level>0) level--; OnTimer(); } void OnMouseMove(int id,int state,int x,int y) { char s[20]; int i,j,yy,k; double fby ; double T=160.0; double w=2*PI/T; double h=25; OnTimer(); dc=(HANDLE)GetProperty(img,"dc",0,0,0); HPEN pen=CreatePen(PS_SOLID,1,0x00ff); SelectObject(dc,pen); for(k=0;k<3;k++) for(i=x-15; i<x+15; i++) // { fby=0; for(j=1; j<level*2; j+=2) fby+=sin(j*w*i)/j; fby*=4.0*h/PI; yy=fby; if(i==x-15) MoveToEx(dc,i+k,yy+70,0); else LineTo(dc,i+k,yy+70); } DeleteObject(pen); pen=CreatePen(PS_SOLID,1,0x80ff80); SelectObject(dc,pen); MoveToEx(dc,x,0,0); LineTo(dc,x,150); MoveToEx(dc,0,y,0); LineTo(dc,340,y); DeleteObject(pen); sprintf(s,"%d,%d",x,y); TextOutA(dc,x+1,y-13,s,strlen(s)); Invalidate(img); } void OnMouseDown(int id,int btn,int state,int x,int y) { char s[20]; OnTimer(); dc=(HANDLE)GetProperty(img,"dc",0,0,0); HPEN pen=CreatePen(PS_SOLID,1,0x8000ff); SelectObject(dc,pen); MoveToEx(dc,x,0,0); LineTo(dc,x,150); MoveToEx(dc,0,y,0); LineTo(dc,340,y); DeleteObject(pen); sprintf(s,"%d,%d",x,y); TextOutA(dc,x+1,y-13,s,strlen(s)); Invalidate(img); } void main() { HideLeftTools(); ClearVclControls(); HideVclWin(200); //p=GetGuiWin(0); p=CreateComponentEx(0,"form","caption",title,"Width",380,"height",250,"position","poMainFormCenter","BorderIcons","[biSystemMenu]","OnClose",formclose,"formstyle","fsstayontop",NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] //CreateComponentEx(p,"timer","interval",20,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 CreateComponentEx(p,"button","caption","关闭","left",10,"top",5,"width",140,"height",25,"OnClick",OnClose,0); CreateComponentEx(p,"button","caption","级数+1","left",160,"top",5,"width",80,"height",25,"OnClick",cbClick,0); CreateComponentEx(p,"button","caption","级数-1","left",250,"top",5,"width",80,"height",25,"OnClick",cbClick1,0); img=CreateComponentEx(p,"Image","left",10,"top",40,"width",340,"height",150,"OnMouseMove",OnMouseMove,"OnMouseDown",OnMouseDown,0); SetProperty(p,"visible",1); OnTimer(); }" /> 
  <Command cmdname="三角波-傅立叶变换" cmdType="P" cmd="[P]#include "windows.h" #include"libtcc1.c" #include"math.h" int p; int img; HANDLE dc; int start=0; int level=1; char *title="三角波-傅立叶级数"; void OnTimer() { double y; int yy,i,j; char s[100]; RECT rect= {0,0,340,300}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0); FillRect(dc,&rect,brush); start++; start++; start%=80; HPEN pen=CreatePen(PS_SOLID,1,0x106010); SelectObject(dc,pen); MoveToEx(dc,5, 70,0); LineTo(dc,330, 70); MoveToEx(dc,5, 71,0); LineTo(dc,330, 71); for(i=0; i<9; i++) { MoveToEx(dc,20, 10-2,0); LineTo(dc,20-3+i, 10+12); } for(i=0; i<9; i++) { MoveToEx(dc,330, 70,0); LineTo(dc,330-12, 70-3+i); } MoveToEx(dc,20, 10,0); LineTo(dc,20, 140); MoveToEx(dc,21, 10,0); LineTo(dc,21, 140); DeleteObject(pen); HPEN pen=CreatePen(PS_SOLID,1,0x00af); SelectObject(dc,pen); #define PI 3.1415929 double fby; double T=120.0; double w=2*PI/T; double h=45; for(j=1; j<level*2; j+=2) for(i=20; i<320; i++) // { fby=0; fby=sin(j*w*i)/(j*j); fby*=8.0*h/(PI*PI); yy=fby; if(i==20) MoveToEx(dc,i,yy+70,0); else LineTo(dc,i,yy+70); } DeleteObject(pen); pen=CreatePen(PS_SOLID,1,0xff00); SelectObject(dc,pen); for(i=20; i<320; i++) // { fby=0; for(j=1; j<level*2; j+=2) if(j%4==3) fby-=sin(j*w*i)/(j*j); else fby+=sin(j*w*i)/(j*j); fby*=8.0*h/(PI*PI); yy=fby; if(i==20) MoveToEx(dc,i,yy+70,0); else LineTo(dc,i,yy+70); } for(i=20; i<320; i++) //波形加粗 { fby=0; for(j=1; j<level*2; j+=2) if(j%4==3) fby-=sin(j*w*i)/(j*j); else fby+=sin(j*w*i)/(j*j); fby*=8.0*h/(PI*PI); yy=fby; if(i==20) MoveToEx(dc,i+1,yy+70,0); else LineTo(dc,i+1,yy+70); } sprintf(s,"%03d",start); SetBkColor(dc,0); SetTextColor(dc,0xff00); char *s="f(t)=(8h/(PI*PI))(sin(wt)-(1/(3*3))sin(3wt)+(1/(5*5))sin(5wt)-(1/(7*7))sin(7wt)..."; TextOutA(dc,30,12,s,strlen(s)); TextOutA(dc,13,71,"0",1); TextOutA(dc,11,10,"y",1); TextOutA(dc,320,75,"x",1); Invalidate(img); DeleteObject(pen); DeleteObject(brush); char s1[50]; sprintf(s1,"%s,级数：%d",title,level); SetProperty(p,"caption",s1,strlen(s1)); } void formclose() { } void OnClose() { CloseForm(p); } void cbClick() { level++; OnTimer(); } void cbClick1() { if(level>0) level--; OnTimer(); } void main() { HideLeftTools(); ClearVclControls(); HideVclWin(200); //p=GetGuiWin(0); p=CreateComponentEx(0,"form","caption",title,"Width",380,"height",250,"position","poMainFormCenter","BorderIcons","[biSystemMenu]","OnClose",formclose,"formstyle","fsstayontop",NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] //CreateComponentEx(p,"timer","interval",20,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 CreateComponentEx(p,"button","caption","关闭","left",10,"top",5,"width",140,"height",25,"OnClick",OnClose,0); CreateComponentEx(p,"button","caption","级数+1","left",160,"top",5,"width",80,"height",25,"OnClick",cbClick,0); CreateComponentEx(p,"button","caption","级数-1","left",250,"top",5,"width",80,"height",25,"OnClick",cbClick1,0); img=CreateComponentEx(p,"Image","left",10,"top",40,"width",340,"height",150, 0); SetProperty(p,"visible",1); OnTimer(); }" /> 
  <Command cmdname="GDI绘图-数据分析" cmdType="P" cmd="[P]#include "windows.h" #include"libtcc1.c" #include"math.h" int p; int img; HANDLE dc; int start=0; void OnTimer() { int i; char s[100]; RECT rect= {0,0,345,300}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0x00); FillRect(dc,&rect,brush); HPEN pen=CreatePen(PS_SOLID,1,0x104010); SelectObject(dc,pen); MoveToEx(dc,5, 90,0); LineTo(dc,330, 90); MoveToEx(dc,5, 91,0); LineTo(dc,330, 91); for(i=0; i<9; i++) { MoveToEx(dc,20, 10-2,0); LineTo(dc,20-3+i, 10+12); } for(i=0; i<9; i++) { MoveToEx(dc,330, 90,0); LineTo(dc,330-12, 90-3+i); } MoveToEx(dc,20, 10,0); LineTo(dc,20, 140); MoveToEx(dc,21, 10,0); LineTo(dc,21, 140); DeleteObject(pen); HPEN pen=CreatePen(PS_SOLID,1,0xff00); SelectObject(dc,pen); sprintf(s,"%03d",start); SetBkColor(dc,0); SetTextColor(dc,0xff00); TextOutA(dc,110,10,s,3); TextOutA(dc,13,91,"0",1); TextOutA(dc,11,10,"y",1); TextOutA(dc,320,95,"x",1); Invalidate(img); DeleteObject(pen); DeleteObject(brush); } void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { if(start==290) { start%=290; OnTimer(); } dc=(HANDLE)GetProperty(img,"dc",0,0,0); HPEN pen=CreatePen(PS_SOLID,1,0xff00); SelectObject(dc,pen); MoveToEx(dc,start+22,90-count%90,0); LineTo(dc,start+22,90); Invalidate(img); DeleteObject(pen); start++; } void OnClose() { HideVclWin(); CloseForm(p); } void main() { HideLeftTools(); ClearVclControls(); ShowVclWin(200); //p=GetGuiWin(0); p=CreateComponentEx(0,"form","caption","GDI绘图","Width",380,"height",250,"position","poMainFormCenter","BorderIcons","[biSystemMenu]", "formstyle","fsstayontop",NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] CreateComponentEx(p,"timer","interval",20,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 CreateComponentEx(p,"button","caption","关闭","left",10,"top",5,"width",140,"height",20,"OnClick",OnClose,0); img=CreateComponentEx(p,"Image","left",10,"top",40,"width",340,"height",150, 0); SetProperty(p,"visible",1); OnTimer(); }" /> 
  <Command cmdname="GDI绘图-动态数据分析" cmdType="P" cmd="[P]#include "windows.h" #include"libtcc1.c" #include"math.h" int p; int img; HANDLE dc; int start=0; void Draw() { int i; char s[100]; RECT rect= {0,0,345,300}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0x00); FillRect(dc,&rect,brush); HPEN pen=CreatePen(PS_SOLID,1,0x106010); SelectObject(dc,pen); MoveToEx(dc,5, 90,0); LineTo(dc,330, 90); MoveToEx(dc,5, 91,0); LineTo(dc,330, 91); for(i=0; i<9; i++) { MoveToEx(dc,20, 10-2,0); LineTo(dc,20-3+i, 10+12); } for(i=0; i<9; i++) { MoveToEx(dc,330, 90,0); LineTo(dc,330-12, 90-3+i); } MoveToEx(dc,20, 10,0); LineTo(dc,20, 140); MoveToEx(dc,21, 10,0); LineTo(dc,21, 140); DeleteObject(pen); HPEN pen=CreatePen(PS_SOLID,1,0xff00); SelectObject(dc,pen); sprintf(s,"%03d",start); SetBkColor(dc,0); SetTextColor(dc,0xff00); TextOutA(dc,110,10,s,3); TextOutA(dc,13,91,"0",1); TextOutA(dc,11,10,"y",1); TextOutA(dc,320,95,"x",1); Invalidate(img); DeleteObject(pen); DeleteObject(brush); } void formclose() { } void OnTimer() { if(start==290) { start%=290; Draw(); } dc=(HANDLE)GetProperty(img,"dc",0,0,0); HPEN pen=CreatePen(PS_SOLID,1,0xff00); SelectObject(dc,pen); int count=rand(70); count=count-count%8; MoveToEx(dc,start+22,20+70-count%70,0); LineTo(dc,start+22,90); start++; MoveToEx(dc,start+22,20+70-count%70,0); LineTo(dc,start+22,90); Invalidate(img); DeleteObject(pen); start++; } void OnClose() { HideVclWin(); CloseForm(p); } void main() { HideLeftTools(); ClearVclControls(); ShowVclWin(200); ShowOutputWin(-1); //p=GetGuiWin(0); p=CreateComponentEx(0,"form","caption","GDI绘图","Width",380,"height",250,"position","poMainFormCenter","BorderIcons","[biSystemMenu]","formstyle","fsstayontop",NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] CreateComponentEx(p,"timer","interval",10,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 CreateComponentEx(p,"button","caption","关闭","left",10,"top",5,"width",140,"height",20,"OnClick",OnClose,0); img=CreateComponentEx(p,"Image","left",10,"top",40,"width",340,"height",150, 0); SetProperty(p,"visible",1); Draw(); }" /> 
  <Command cmdname="GDI绘图-在增加的页面中显示" cmdType="P" cmd="[P]#include "windows.h" #include"libtcc1.c" #include"math.h" int p; int img; HANDLE dc; int start=0; void OnTimer() { double y; int yy,i; char s[100]; //return; RECT rect= {0,0,340,300}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0); FillRect(dc,&rect,brush); start++;start++; start%=80; HPEN pen=CreatePen(PS_SOLID,1,0x104010); SelectObject(dc,pen); MoveToEx(dc,5, 70,0); LineTo(dc,330, 70); MoveToEx(dc,5, 71,0); LineTo(dc,330, 71); for(i=0; i<9; i++) { MoveToEx(dc,20, 10-2,0); LineTo(dc,20-3+i, 10+12); } for(i=0; i<9; i++) { MoveToEx(dc,330, 70,0); LineTo(dc,330-12, 70-3+i); } MoveToEx(dc,20, 10,0); LineTo(dc,20, 140); MoveToEx(dc,21, 10,0); LineTo(dc,21, 140); DeleteObject(pen); HPEN pen=CreatePen(PS_SOLID,1,0xff00); SelectObject(dc,pen); for(i=20; i<320; i++) // { y=sin(3.14*2*(i+start)/80) ; yy=y*20; //dc=GetProperty(img,"dc",0,0,0); if(i==20) MoveToEx(dc,i,yy+70,0); else LineTo(dc,i,yy+70); } sprintf(s,"%03d",start); SetBkColor(dc,0); SetTextColor(dc,0xff00); TextOutA(dc,110,10,s,3); TextOutA(dc,13,71,"0",1); TextOutA(dc,11,10,"y",1); TextOutA(dc,320,75,"x",1); Invalidate(img); DeleteObject(pen); DeleteObject(brush); } void OnClose() { HideVclWin(); CloseVclWin(); } void main() { HideLeftTools(); ClearVclControls(); ShowVclWin(200); ShowOutputWin(-1); p=GetGuiWin(1);//// CreateComponentEx(p,"timer","interval",20,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 CreateComponentEx(p,"button","caption","关闭","left",10,"top",5,"width",140,"height",20,"OnClick",OnClose,0); img=CreateComponentEx(p,"Image","left",10,"top",40,"width",340,"height",150, 0); }" /> 
  <Command cmdname="GDI绘图-在增加的页面中显示-NoOutput" cmdType="P" cmd="[P]#include "windows.h" #include"libtcc1.c" #include"math.h" int p; int img; HANDLE dc; int start=0; void OnTimer() { double y; int yy,i; char s[100]; //return; RECT rect= {0,0,340,300}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0); FillRect(dc,&rect,brush); start++;start++; start%=80; HPEN pen=CreatePen(PS_SOLID,1,0x104010); SelectObject(dc,pen); MoveToEx(dc,5, 70,0); LineTo(dc,330, 70); MoveToEx(dc,5, 71,0); LineTo(dc,330, 71); for(i=0; i<9; i++) { MoveToEx(dc,20, 10-2,0); LineTo(dc,20-3+i, 10+12); } for(i=0; i<9; i++) { MoveToEx(dc,330, 70,0); LineTo(dc,330-12, 70-3+i); } MoveToEx(dc,20, 10,0); LineTo(dc,20, 140); MoveToEx(dc,21, 10,0); LineTo(dc,21, 140); DeleteObject(pen); HPEN pen=CreatePen(PS_SOLID,1,0xff00); SelectObject(dc,pen); for(i=20; i<320; i++) // { y=sin(3.14*2*(i+start)/80) ; yy=y*20; //dc=GetProperty(img,"dc",0,0,0); if(i==20) MoveToEx(dc,i,yy+70,0); else LineTo(dc,i,yy+70); } sprintf(s,"%03d",start); SetBkColor(dc,0); SetTextColor(dc,0xff00); TextOutA(dc,110,10,s,3); TextOutA(dc,13,71,"0",1); TextOutA(dc,11,10,"y",1); TextOutA(dc,320,75,"x",1); Invalidate(img); DeleteObject(pen); DeleteObject(brush); } void OnClose() { HideVclWin(); CloseVclWin(); } void main() { HideLeftTools(); ClearVclControls(); HideVclWin(); p=GetGuiWin(1);//// CreateComponentEx(p,"timer","interval",20,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 CreateComponentEx(p,"button","caption","关闭","left",10,"top",5,"width",140,"height",20,"OnClick",OnClose,0); img=CreateComponentEx(p,"Image","left",10,"top",40,"width",340,"height",150, 0); }" /> 
  <Command cmdname="OpenGL 汉字显示（ftgl_ttf、shx）" cmdType="P" cmd="[P]#include <windows.h> // Header File For Windows #include <stdio.h> // Header File For Standard Input/Output #include <gl\gl.h> // Header File For The OpenGL32 Library #include <gl\glu.h> // Header File For The GLu32 Library #include <gl\glaux.h> // Header File For The Glaux Library //#include"libtcc1.c" #include"math.h" #pragma comment(lib,"ftgl.def"); #pragma comment(lib,"lib\\shx.o"); #define bool unsigned char int closing=0; // Private GDI Device Context HGLRC hRC=NULL; // Permanent Rendering Context HWND hWnd=NULL; // Holds Our Window Handle HINSTANCE hInstance; // Holds The Instance Of The Application GLuint base; // Base Display List For The Font Set GLfloat cnt1; // 1st Counter Used To Move Text & For Coloring GLfloat cnt2; // 2nd Counter Used To Move Text & For Coloring bool keys[256]; // Array Used For The Keyboard Routine bool active=TRUE; // Window Active Flag Set To TRUE By Default bool fullscreen=TRUE; // Fullscreen Flag Set To Fullscreen Mode By Default HGLRC hglrc; HDC hdc; int img; int pnl; int GuiMode=2,pfm; int *ft; void formcreate() { hdc=GetDC(GetFormHandle(pfm)); //hdc=(HANDLE)GetProperty(pnl,"dc",0,0,0); int nPixelFormat; /* static PIXELFORMATDESCRIPTOR pfd= { sizeof(PIXELFORMATDESCRIPTOR), 1, PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER, PFD_TYPE_RGBA, 24, 0,0,0,0,0, 0,0, 0,0,0,0,0, 32, 0, 0, PFD_MAIN_PLANE, 0, 0,0,0 };*/ static PIXELFORMATDESCRIPTOR pfd= // pfd Tells Windows How We Want Things To Be { sizeof(PIXELFORMATDESCRIPTOR), // Size Of This Pixel Format Descriptor 1, // Version Number PFD_DRAW_TO_WINDOW | // Format Must Support Window PFD_SUPPORT_OPENGL | // Format Must Support OpenGL PFD_DOUBLEBUFFER, // Must Support Double Buffering PFD_TYPE_RGBA, // Request An RGBA Format 24, // Select Our Color Depth 0, 0, 0, 0, 0, 0, // Color Bits Ignored 0, // No Alpha Buffer 0, // Shift Bit Ignored 0, // No Accumulation Buffer 0, 0, 0, 0, // Accumulation Bits Ignored 16, // 16Bit Z-Buffer (Depth Buffer) 0, // No Stencil Buffer 0, // No Auxiliary Buffer PFD_MAIN_PLANE, // Main Drawing Layer 0, // Reserved 0, 0, 0 // Layer Masks Ignored }; nPixelFormat=ChoosePixelFormat(hdc,&pfd); SetPixelFormat(hdc,nPixelFormat,&pfd); hglrc=wglCreateContext(hdc); wglMakeCurrent(hdc,hglrc); } //--------------------------------------------------------------------------- GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } void FormDestroy() { closing=1; Wait(1); wglMakeCurrent(NULL,NULL); wglDeleteContext(hglrc); DeleteObject(hdc); printf("destroy"); } void OnClose() { closing=1; Wait(1); if((GuiMode==0)||(GuiMode==1)) { ClearVclControls(); HideVclWin(200); } else { CloseForm(pfm); } } GLvoid BuildFont(GLvoid) // Build Our Bitmap Font { HFONT font; // Windows Font ID HFONT oldfont; // Used For Good House Keeping base = glGenLists(96); // Storage For 96 Characters font = CreateFont( -24, // Height Of Font 0, // Width Of Font 0, // Angle Of Escapement 0, // Orientation Angle FW_BOLD, // Font Weight FALSE, // Italic FALSE, // Underline FALSE, // Strikeout ANSI_CHARSET, // Character Set Identifier OUT_TT_PRECIS, // Output Precision CLIP_DEFAULT_PRECIS, // Clipping Precision ANTIALIASED_QUALITY, // Output Quality FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch "Courier New"); // Font Name printf("font:%x",font); oldfont = (HFONT)SelectObject(hdc, font); // Selects The Font We Want wglUseFontBitmaps(hdc, 32, 96, base); // Builds 96 Characters Starting At Character 32 SelectObject(hdc, oldfont); // Selects The Font We Want DeleteObject(font); // Delete The Font } GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } void DrawLine(double x0,double y0,double x1,double y1) { glBegin(GL_LINES); glVertex3f(x0,y0, 0.0f); glVertex3f(x1,y1, 0.0f); glEnd(); } GLvoid glPrint(const char *fmt, ...) // Custom GL "Print" Routine { char text[256]; // Holds Our String va_list ap; // Pointer To List Of Arguments if (fmt == NULL) // If There's No Text return; // Do Nothing va_start(ap, fmt); // Parses The String For Variables vsprintf(text, fmt, ap); // And Converts Symbols To Actual Numbers va_end(ap); // Results Are Stored In Text //printf(text); glPushAttrib(GL_LIST_BIT); // Pushes The Display List Bits glListBase(base - 32); // Sets The Base Character to 32 glCallLists(strlen(text), GL_UNSIGNED_BYTE, text); // Draws The Display List Text glPopAttrib(); // Pops The Display List Bits } GLvoid glShxPrint(const char *fmt, ...) // Custom GL "Print" Routine { char text[256]; // Holds Our String va_list ap; // Pointer To List Of Arguments int i=0; if (fmt == NULL) // If There's No Text return; // Do Nothing va_start(ap, fmt); // Parses The String For Variables vsprintf(text, fmt, ap); // And Converts Symbols To Actual Numbers va_end(ap); // Results Are Stored In Text while(text[i]) { ReadCharShape(text[i],0); glTranslatef(10,0.0f,0.0f); i++; } } GLvoid ReSizeGLScene(GLsizei width, GLsizei height) // Resize And Initialize The GL Window { if (height==0) // Prevent A Divide By Zero By { height=1; // Making Height Equal One } glViewport(0,0,width,height); // Reset The Current Viewport glMatrixMode(GL_PROJECTION); // Select The Projection Matrix glLoadIdentity(); // Reset The Projection Matrix // Calculate The Aspect Ratio Of The Window gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f); glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix glLoadIdentity(); // Reset The Modelview Matrix } #define FT_ENC_TAG( value, a, b, c, d ) \ unsigned int value = ( ( (int)(a) << 24 ) | \ ( (int)(b) << 16 ) | \ ( (int)(c) << 8 ) | \ (int)(d) ) FT_ENC_TAG( FT_ENCODING_UNICODE, 'u', 'n', 'i', 'c' ); int InitGL(GLvoid) // All Setup For OpenGL Goes Here { int r; glShadeModel(GL_SMOOTH); // Enable Smooth Shading glClearColor(0.0f, 0.0f, 0.0f, 0.5f); // Black Background glClearDepth(1.0f); // Depth Buffer Setup glEnable(GL_DEPTH_TEST); // Enables Depth Testing glDepthFunc(GL_LEQUAL); // The Type Of Depth Testing To Do glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Really Nice Perspective Calculations BuildFont(); // Build The Font ft=ftglCreateBufferFont("c:\\windows\\fonts\\simhei.ttf"); ftglSetFontFaceSize(ft, 37, 72); ftglSetFontDepth(ft, 10); ftglSetFontOutset(ft, 0, 3); r=ftglSetFontCharMap(ft, FT_ENCODING_UNICODE); printf("glft:%x,set char map:%d",ft,r); return TRUE; // Initialization Went OK } int AnsiToUnicode(unsigned char *pszA, unsigned char* ppszW) { ULONG cCharacters; DWORD dwError; if (NULL == pszA) { *ppszW = NULL; printf("ERROR0"); return NOERROR; } cCharacters = strlen(pszA)+1; if (NULL == ppszW) return E_OUTOFMEMORY; // Covert to Unicode. if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, -1, ppszW, cCharacters)) { dwError = GetLastError(); free(ppszW); ppszW = NULL; printf("ERROR"); return HRESULT_FROM_WIN32(dwError); } return NOERROR; } int DrawGLScene(GLvoid) // Here's Where We Do All The Drawing { char buf[]= {0x31,0,0x32,0,0x8d,0x9c,0,0}; char buf1[100]; int i; AnsiToUnicode("ftgl(TTF): Name 中国 0086",buf1); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear Screen And Depth Buffer glLoadIdentity(); // Reset The Current Modelview Matrix glTranslatef(-1.0f,0.0f,-6.0f); // Move One Unit Into The Screen // Pulsing Colors Based On Text Position glColor3f(1.0f ,0.0f ,1.0f ); // Position The Text On The Screen glScalef(0.01,0.01,0.01); glLoadIdentity(); glTranslatef(-1.0f,0.0f,-6.0f); glRasterPos2f( -3, -1); glPrint("Active OpenGL Text With NeHe - "); // Print GL Text To The Screen /////////////ftgl///////////////////// glLoadIdentity(); glTranslatef(-3.0f,0.0f,-6.0f); glScalef(0.01,0.01,0.01); ftglRenderFontW(ft, buf1, 0xffff); /////////////shx///////////////////// glLoadIdentity(); glTranslatef(-3.0f,1.0f,-6.0f); glRasterPos2f(0, 0); glScalef(0.02,0.02,1); glShxPrint("AutoCAD shx Font:12345!"); cnt1+=0.051f; // Increase The First Counter cnt2+=0.005f; SwapBuffers(hdc); // Increase The First Counter return TRUE; // Everything Went OK } void OnTimer() { DrawGLScene(); } void OnTest() { DrawGLScene(); } void OnResize() { int x,y; x=GetProperty(pfm,"width",0,0); y=GetProperty(pfm,"height",0,0); ReSizeGLScene(x,y); } void main() { int i,j; int mi,mi1; //HideLeftTools(); ClearVclControls(); //ShowVclWin(-1); if((GuiMode==0)||(GuiMode==1)) pfm=GetGuiWin(GuiMode); else pfm=CreateComponentEx(0,"form","caption","调幅-正弦波","Width",600,"height",300,"BorderIcons","[biSystemMenu,biMaximize]","position","poMainFormCenter","formstyle","fsstayontop","OnClose",FormDestroy,"OnResize",OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] int btn=CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); CreateComponentEx(pfm,"SpeedButton","caption","test","left",80,"top",5,"width",60,"height",20,"OnClick",OnTest,0); //img=CreateComponentEx(pfm,"Image","left",10,"top",10,"width",200,"height",200,0); SetProperty(pfm,"visible",1);//// formcreate(); OnResize(); InitGL(); DrawGLScene(); ReaderShxFile("dat\\txt.shx"); int count=0; while(!closing) { DrawGLScene(); count++; if(count%5==4) { //printf("count:%d",count); Wait(1); } } printf("exit"); }" /> 
  <Command cmdname="OpenGL 汉字显示(ftgl、shx)" cmdType="P" cmd="[P]#include <windows.h> // Header File For Windows #include <stdio.h> // Header File For Standard Input/Output #include <gl\gl.h> // Header File For The OpenGL32 Library #include <gl\glu.h> // Header File For The GLu32 Library #include <gl\glaux.h> // Header File For The Glaux Library //#include"libtcc1.c" #include"math.h" #pragma comment(lib,"lib\\ftgl.def"); #pragma comment(lib,"lib\\shx.o"); #define bool unsigned char int closing=0; typedef struct CharIndex { int code; int shapePtr; int len; } CharIndex; typedef struct _ShxFont_ { int openOK; int indexCount; unsigned char *buffer; CharIndex *indexBuffer; int type; int shxFontDownLine,shxFontUpLine; double scale; } ShxFont; ShxFont *sf; // Private GDI Device Context HGLRC hRC=NULL; // Permanent Rendering Context HWND hWnd=NULL; // Holds Our Window Handle HINSTANCE hInstance; // Holds The Instance Of The Application GLuint base; // Base Display List For The Font Set GLfloat cnt1; // 1st Counter Used To Move Text & For Coloring GLfloat cnt2; // 2nd Counter Used To Move Text & For Coloring bool keys[256]; // Array Used For The Keyboard Routine bool active=TRUE; // Window Active Flag Set To TRUE By Default bool fullscreen=TRUE; // Fullscreen Flag Set To Fullscreen Mode By Default HGLRC hglrc; HDC hdc; int img; int pnl; int GuiMode=2,pfm; int *ft; void formcreate() { hdc=GetDC(GetFormHandle(pfm)); //hdc=(HANDLE)GetProperty(pnl,"dc",0,0,0); int nPixelFormat; /* static PIXELFORMATDESCRIPTOR pfd= { sizeof(PIXELFORMATDESCRIPTOR), 1, PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER, PFD_TYPE_RGBA, 24, 0,0,0,0,0, 0,0, 0,0,0,0,0, 32, 0, 0, PFD_MAIN_PLANE, 0, 0,0,0 };*/ static PIXELFORMATDESCRIPTOR pfd= // pfd Tells Windows How We Want Things To Be { sizeof(PIXELFORMATDESCRIPTOR), // Size Of This Pixel Format Descriptor 1, // Version Number PFD_DRAW_TO_WINDOW | // Format Must Support Window PFD_SUPPORT_OPENGL | // Format Must Support OpenGL PFD_DOUBLEBUFFER, // Must Support Double Buffering PFD_TYPE_RGBA, // Request An RGBA Format 24, // Select Our Color Depth 0, 0, 0, 0, 0, 0, // Color Bits Ignored 0, // No Alpha Buffer 0, // Shift Bit Ignored 0, // No Accumulation Buffer 0, 0, 0, 0, // Accumulation Bits Ignored 16, // 16Bit Z-Buffer (Depth Buffer) 0, // No Stencil Buffer 0, // No Auxiliary Buffer PFD_MAIN_PLANE, // Main Drawing Layer 0, // Reserved 0, 0, 0 // Layer Masks Ignored }; nPixelFormat=ChoosePixelFormat(hdc,&pfd); SetPixelFormat(hdc,nPixelFormat,&pfd); hglrc=wglCreateContext(hdc); wglMakeCurrent(hdc,hglrc); } //--------------------------------------------------------------------------- GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } void FormDestroy() { closing=1; Wait(1); wglMakeCurrent(NULL,NULL); wglDeleteContext(hglrc); DeleteObject(hdc); printf("destroy"); } void OnClose() { closing=1; Wait(1); if((GuiMode==0)||(GuiMode==1)) { ClearVclControls(); HideVclWin(200); } else { CloseForm(pfm); } } GLvoid BuildFont(GLvoid) // Build Our Bitmap Font { HFONT font; // Windows Font ID HFONT oldfont; // Used For Good House Keeping base = glGenLists(96); // Storage For 96 Characters font = CreateFont( -24, // Height Of Font 0, // Width Of Font 0, // Angle Of Escapement 0, // Orientation Angle FW_BOLD, // Font Weight FALSE, // Italic FALSE, // Underline FALSE, // Strikeout ANSI_CHARSET, // Character Set Identifier OUT_TT_PRECIS, // Output Precision CLIP_DEFAULT_PRECIS, // Clipping Precision ANTIALIASED_QUALITY, // Output Quality FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch "Courier New"); // Font Name printf("font:%x",font); oldfont = (HFONT)SelectObject(hdc, font); // Selects The Font We Want wglUseFontBitmaps(hdc, 32, 96, base); // Builds 96 Characters Starting At Character 32 SelectObject(hdc, oldfont); // Selects The Font We Want DeleteObject(font); // Delete The Font } GLvoid KillFont(GLvoid) // Delete The Font List { glDeleteLists(base, 96); // Delete All 96 Characters } void DrawLine0(double x0,double y0,double x1,double y1) { glBegin(GL_LINES); glVertex3f(x0,y0, 0.0f); glVertex3f(x1,y1, 0.0f); glEnd(); } void DrawLine(ShxFont *sf,double x0,double y0,double x1,double y1) { double scale; scale=5.0/GetShxFontHeight(sf)*1.0* sf->scale;// 0.08; x0*=scale; y0*=scale; x1*=scale; y1*=scale; x0+=0; x1+=0; glBegin(GL_LINES); glVertex3f(x0,y0, 0.0f); glVertex3f(x1,y1, 0.0f); glEnd(); } GLvoid glPrint(const char *fmt, ...) // Custom GL "Print" Routine { char text[256]; // Holds Our String va_list ap; // Pointer To List Of Arguments if (fmt == NULL) // If There's No Text return; // Do Nothing va_start(ap, fmt); // Parses The String For Variables vsprintf(text, fmt, ap); // And Converts Symbols To Actual Numbers va_end(ap); // Results Are Stored In Text //printf(text); glPushAttrib(GL_LIST_BIT); // Pushes The Display List Bits glListBase(base - 32); // Sets The Base Character to 32 glCallLists(strlen(text), GL_UNSIGNED_BYTE, text); // Draws The Display List Text glPopAttrib(); // Pops The Display List Bits } GLvoid glShxPrint(ShxFont *sf,const char *fmt, ...) // Custom GL "Print" Routine { char text[256]; // Holds Our String va_list ap; // Pointer To List Of Arguments int i=0; if (fmt == NULL) // If There's No Text return; // Do Nothing va_start(ap, fmt); // Parses The String For Variables vsprintf(text, fmt, ap); // And Converts Symbols To Actual Numbers va_end(ap); // Results Are Stored In Text while(text[i]) { ReadCharShape(sf,text[i],0); glTranslatef(14,0.0f,0.0f); i++; } } GLvoid ReSizeGLScene(GLsizei width, GLsizei height) // Resize And Initialize The GL Window { if (height==0) // Prevent A Divide By Zero By { height=1; // Making Height Equal One } glViewport(0,0,width,height); // Reset The Current Viewport glMatrixMode(GL_PROJECTION); // Select The Projection Matrix glLoadIdentity(); // Reset The Projection Matrix // Calculate The Aspect Ratio Of The Window gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f); glMatrixMode(GL_MODELVIEW); // Select The Modelview Matrix glLoadIdentity(); // Reset The Modelview Matrix } #define FT_ENC_TAG( value, a, b, c, d ) \ unsigned int value = ( ( (int)(a) << 24 ) | \ ( (int)(b) << 16 ) | \ ( (int)(c) << 8 ) | \ (int)(d) ) FT_ENC_TAG( FT_ENCODING_UNICODE, 'u', 'n', 'i', 'c' ); int InitGL(GLvoid) // All Setup For OpenGL Goes Here { int r; glShadeModel(GL_SMOOTH); // Enable Smooth Shading glClearColor(0.0f, 0.0f, 0.0f, 0.5f); // Black Background glClearDepth(1.0f); // Depth Buffer Setup glEnable(GL_DEPTH_TEST); // Enables Depth Testing glDepthFunc(GL_LEQUAL); // The Type Of Depth Testing To Do glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Really Nice Perspective Calculations BuildFont(); // Build The Font ft=ftglCreateBufferFont("c:\\windows\\fonts\\simhei.ttf"); ftglSetFontFaceSize(ft, 37, 72); ftglSetFontDepth(ft, 10); ftglSetFontOutset(ft, 0, 3); r=ftglSetFontCharMap(ft, FT_ENCODING_UNICODE); printf("glft:%x,set char map:%d",ft,r); return TRUE; // Initialization Went OK } int AnsiToUnicode(unsigned char *pszA, unsigned char* ppszW) { ULONG cCharacters; DWORD dwError; if (NULL == pszA) { *ppszW = NULL; printf("ERROR0"); return NOERROR; } cCharacters = strlen(pszA)+1; if (NULL == ppszW) return E_OUTOFMEMORY; // Covert to Unicode. if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, -1, ppszW, cCharacters)) { dwError = GetLastError(); free(ppszW); ppszW = NULL; printf("ERROR"); return HRESULT_FROM_WIN32(dwError); } return NOERROR; } int DrawGLScene(GLvoid) // Here's Where We Do All The Drawing { char buf[]= {0x31,0,0x32,0,0x8d,0x9c,0,0}; char buf1[100]; int i; AnsiToUnicode("ftgl(TTF): Name 中国 0086",buf1); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear Screen And Depth Buffer glLoadIdentity(); // Reset The Current Modelview Matrix glTranslatef(-1.0f,0.0f,-6.0f); // Move One Unit Into The Screen // Pulsing Colors Based On Text Position glColor3f(1.0f ,0.0f ,1.0f ); // Position The Text On The Screen glScalef(0.01,0.01,0.01); glLoadIdentity(); glTranslatef(-1.0f,0.0f,-6.0f); glRasterPos2f( -3, -1); glPrint("Active OpenGL Text With NeHe - "); // Print GL Text To The Screen /////////////ftgl///////////////////// glLoadIdentity(); glTranslatef(-3.0f,0.0f,-6.0f); glScalef(0.01,0.01,0.01); ftglRenderFontW(ft, buf1, 0xffff); /////////////shx///////////////////// glLoadIdentity(); glTranslatef(-3.0f,1.0f,-6.0f); glRasterPos2f(0, 0); glScalef(0.02,0.02,1); glShxPrint(sf,"AutoCAD shx Font:12345!"); cnt1+=0.051f; // Increase The First Counter cnt2+=0.005f; SwapBuffers(hdc); // Increase The First Counter return TRUE; // Everything Went OK } void OnTimer() { DrawGLScene(); } void OnTest() { DrawGLScene(); } void OnResize() { int x,y; x=GetProperty(pfm,"width",0,0); y=GetProperty(pfm,"height",0,0); ReSizeGLScene(x,y); } void main() { int i,j; int mi,mi1; //HideLeftTools(); ClearVclControls(); //ShowVclWin(-1); if((GuiMode==0)||(GuiMode==1)) pfm=GetGuiWin(GuiMode); else pfm=CreateComponentEx(0,"form","caption","调幅-正弦波","Width",600,"height",300,"BorderIcons","[biSystemMenu,biMaximize]","position","poMainFormCenter","formstyle","fsstayontop","OnClose",FormDestroy,"OnResize",OnResize,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] int btn=CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); CreateComponentEx(pfm,"SpeedButton","caption","test","left",80,"top",5,"width",60,"height",20,"OnClick",OnTest,0); //img=CreateComponentEx(pfm,"Image","left",10,"top",10,"width",200,"height",200,0); SetProperty(pfm,"visible",1);//// formcreate(); OnResize(); InitGL(); sf=CreateShxFont("dat\\txt.shx"); DrawGLScene(); int count=0; while(!closing) { DrawGLScene(); count++; if(count%5==4) { //printf("count:%d",count); Wait(1); } } printf("exit"); }" /> 
  </Command>
- <Command cmdname="游戏脚本编程" cmdType="S" cmd="[S]数据发送区/C语言脚本编辑区，[F5]键发送/执行。">
  <Command cmdname="俄罗斯方块" cmdType="P" cmd="[P]#include "windows.h" #include"libtcc1.c" #include"math.h" #define WHITE 0xffffff #define CYAN 0xffff00 #define YELLOW 0x00ffff #define BLACK 0x00000 #define RED 0x000ff #define GREEN 0x000ff00 /*定义左上角点在屏幕上的位置*/ #define MAPXOFT 9 #define MAPYOFT 5 /*定义下一个方块显示的位置*/ #define MAPXOFT1 14 #define MAPYOFT1 -1 #define LEFT 37 #define RIGHT 39 #define DOWN 40 /*此键为加速键*/ #define UP 38 /*此键为变形键*/ #define ESC 27 /*此键为退出键*/ #define ENTER 13 #ifdef __cplusplus #define __CPPARGS ... #else #define __CPPARGS #endif struct shape { int xy[8],next; }; struct shape shapes[19]= { /*x1,y1,x2,y2,x3,y3,x4,y4 指四个小方块的相对坐标，next指此方块变形后应变为哪个小方块 { x1,y1,x2,y2,x3,y3,x4,y4,next}*/ { 0,-2, 0,-1, 0, 0, 1, 0, 1}, {-1, 0, 0, 0, 1,-1, 1, 0, 2}, { 0,-2, 1,-2, 1,-1, 1, 0, 3}, {-1,-1,-1, 0, 0,-1, 1,-1, 0}, { 0,-2, 0,-1, 0, 0, 1,-2, 5}, {-1,-1, 0,-1, 1,-1, 1, 0, 6}, { 0, 0, 1,-2, 1,-1, 1, 0, 7}, {-1,-1,-1, 0, 0, 0, 1, 0, 4}, {-1, 0, 0,-1, 0, 0, 1, 0, 9}, { 0,-2, 0,-1, 0, 0, 1,-1,10}, {-1,-1, 0,-1, 1,-1, 0, 0,11}, { 0,-1, 1,-2, 1,-1, 1, 0, 8}, {-1, 0, 0,-1, 0, 0, 1,-1,13}, { 0,-2, 0,-1, 1,-1, 1, 0,12}, {-1,-1, 0,-1, 0, 0, 1, 0,15}, { 0,-1, 0, 0, 1,-2, 1,-1,14}, { 0,-3, 0,-2, 0,-1, 0, 0,17}, {-1, 0, 0, 0, 1, 0, 2, 0,16}, { 0,-1, 0, 0, 1,-1, 1, 0,18} }; int board[10][20]= {0}; /*定义游戏板初始化为0*/ char sp[]="0",le[]="0",sc[]="00000"; int speed,speed0,level,score; int sign,flag; int style,style1; /*style为当前方块的种类，style1为即将输出的方块的种类*/ void draw_block(int x,int y,int style,int way); void draw_little_block(int x,int y); void initialize(); void speed_change(void); void score_change(int); void kill_line(int y); void High_line(int y); void fill_board(int x,int y, int style); int change(int *i,int *j,int key); void renovate(void); void ajustment(void); void level_change(void); int needclose=0; HPEN pen=0; HBRUSH brush=0; int p; int img; HANDLE dc; int start=0; int TimerCounter=0; /* 计时变量，每秒钟增加18。 */ int KeyDown=0; void OnTimer() { TimerCounter++; } void OnClose() { printf("need close..."); needclose=1; Wait(1); Wait(1); CloseForm(p); } void OnDblClick() { PlayWave("ding.wav"); KeyDown=ENTER; } void OnEnter() { PlayWave("ding.wav"); KeyDown=ENTER; } void OnLeft() { KeyDown=LEFT; } void OnUp() { KeyDown=UP; } void OnRight() { KeyDown=RIGHT; } void OnDown() { KeyDown=DOWN; } void OnKeyDown(int id,int *key,int state) { KeyDown=*key; } void InitGraph() { HideLeftTools(); ClearVclControls(); HideVclWin(200); //p=GetGuiWin(0); p=CreateComponentEx(0,"form","caption","GDI绘图示例-俄罗斯方块","Width",520,"height",580,"position","poMainFormCenter","BorderIcons","[]","OnKeyDown",OnKeyDown,"formstyle","fsstayontop",NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] CreateComponentEx(p,"timer","interval",40,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 CreateComponentEx(p,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); CreateComponentEx(p,"SpeedButton","caption","Enter","left",80,"top",5,"width",60,"height",20,"OnClick",OnEnter,0); CreateComponentEx(p,"SpeedButton","caption","Left","left",150,"top",5,"width",60,"height",20,"OnClick",OnLeft,0); CreateComponentEx(p,"SpeedButton","caption","Up","left",220,"top",5,"width",60,"height",20,"OnClick",OnUp,0); CreateComponentEx(p,"SpeedButton","caption","Right","left",290,"top",5,"width",60,"height",20,"OnClick",OnRight,0); CreateComponentEx(p,"SpeedButton","caption","Down","left",360,"top",5,"width",60,"height",20,"OnClick",OnDown,0); img=CreateComponentEx(p,"Image","left",10,"top",40,"width",480,"height",480,"OnDblClick",OnDblClick,0); SetProperty(p,"visible",1); RECT rect= {0,0,640,480}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0x00); SelectObject(dc,brush); FillRect(dc,&rect,brush); DeleteObject(brush); } void setcolor(int cl) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); if(pen!=0) DeleteObject(pen); pen=CreatePen(PS_SOLID,1,cl); SelectObject(dc,pen); //if(brush!=0) DeleteObject(brush); //pen=CreateSolidBrush(RED); //SelectObject(dc,brush); } int bioskey(int flat) { int tmp; if(flat==1) { if(KeyDown!=0) return 1; else return 0; } tmp=KeyDown; KeyDown=0; return tmp; } void outtextxy(int x,int y,char *s) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); TextOutA(dc,x,y,s,strlen(s)); } void setbkcolor(int cl) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); SetBkColor(dc,cl); } void settextcolor(int cl) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); SetTextColor(dc,cl); } void line(int x0,int y0,int x1,int y1) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); MoveToEx(dc,x0,y0,0); LineTo(dc,x1,y1); } void rectangle(int x0,int y0,int x1,int y1) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); MoveToEx(dc,x0,y0,0); LineTo(dc,x1,y0); LineTo(dc,x1,y1); LineTo(dc,x0,y1); LineTo(dc,x0,y0); } void circle(int x,int y,int r) { int i; for(i=r;i>=0;i-=2) rectangle(x-i/2,y-i/2,x+i/2,y+i/2); //dc=(HANDLE)GetProperty(img,"dc",0,0,0); //Ellipse(dc,x-r/2,y-r/2,x+r/2,y+r/2); } main() { int i,j,key,x0=5,y0=1; InitGraph(); while(!flag) /*flag为0表示重新开始游戏*/ { if(needclose)return; Wait(1); level=score=speed=0; strcpy(le,"0"); strcpy(sp,"0"); strcpy(sc,"00000"); for(i=0; i<10; i++) for(j=0; j<20; j++) board[i][j]=0; /*初始化一些变量为0*/ ajustment(); /*开始游戏前调整速度和高度*/ if(level>0) level_change(); /*根据高度随机确定方块是否存在*/ style=rand(100)%19; /*随机确定方块种类*/ while(1) { if(needclose)return; Wait(1); i=x0,j=y0; style1=rand(100)%19; /*随机确定即将出现的方块种类*/ setcolor(WHITE); sign=1; draw_block(MAPXOFT1,MAPYOFT1,style1,1);/*画出即将出现的方块*/ speed0=0; for(j=y0; j<=20; j++) /*使方块下降*/ { if(needclose)return; if(!check_block(i,j,style)) { draw_block(i,j-1,style,1); renovate(); break; } if(speed0!=9) draw_block(i,j,style,1); while(speed0==0)// wait 1 sec { if(needclose)return; Wait(0); if (TimerCounter>18/(speed+1)) { TimerCounter=0;/* 恢复计时变量 */ break; } if(bioskey(1)) { key=bioskey(0); if(change(&i,&j,key))/*根据按键值做调整*/ { flag=1; goto end; } PlayWave("down.WAV"); } } draw_block(i,j,style,0); renovate(); // /*刷新屏幕*/ } if(j==y0) { break; } j--; draw_block(i,j,style,1); fill_board(i,j,style); sign=1; High_line(j); kill_line(j); /*消去的函数，消去若干行并改变分数和速度*/ draw_block(MAPXOFT1,MAPYOFT1,style1,0); style=style1; while(bioskey(1)) /*清除内存中的按键*/ key=bioskey(0); } setcolor(CYAN); TimerCounter=0; while(bioskey(1)) /*清除内存中的按键*/ key=bioskey(0); setbkcolor(BLACK); settextcolor(RED); outtextxy(360,340,"游戏结束!"); outtextxy(360,360,"按【回车】键重新开始"); outtextxy(360,380,"按【ESC】键退出"); Invalidate(img); printf("Game Over!!!"); Wait(1); while(bioskey(1)==0) { Wait(1); if(needclose)return; } key=bioskey(0); end: if(key==ESC||flag) break; } RECT rect= {0,0,640,480}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0xFF); SelectObject(dc,brush); FillRect(dc,&rect,brush); outtextxy(50,30," 游戏结束 "); Invalidate(img); printf("exit form game!"); } void ajustment(void) /*开始游戏前调整速度和高度*/ { int key,boo=1,left=1; RECT rect= {0,0,640,480}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0x00); SelectObject(dc,brush); FillRect(dc,&rect,brush); DeleteObject(brush); renovate(); setcolor(YELLOW); setbkcolor(BLACK); settextcolor(GREEN); outtextxy(150,30," 按【回车】键开始游戏... "); outtextxy(150,50," 按【上下左右】设置难度与速度 "); outtextxy(95,280," 难度 "); outtextxy(335,280," 速度 "); outtextxy(6.5*16,15*16,le); outtextxy(21.9*16,15*16,sp); Invalidate(img); Wait(1); while(1) { if(needclose) return; Wait(1); if(TimerCounter>4) { TimerCounter=0; boo*=-1; if(boo==-1) setcolor(BLACK); else setcolor(YELLOW); if(left==1) { line(6*16,17*16,8.5*16,17*16); setcolor(BLACK); line(21.4*16,17*16,23.9*16,17*16); } else { line(21.4*16,17*16,23.9*16,17*16); setcolor(BLACK); line(6*16,17*16,8.5*16,17*16); } Invalidate(img); Wait(1); } if(bioskey(1)) { key=bioskey(0); if(key==ENTER) break; else if(key==UP) { if(left==1) { level--; if(level==-1) level=9; } else { speed--; if(speed==-1) speed=9; } } else if(key==DOWN) { if(left==1) { level++; if(level==10) level=0; } else { speed++; if(speed==10) speed=0; } } else if(key==LEFT||RIGHT) left*=-1; setcolor(YELLOW); sp[0]=speed+'0'; le[0]=level+'0'; setbkcolor(BLACK); settextcolor(GREEN); outtextxy(6.5*16,15*16,le); outtextxy(21.9*16,15*16,sp); Invalidate(img); Wait(1); } } setcolor(YELLOW); sp[0]=speed+'0'; le[0]=level+'0'; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0x00); SelectObject(dc,brush); FillRect(dc,&rect,brush); DeleteObject(brush); renovate(); setbkcolor(BLACK); settextcolor(GREEN); outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16,"0000"); /*输出新分数*/ outtextxy(-80+(MAPXOFT+21)*16-16*2.5,(MAPYOFT+6)*16,"分数:"); /*输出新分数*/ outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16-16,le); /*输出新分数*/ outtextxy(-80+(MAPXOFT+21)*16-16*2.5,(MAPYOFT+6)*16-16,"难度:"); /*输出新分数*/ outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16-32,sp); /*输出新分数*/ outtextxy(-80+(MAPXOFT+21)*16-16*2.5,(MAPYOFT+6)*16-32,"速度:"); /*输出新分数*/ Invalidate(img); Wait(1); } void level_change(void) /*根据高度随机确定方块是否存在*/ { int i,j; setcolor(WHITE); for(i=1; i<=10; i++) for(j=1; j<=level; j++) if(rand(2)) { board[i-1][20-j]=1; draw_little_block(i+MAPXOFT,21-j+MAPYOFT); } } /*此x,y为虚拟坐标，为19中形式中的一种：0~18中的一个 x,y为10*20的方格的坐标，下标从1开始 way为1表填充，为0表清除*/ void draw_block(int x,int y,int style,int way) { int x1,y1; int i; x1=x+MAPXOFT,y1=y+MAPYOFT; if(way==1) setcolor(WHITE); else setcolor(BLACK); for(i=0; i<=6; i+=2) draw_little_block(x1+shapes[style].xy[i],y1+shapes[style].xy[i+1]); if(sign==1) sign=0; if(way==1) Invalidate(img); } void draw_little_block(int x,int y)/*此处仅在10*20的游戏版内画小方块，若在外，不画之。*/ { if((x>=10&&x<20&&y>=6&&y<26)||sign) { rectangle(x*16,y*16,x*16+16,y*16+16); circle(x*16+8,y*16+8,6); } } int check_block(int x,int y,int style)/*此处检查在(x,y)处放置一方块是否可以，若是，则返回1，否则返回0*/ { int x1=x+MAPXOFT,y1=y+MAPYOFT; int x2,y2,i; for(i=0; i<=6; i+=2) { x2=x1+shapes[style].xy[i]; y2=y1+shapes[style].xy[i+1]; if(x2>=10&&x2<20&&y2<26&&(y2<6||board[x2-10][y2-6]==0)) continue; else break; } if(i==8) return 1; else return 0; } void speed_change(void) /*此为变速函数，当分数超过一级时，即加一。*/ { if(score>=(sp[0]-'0')*100&&(sp[0]-'0')<9) { sp[0]++; speed++; setbkcolor(BLACK); settextcolor(GREEN); outtextxy(21.9*16,15*16,sp); } } void score_change(int count) /*count为消去的行数，据此来改变score的值*/ { int score_inc[4]= {1,3,7,13}; int i; score+=score_inc[count-1]; sc[4]+=score_inc[count-1]; for(i=4; i>=1; i--) { sc[i-1]+=(sc[i]-'0')/10; sc[i]-=(sc[i]-'0')/10*10; } setcolor(YELLOW); setbkcolor(BLACK); settextcolor(GREEN); outtextxy(-80+(MAPXOFT+21)*16,(MAPYOFT+6)*16,sc); /*输出新分数*/ } void High_line(int y)/*消去的函数，消去若干行并改变分数和速度*/ { int count=0,i,t=1,j,k; int row; for(j=0; j<4; j++) { count=0; for(row=y; row>=1; row--) { for(i=1; i<=10; i++) if(!board[i-1][row-1]) break; if(i==11) { count++; for(k=1; k<=10; k++) { if(j%2==0) setcolor(RED); else setcolor(0x00ff00); draw_little_block(k+MAPXOFT,row+MAPYOFT); } } } if(count>0) { if(j==0) score_change(count); Invalidate(img); if(j==0) PlayWave("addscore.wav"); Wait(100); } else return; } } void kill_line(int y)/*消去的函数，消去若干行并改变分数和速度*/ { int count=0,i,t=1,j,k; for(; y>=1&&t<=4; y--,t++) { for(i=1; i<=10; i++) if(!board[i-1][y-1]) break; if(i==11) { count++; for(k=1; k<=10; k++) { setcolor(BLACK); draw_little_block(k+MAPXOFT,y+MAPYOFT); } for(j=y-1; j>=1; j--) for(k=1; k<=10; k++) { board[k-1][j]=board[k-1][j-1]; if(board[k-1][j]) { setcolor(BLACK); draw_little_block(k+MAPXOFT,j+MAPYOFT); setcolor(WHITE); draw_little_block(k+MAPXOFT,j+1+MAPYOFT); } } renovate(); Wait(10); y++; } } } void fill_board(int x,int y, int style) /*当一方块停止时，将中相应的值改为1*/ { int x1,y1,i; for(i=0; i<=6; i+=2) { x1=x+shapes[style].xy[i]; y1=y+shapes[style].xy[i+1]; board[x1-1][y1-1]=1; } } int change(int *i,int *j,int key)/*控制方块移动、变形的函数*/ { int key1; if(key==UP&&check_block(*i,*j,shapes[style].next)) { draw_block(*i,*j,style,0); style=shapes[style].next; draw_block(*i,*j,style,1); } else if(key==LEFT&&check_block(*i-1,*j,style)) { draw_block(*i,*j,style,0); (*i)--; draw_block(*i,*j,style,1); } else if(key==RIGHT&&check_block(*i+1,*j,style)) { draw_block(*i,*j,style,0); (*i)++; draw_block(*i,*j,style,1); } else if(key==DOWN&&check_block(*i,*j+1,style)) { draw_block(*i,*j,style,0); (*j)++; draw_block(*i,*j,style,1); speed0=9; } else if(key==ENTER) { while(1) { Wait(1); if(bioskey(1)) key1=bioskey(0); if(key1==ENTER) break; } } else if(key==ESC) return 1; else if(key==21040) { sign=1; draw_block(MAPXOFT1,MAPYOFT1,style1,0); style1=16; sign=1; draw_block(MAPXOFT1,MAPYOFT1,style1,1); } return 0; } void renovate(void) /*刷新屏幕*/ { int i,j; setcolor(WHITE); for(i=1; i<=10; i++) for(j=1; j<=20; j++) if(board[i-1][j-1]==1) draw_little_block(i+MAPXOFT,j+MAPYOFT); setcolor(BLACK); rectangle(10*16-1,6*16-1,20*16+1,26*16+1); setcolor(YELLOW); rectangle(10*16-2,6*16-2,20*16+2,26*16+2); Invalidate(img); Wait(0); }" /> 
  <Command cmdname="五子棋" cmdType="P" cmd="[P]#include "windows.h" #include "stdio.h" #include "conio.h" #define SIZE 24 #define X0 30 #define Y0 30 #define Radius 16 #define TRUE 1 #include "stdio.h" #include "dos.h" #include "conio.h" #include "stdlib.h" #define LEFT 37 #define RIGHT 39 #define DOWN 40 /*此键为加速键*/ #define UP 38 /*此键为变形键*/ #define ESC 27 /*此键为退出键*/ #define ENTER 13 #define DEPTH 21 //递归深度，棋力 int player_x,player_y; int kx=7,ky=7; int old_x,old_y; char back[6]= {27,28,25,26,31,48}; int pfm; void graph_init(); void drawline(); char getkey(); void drawcircle(int ,int ,char); void drawcross(int,int); void setbit(int,int); int needclose=0; int KeyDown=0; HPEN pen=0; int img; HANDLE dc; int ms; int mx,my; void setcolor(int cl) { cl*=0xfffff; dc=(HANDLE)GetProperty(img,"dc",0,0,0); if(pen!=0) DeleteObject(pen); pen=CreatePen(PS_SOLID,1,cl); SelectObject(dc,pen); } int bioskey(int flat) { int tmp; if(flat==1) { if(KeyDown!=0) return 1; else return 0; } tmp=KeyDown; KeyDown=0; return tmp; } void putpixel(int x,int y,int cl) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); SetPixel(dc,x,y,cl*0xfffff); } void settextstyle(int a,int b,int c) { } void outtextxy(int x,int y,char *s) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); TextOutA(dc,x,y,s,strlen(s)); } void line(int x0,int y0,int x1,int y1) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); MoveToEx(dc,x0,y0,0); LineTo(dc,x1,y1); } void rectangle(int x0,int y0,int x1,int y1) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); MoveToEx(dc,x0,y0,0); LineTo(dc,x1,y0); LineTo(dc,x1,y1); LineTo(dc,x0,y1); LineTo(dc,x0,y0); } void circle(int x,int y,int r) { rectangle(x-r/2,y-r/2,x+r/2,y+r/2); } void setmousecoord(int x,int y) { RECT rect; //x+=10; //y+=40; rect.left=x-10; rect.top=y-10; rect.right=x+10; rect.bottom=y+10; InvalidateImgRect(img,&rect,1); return; InvalidateRect(GetFormHandle(pfm),&rect,0); UpdateWindow(GetFormHandle(pfm)); } void setfillstyle(int m1,int m2) { } void ellipse(int x0,int y0,int start,int end,int r0,int r1) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); Ellipse(dc,x0-r0/2,y0-r1/2,x0+r0/2,y0+r1/2); } void OnKeyDown(int id,int *key,int state) { KeyDown=*key; } typedef struct struct1 { char p[4]; char l[4]; char d[4]; } QCL; QCL pos[15][15][2]; char all[15][15][2]; char keepgo(int,int,int,char,char,int,QCL); char goon(int,int,char,char,int); char ifgook(int,int,char,char); char computer_keep(int,int,int); void exit_game(); unsigned int step=0; unsigned keep[11]= { 0x0015, //011100 0x0062, //001110 0x0613, //010110 0x0614, //011010 0x0000, //111111 0x0001, //01111 0x0002, //10111 0x0003, //11011 0x0004, //11101 0x0005, //11110 0x0000 //11111 }; char judge; /*****************************/ /* return value */ /* -1 can not move */ /* 0 nothing */ /* 1 5,6 ready */ /* 2 3 ready */ /* 3 3,3 ready */ /* 4 4 ready */ /* 5 3,4 ready */ /* 6 4,4 ready */ /*****************************/ char computer_go(int) ; char many(int ,int); char power(int ,int ,char); /*****************************/ /* return value */ /* -1 lose the game */ /* 0 nothing happen */ /* 1 win the game */ /*****************************/ void active_init(void); void game_init(void); unsigned int left,top,right,down; unsigned char player,computer; QCL Glist; char active[15][15][2]; char qz[15][15]; #define LEN 252 #define COLOR 15 #define INTR 0X1C /* The clock tick interrupt */ #define X 98 #define Y 10 char num[11][9]= { {0x7e,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7e},//0 {0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},//1 {0x7e,0x01,0x01,0x01,0x7e,0x80,0x80,0x80,0x7e},//2 {0x7e,0x01,0x01,0x01,0x7e,0x01,0x01,0x01,0x7e},//3 {0x81,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x01},//4 {0x7e,0x80,0x80,0x80,0x7e,0x01,0x01,0x01,0x7e},//5 {0x7e,0x80,0x80,0x80,0x7e,0x81,0x81,0x81,0x7e},//6 {0x7e,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},//7 {0x7e,0x81,0x81,0x81,0x7e,0x81,0x81,0x81,0x7e},//8 {0x7e,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x7e},//9 {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}, }; #define COLOR 10 void text(int,int,char,int,char *); int count0=0,second0=0;/*computer's time*/ int count1=0,second1=0;/*player's time*/ int check; void set(int che) { if(che>2) return; check=che; } void reset() { count0=0; count1=0; second0=0; second1=0; check=0; } void init(); void attrib(int x,int y,QCL *pl,char color1,char color2); void qz_init(); void game_init(void) { init(); active_init(); qz_init(); left=right=top=down=7; } void active_init(void) { int i,j; for(i=0; i<15; i++) for(j=0; j<15; j++) active[i][j][0]=active[i][j][1]=0; } void qz_init(void) { int i,j; for(i=0; i<15; i++) for(j=0; j<15; j++) qz[i][j]=0; } char computer_go(int len) { register int i,j; char result,temp1,temp2,temp3; int max,large; char max_x,max_y; //ShowMessage("Computer go"); step++; for(i=left; i<=right; i++) for(j=top; j<=down; j++) { all[i][j][computer-1]=ifgook(i,j,computer,player); pos[i][j][computer-1]=Glist; all[i][j][player-1]=ifgook(i,j,player,computer); pos[i][j][player-1]=Glist; } for(i=left; i<=right; i++) for(j=top; j<=down; j++) if(all[i][j][computer-1]==1) { drawcircle(i,j,computer); return 1; } for(i=left; i<=right; i++) for(j=top; j<=down; j++) if(all[i][j][player-1]==1) { if(all[i][j][computer-1]!=-1) { drawcircle(i,j,computer); return 0; } else return -1; } large=-1; judge=4; if(len==3) { for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(active[i][j][computer-1]==1) { switch(all[i][j][computer-1]) { case -1: break; case 0: break; case 6: case 1: drawcircle(i,j,computer); return 1; case 2: case 3: break; case 5: qz[i][j]=computer; temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { drawcircle(i,j,computer); return 0; } break; case 4: temp3=power(i,j,computer); if(temp3<=large) break; qz[i][j]=computer; temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { large=temp3; max_x=i; max_y=j; } break; default: printf("error if computer_go()."); } } } if(large>=0) { drawcircle(max_x,max_y,computer); return 0; } result=computer_keep(player_x,player_y,3); if(result==1) return 0; } else { judge=4; large=-1; for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(active[i][j][computer-1]==1) { switch(all[i][j][computer-1]) { case -1: break; case 0: break; case 6: case 1: drawcircle(i,j,computer); return 1; case 2: case 3: break; case 5: qz[i][j]=computer; temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { drawcircle(i,j,computer); return 0; } break; case 4: temp3=power(i,j,computer); if(temp3<=large) break; qz[i][j]=computer; temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { large=temp3; max_x=i; max_y=j; } break; default: printf("error if computer_go()."); } } } if(large>=0) { drawcircle(max_x,max_y,computer); return 0; } } large=-1; judge=4; for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(active[i][j][player-1]==1) { temp1=all[i][j][computer-1]; switch(all[i][j][player-1]) { case -1: break; case 0: break; case 6: case 1: if(temp1!=-1) { drawcircle(i,j,computer); return 0; } break; case 2: case 3: break; case 5: if(temp1!=-1) { qz[i][j]=player; temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]); qz[i][j]=0; if(temp2==-1) { drawcircle(i,j,computer); return 0; } } break; case 4: if(temp1!=-1) { temp3=power(i,j,player); if(temp3<=large) break; qz[i][j]=player; temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]); qz[i][j]=0; if(temp2==-1) { large=temp3; max_x=i; max_y=j; } } break; default: printf("error if player_go()."); } } } if(large>=0) { drawcircle(max_x,max_y,computer); return 0; } judge=3; large=-1; for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(active[i][j][computer-1]==1) { switch(all[i][j][computer-1]) { case -1: break; case 0: break; case 6: case 5: drawcircle(i,j,computer); return 0; case 1: drawcircle(i,j,computer); return 1; case 2: case 3: temp3=power(i,j,computer); if(temp3<=large) break; qz[i][j]=computer; temp1=keepgo(i,j,3,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { large=temp3; max_x=i; max_y=j; } break; case 4: temp3=power(i,j,computer); if(temp3<=large) break; qz[i][j]=computer; temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { large=temp3; max_x=i; max_y=j; } break; default: printf("error if player_go()."); } } } if(large>=0) { drawcircle(max_x,max_y,computer); return 0; } large=-1; judge=3; for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(active[i][j][player-1]==1) { temp1=all[i][j][computer-1]; switch(all[i][j][player-1]) { case -1: break; case 0: break; case 6: case 5: case 1: if(temp1!=-1) { drawcircle(i,j,computer); return 0; } break; case 3: if(temp1!=-1) { qz[i][j]=player; temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]); qz[i][j]=0; if(temp2!=1) { drawcircle(i,j,computer); return 0; } } break; case 2: if(temp1!=-1) { temp3=power(i,j,player); if(temp3<=large) break; qz[i][j]=player; temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]); qz[i][j]=0; if(temp2!=1) { large=temp3; max_x=i; max_y=j; } } break; case 4: if(temp1!=-1) { temp3=power(i,j,player); if(temp3<=large) break; qz[i][j]=player; temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]); qz[i][j]=0; if(temp2==-1) { large=temp3; max_x=i; max_y=j; } } break; default: printf("error if player_go()."); } } } if(large>=0) { drawcircle(max_x,max_y,computer); return 0; } max=-1; max_x=6; max_y=7; if(computer==2&&step<=5) { for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(all[i][j][0]>0&&all[i][j][1]>0) { temp1=power(i,j,1); if(temp1>max) { max=temp1; max_x=i; max_y=j; } else if(temp1==max&&power(max_x,max_y,computer)<power(i,j,computer)) { max_x=i; max_y=j; } } } if(max>=0) { drawcircle(max_x,max_y,computer); return 0; } for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(all[i][j][computer-1]!=-1) { temp1=power(i,j,1); if(temp1>max) { max=temp1; max_x=i; max_y=j; } } } if(max>=0) { drawcircle(max_x,max_y,computer); return 0; } } if(computer==1&&step<=5) { for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(all[i][j][computer-1]!=-1&&active[i][j][computer-1]==1&&all[i][j][player-1]>0) { temp1=power(i,j,computer); if(temp1>max) { max=temp1; max_x=i; max_y=j; } else if(temp1==max&&power(max_x,max_y,player)<power(i,j,player)) { max_x=i; max_y=j; } } } if(max>=0) { drawcircle(max_x,max_y,computer); return 0; } } for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(qz[i][j]==0&&all[i][j][computer-1]!=-1) { temp1=many(i,j); if(temp1>max) { max=temp1; max_x=i; max_y=j; } } } drawcircle(max_x,max_y,computer); return 0; } char player_go() { char result; result=getkey(); if(needclose) { printf("exit player go"); return 0; } switch(result) { case 0: return 0; case -1: return -1; case 1: return 1; case 3: case 2: return 3; case 4: case 5: case 6: return 4; default: return result; } } char ifgook(int x,int y,char color1,char color2) { register int i; int k3=0,k4=0; if(qz[x][y]!=0) return -1; qz[x][y]=color1; attrib(x,y,&Glist,color1,color2); qz[x][y]=0; for(i=0; i<4; i++) { if(Glist.p[i]>=0&&Glist.p[i]<=3) k3++; else if(Glist.p[i]==10) return 1; /* there is five .*/ else if(Glist.p[i]<10&&Glist.p[i]>=5) k4++; if(Glist.p[i]==4&&color1==1) return -1; if(Glist.p[i]==4&&color1==2) return 1; } if(k4>1) { if(color1==1) return -1; else return 6; } if(k3>1&&color1==1) return -1; if(k3==1&&k4==1) return 5; /* case a 3 and a 4 */ if(k3>1) return 3; if(k4==1) return 4 ; /* case a 4 */ if(k3==1) return 2 ; /* case a 3 */ return 0; } char keepgo(int x,int y,int len,char color1,char color2,int depth,QCL list) { int dx,dy,x0,y0; int i,bx,by,mask,d,r0,r1,r2; char old_judge; if(depth>=DEPTH) return -1; else depth++; for(i=0; i<4; i++) { switch(i) { case 0: dx=0; dy=1; break; case 1: dx=1; dy=1; break; case 2: dx=1; dy=0; break; case 3: dx=1; dy=-1; break; } if(list.l[i]==len) { int j; j=list.p[i]; bx=x-dx*list.d[i]; by=y-dy*list.d[i]; mask=keep[j]; while(mask!=0) { d=(mask&0x000f)-1; x0=bx+d*dx; y0=by+d*dy; r1=ifgook(x0,y0,color1,color2); switch(r1) { case -1: break; case 0: if(judge==4||judge==5) { qz[x0][y0]=color1; r2=goon(x,y,color2,color1,depth); qz[x0][y0]=0; if(r2==1) break; else return 1; } if(judge==3) { judge=4; qz[x0][y0]=color1; r2=goon(x0,y0,color1,color2,depth); judge=3; if(r2==1) judge=4; r2=goon(x,y,color2,color1,depth); qz[x0][y0]=0; judge=3; if(r2==1) break; else return 1; } case 2: case 3: old_judge=judge; if(judge==3) judge=4; qz[x0][y0]=color1; r2=goon(x,y,color2,color1,depth); qz[x0][y0]=0; judge=old_judge; if(r2==1) break; else return 1; case 1: return 1; case 4: case 5: case 6: old_judge=judge; if(judge==3||judge==4) judge=5; qz[x0][y0]=color1; r2=goon(x,y,color2,color1,depth); qz[x0][y0]=0; judge=old_judge; if(r2==1) break; else return 1; default: printf("error in keepgo()"); break; } mask=mask>>4; } } } return -1; } char goon(int x,int y,char color1,char color2,int depth) { int i,dx,dy,k1,k2,rang1,rang2,temp; int nx,ny; char r1,r2; for(i=0; i<4; i++) { k1=1; k2=1; switch(i) { case 0: dx=0; dy=1; rang1=(y>4)?4:y; rang2=(14-y>4)?4:14-y; break; case 1: dx=1; dy=1; rang1=(x<y)?x:y; rang1=(rang1>4)?4:rang1; rang2=(x>y)?x:y; rang2=(14-rang2>4)?4:14-rang2; break; case 2: dx=1; dy=0; rang1=(x>4)?4:x; rang2=(14-x>4)?4:14-x; break; case 3: dx=1; dy=-1; rang1=(x<14-y)?x:14-y; rang1=(rang1>4)?4:rang1; rang2=(14-x<y)?14-x:y; rang2=(rang2>4)?4:rang2; break; } while(k1<=rang1) { nx=x-k1*dx; ny=y-k1*dy; temp=qz[nx][ny]; k1++; if(temp==0) { r1=ifgook(nx,ny,color1,color2); switch(r1) { case -1: case 0: break; case 1: return 1; case 2: case 3: if(judge!=3) break; qz[nx][ny]=color1; r2=keepgo(nx,ny,3,color2,color1,depth,Glist); qz[nx][ny]=0; if(r2==-1) return 1; break; case 6: case 5: case 4: if(judge==5) break; qz[nx][ny]=color1; r2=keepgo(nx,ny,4,color2,color1,depth,Glist); qz[nx][ny]=0; if(r2==-1) return 1; break; } } if(temp==color2) break; } while(k2<=rang2) { nx=x+k2*dx; ny=y+k2*dy; temp=qz[nx][ny]; k2++; if(temp==0) { r1=ifgook(nx,ny,color1,color2); switch(r1) { case -1: case 0: break; case 1: return 1; case 2: case 3: if(judge!=3) break; qz[nx][ny]=color1; r2=keepgo(nx,ny,3,color2,color1,depth,Glist); qz[nx][ny]=0; if(r2==-1) return 1; break; case 5: case 6: case 4: if(judge==5) break; qz[nx][ny]=color1; r2=keepgo(nx,ny,4,color2,color1,depth,Glist); qz[nx][ny]=0; if(r2==-1) return 1; break; } } if(temp==color2) break; } } return -1; } char computer_keep(int x,int y,int len) { int dx,dy,x0,y0; int i,j,bx,by,mask,d,r1,r2; int temp; char old_judge; int max=-1,max_x,max_y; QCL list; attrib(x,y,&list,player,computer); judge=3; for(i=0; i<4; i++) { switch(i) { case 0: dx=0; dy=1; break; case 1: dx=1; dy=1; break; case 2: dx=1; dy=0; break; case 3: dx=1; dy=-1; break; } if(list.l[i]==len) { j=list.p[i]; bx=x-dx*list.d[i]; by=y-dy*list.d[i]; mask=keep[j]; while(mask!=0) { d=(mask&0x000f)-1; x0=bx+d*dx; y0=by+d*dy; r1=ifgook(x0,y0,computer,player); switch(r1) { case -1: break; case 0: old_judge=judge; judge=4; qz[x0][y0]=computer; r2=goon(x0,y0,computer,player,0); if(r2==-1) judge=3; r2=goon(x,y,player,computer,0); qz[x0][y0]=0; judge=old_judge; if(r2==1) break; r2=power(x0,y0,1); if(max<r2) { max=r2; max_x=x0; max_y=y0; } break; case 1: drawcircle(x0,y0,computer); return 1; case 2: case 3: old_judge=judge; judge=4; qz[x0][y0]=computer; r2=goon(x,y,player,computer,0); qz[x0][y0]=0; judge=old_judge; if(r2==1) break; drawcircle(x0,y0,computer); return 1; case 4: case 5: case 6: drawcircle(x0,y0,computer); return 1; default: printf("error in keepgo()"); break; } mask=mask>>4; }//end while if(max>=0) { drawcircle(max_x,max_y,computer); return 1; } mask=keep[j]; while(mask!=0) { d=(mask&0x000f)-1; x0=bx+d*dx; y0=by+d*dy; r1=ifgook(x0,y0,computer,player); temp=power(x0,y0,player); if(temp>max&&r1!=-1) { max=temp; max_x=x0; max_y=y0; } mask=mask>>4; } if(max>=0) { drawcircle(max_x,max_y,computer); return 1; } } //end if } //end for return 0; } char many(int x,int y) { int l,t,r,d; int num=0,id=0; l=(x-2>0)?x-2:0; t=(y-2>0)?y-2:0; r=(x+2>14)?14:x+2; d=(y+2>14)?14:y+2; if(x-1>=l&&y-1>=t) { if(qz[x-1][y-1]==0) { num++; if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==0) ; else if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==computer) num++; else num--; } else if(qz[x-1][y-1]==computer) { id=1; num+=2; if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==0) num++; else if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(y-1>=t) { if(qz[x][y-1]==0) { num++; if(y-2>=t&&qz[x][y-2]==0) ; else if(y-2>=t&&qz[x][y-2]==computer) num++; else num--; } else if(qz[x][y-1]==computer) { id=1; num+=2; if(y-2>=t&&qz[x][y-2]==0) num++; else if(y-2>=t&&qz[x][y-2]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(x+1<=r&&y-1>=t) { if(qz[x+1][y-1]==0) { num++; if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==0) ; else if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==computer) num++; else num--; } else if(qz[x+1][y-1]==computer) { id=1; num+=2; if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==0) num++; else if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(x-1>=l) { if(qz[x-1][y]==0) { num++; if(x-2>=l&&qz[x-2][y]==0) ; else if(x-2>=l&&qz[x-2][y]==computer) num++; else num--; } else if(qz[x-1][y]==computer) { id=1; num+=2; if(x-2>=l&&qz[x-2][y]==0) num++; else if(x-2>=l&&qz[x-2][y]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(x-1>=l&&y+1<=d) { if(qz[x-1][y+1]==0) { num++; if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==0) ; else if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==computer) num++; else num--; } else if(qz[x-1][y+1]==computer) { id=1; num+=2; if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==0) num++; else if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(y+1<=d) { if(qz[x][y+1]==0) { num++; if(y+2<=d&&qz[x][y+2]==0) ; else if(y+2<=d&&qz[x][y+2]==0) num++; else num--; } else if(qz[x][y+1]==computer) { id=1; num+=2; if(y+2<=d&&qz[x][y+2]==0) num++; else if(y+2<=d&&qz[x][y+2]==0) num+=2; else num--; } else num-=2; } else num-=2; if(x+1<=r&&y+1<=d) { if(qz[x+1][y+1]==0) { num++; if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==0) ; else if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==computer) num++; else num--; } else if(qz[x+1][y+1]==computer) { id=1; num+=2; if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==0) num++; else if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(x+1<=r) { if(qz[x+1][y]==0) { num++; if(x+2<=r&&qz[x+2][y]==0) ; else if(x+2<=r&&qz[x+2][y]==computer) num++; else num--; } else if(qz[x+1][y]==computer) { id=1; num+=2; if(x+2<=r&&qz[x+2][y]==0) num++; else if(x+2<=r&&qz[x+2][y]==computer) num+=2; else num--; } else num-=2; } else num-=2; if (id==1) return num; else return -1; } char power(int x,int y,char color) { int l,t,r,d,num; l=(x-2>0)?x-2:0; t=(y-2>0)?y-2:0; r=(x+2>14)?14:x+2; d=(y+2>14)?14:y+2; num=0; if(x-1>=l&&y-1>=t) if(qz[x-1][y-1]==color) { num+=2; if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==color) num+=2; else if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==0) num++; else num--; } else if(qz[x-1][y-1]==0) { num++; if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==color) num++; else if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==0) ; else num--; } //else num--; if(y-1>=t) if(qz[x][y-1]==color) { num+=2; if(y-2>=t&&qz[x][y-2]==color) num+=2; else if(y-2>=t&&qz[x][y-2]==0) num++; else num--; } else if(qz[x][y-1]==0) { num++; if(y-2>=t&&qz[x][y-2]==color) num++; else if(y-2>=t&&qz[x][y-2]==0) ; else num--; } //else num--; if(x+1<=r&&y-1>=t) if(qz[x+1][y-1]==color) { num+=2; if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==color) num+=2; else if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==0) num++; else num--; } else if(qz[x+1][y-1]==0) { num++; if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==color) num++; else if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==0) ; else num--; } //else num--; if(x-1>=l) if(qz[x-1][y]==color) { num+=2; if(x-2>=l&&qz[x-2][y]==color) num+=2; else if(x-2>=l&&qz[x-2][y]==0) num++; else num--; } else if(qz[x-1][y]==0) { num++; if(x-2>=l&&qz[x-2][y]==color) num++; else if(x-2>=l&&qz[x-2][y]==0) ; else num--; } //else num--; if(x-1>=l&&y+1<=d) if(qz[x-1][y+1]==color) { num+=2; if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==color) num+=2; else if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==0) num++; else num--; } else if(qz[x-1][y+1]==0) { num++; if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==color) num++; else if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==0) ; else num--; } //else num--; if(y+1<=d) if(qz[x][y+1]==color) { num+=2; if(y+2<=d&&qz[x][y+2]==color) num+=2; else if(y+2<=d&&qz[x][y+2]==0) num++; else num--; } else if(qz[x][y+1]==0) { num++; if(y+2<=d&&qz[x][y+2]==color) num++; else if(y+2<=d&&qz[x][y+2]==0) ; else num--; } //else num--; if(x+1<=r&&y+1<=d) if(qz[x+1][y+1]==color) { num+=2; if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==color) num+=2; else if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==0) num++; else num--; } else if(qz[x+1][y+1]==0) { num++; if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==color) num++; else if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==0) ; else num--; } //else num--; if(x+1<=r) if(qz[x+1][y]==color) { num+=2; if(x+2<=r&&qz[x+2][y]==color) num+=2; else if(x+2<=r&&qz[x+2][y]==0) num++; else num--; } else if(qz[x+1][y]==0) { num++; if(x+2<=r&&qz[x+2][y]==color) num++; else if(x+2<=r&&qz[x+2][y]==0) ; else num--; } //else num--; return num; } ///////////////////////five.c//////////////////////////////////////// char lose[4]= {27,12,35,47}; char lose2[6]= {41,42,27,12,35,47}; char win[4]= {27,34,35,47}; char str1[6]= {27,28,32,33,31,48}; char gamego[8]= {27,28,37,43,44,45,31,48}; extern unsigned int step; void p(void) { int i,j; for(i=0; i<15; i++) { for(j=0; j<15; j++) printf("%d",qz[j][i]); } } void init(void) { drawline(); old_x=7; old_y=7; setbit(7,7); } void drawline() { int j; char str[2]; char string[3]; setfillstyle(1,14); setcolor(9); str[1]='\0'; string[2]='\0'; dc=(HANDLE)GetProperty(img,"dc",0,0,0); SetTextColor(dc,0xff00); SetBkColor(dc,0); for(j=0; j<15; j++) { line(X0+SIZE*(j),Y0,X0+SIZE*(j),Y0+SIZE*14); line(X0,Y0+SIZE*(j),X0+SIZE*14,Y0+SIZE*(j)); if(j>=9) { string[0]='1'; string[1]='0'+j-9; } else { string[0]='1'+j; string[1]='\0'; } outtextxy(X0-16,Y0+SIZE*j-7,string); str[0]='A'+j; outtextxy(X0+SIZE*j-3,Y0-15,str); } } char getkey() { int key,ok=0; int f,oldx,oldy; int can1,can2; while(1) { if(needclose) { printf("exit getkey"); return 0; } Wait(1); if(bioskey(1)==1) { key=bioskey(0); if(key!=ENTER) { switch(key) { case LEFT: printf("left0 kx:%d,ky:%d",kx,ky); kx=(kx==0)?0:--kx; printf("left1 kx:%d,ky:%d",kx,ky); setbit(kx,ky); break; /*left*/ case RIGHT: kx=(kx==14)?14:++kx; setbit(kx,ky); break; /*right*/ case UP: ky=(ky==0)?0:--ky; setbit(kx,ky); break; /*up*/ case DOWN: ky=(ky==14)?14:++ky; setbit(kx,ky);; break; /*down*/ case ESC: return 0x10; break; case 'r': case 'R': return 0x11; default: break; } } else ok=1; } if(oldx!=kx||oldy!=ky) { oldx=kx; oldy=ky; } /**/ if((mx>X0-SIZE/2)&&(my>Y0-SIZE/2)) if((mx<X0+SIZE*14.5)&&(my<Y0+SIZE*14.5)) { printf("check mouse down,x:%d,y:%d",mx,my); //readmouse(&f,&mx,&my); can1=(mx-X0)%SIZE; can2=(my-Y0)%SIZE; if(can1<=(SIZE/2)) kx=(mx-X0)/SIZE; else kx=(mx-X0)/SIZE+1; if(can2<=(SIZE/2)) ky=(my-Y0)/SIZE; else ky=(my-Y0)/SIZE+1; mx=0; my=0; f=1; } if(f==1) ok=1; if(ok==1) { char result; result=ifgook(kx,ky,player,computer); player_x=kx; player_y=ky; if(qz[kx][ky]==0) { drawcircle(kx,ky,player); return result; } if(qz[kx][ky]==0&&result==-1) return result; ok=0; } } } void drawcircle(int x,int y,char color) { int i; int l,r,d,t; qz[x][y]=color; color--; active[x][y][0]=0; active[x][y][1]=0; l=(x-2>0)?x-2:0; t=(y-2>0)?y-2:0; r=(x+2>14)?14:x+2; d=(y+2>14)?14:y+2; if(x-1>=l&&y-1>=t) if(qz[x-1][y-1]==0) { active[x-1][y-1][color]=1; if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==0) active[x-2][y-2][color]=1; } if(y-1>=t) if(qz[x][y-1]==0) { active[x][y-1][color]=1; if(y-2>=t&&qz[x][y-2]==0) active[x][y-2][color]=1; } if(x+1<=r&&y-1>=t) if(qz[x+1][y-1]==0) { active[x+1][y-1][color]=1; if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==0) active[x+2][y-2][color]=1; } if(x-1>=l) if(qz[x-1][y]==0) { active[x-1][y][color]=1; if(x-2>=l&&qz[x-2][y]==0) active[x-2][y][color]=1; } if(x-1>=l&&y+1<=d) if(qz[x-1][y+1]==0) { active[x-1][y+1][color]=1; if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==0) active[x-2][y+2][color]=1; } if(y+1<=d) if(qz[x][y+1]==0) { active[x][y+1][color]=1; if(y+2<=d&&qz[x][y+2]==0) active[x][y+2][color]=1; } if(x+1<=r&&y+1<=d) if(qz[x+1][y+1]==0) { active[x+1][y+1][color]=1; if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==0) active[x+2][y+2][color]=1; } if(x+1<=r) if(qz[x+1][y]==0) { active[x+1][y][color]=1; if(x+2<=r&&qz[x+2][y]==0) active[x+2][y][color]=1; } if(y+1<=d) if(qz[x][y+1]==0) { active[x][y+1][color]=1; if(y+2<=d&&qz[x][y+2]==0) active[x][y+2][color]=1; } if(l<left) left=l; if(r>right) right=r; if(t<top) top=t; if(d>down) down=d; drawcross(old_x,old_y); color=(color==0)?0:15; setcolor(0); setfillstyle(1,color); circle(X0+SIZE*x,Y0+SIZE*y,Radius); setcolor(color^0xff); dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush; if(color==0) { setcolor(16); brush=CreateSolidBrush(0xffff); } else { setcolor(10); brush=CreateSolidBrush(0xffff00); } SelectObject(dc,brush); ellipse(X0+SIZE*x,Y0+SIZE*y,90+(1-color)*180,180+(1-color)*180,Radius-2,Radius-2); DeleteObject( brush); drawcross(x,y); old_x=x; old_y=y; setbit(x,y); } void drawcross(int x,int y) { setcolor(2); line(X0+SIZE*x-6,Y0+SIZE*y,X0+SIZE*x+6,Y0+SIZE*y); line(X0+SIZE*x,Y0+SIZE*y-6,X0+SIZE*x,Y0+SIZE*y+6); } void setbit(int x,int y) { int mx,my; mx=X0+SIZE*x; my=Y0+SIZE*y; printf("setbit,x:%d,y:%d",x,y); setmousecoord(mx,my); } unsigned condition[2][11]= { { 0x0054, 0x0150, 0x0144, 0x0114, 0x0555, 0x0154, 0x0151, 0x0145, 0x0115, 0x0055, 0x0155 }, { 0x00a8, 0x02a0, 0x0288, 0x0228, 0x0aaa, 0x02a8, 0x02a2, 0x028a, 0x022a, 0x00aa, 0x02aa } }; int compare(unsigned input,int len,char color); void attrib(int x,int y,QCL *pl,char color1,char color2) { int h,i,j,dx,dy,k1,k2,k,num,rang1,rang2; register int temp; pl->p[0]=-1; pl->p[1]=-1; pl->p[2]=-1; pl->p[3]=-1; pl->l[0]=0; pl->l[1]=0; pl->l[2]=0; pl->l[3]=0; for(i=0; i<4; i++) { k1=1; k2=1; num=1; switch(i) { case 0: dx=0; dy=1; rang1=(y>4)?4:y; rang2=(14-y>4)?4:14-y; break; case 1: dx=1; dy=1; rang1=(x<y)?x:y; rang1=(rang1>4)?4:rang1; rang2=(x>y)?x:y; rang2=(14-rang2>4)?4:14-rang2; break; case 2: dx=1; dy=0; rang1=(x>4)?4:x; rang2=(14-x>4)?4:14-x; break; case 3: dx=1; dy=-1; rang1=(x<14-y)?x:14-y; rang1=(rang1>4)?4:rang1; rang2=(14-x<y)?14-x:y; rang2=(rang2>4)?4:rang2; break; } while(k1<=rang1) { temp=qz[x-k1*dx][y-k1*dy]; if(temp==0&&k1+1<=rang1&&qz[x-(k1+1)*dx][y-(k1+1)*dy]==0) { k1+=2; break; } k1++; if(temp==color2) break; if(temp==color1) num++; } k1--; while(k2<=rang2) { temp=qz[x+k2*dx][y+k2*dy]; if(temp==0&&k2+1<=rang2&&qz[x+(k2+1)*dx][y+(k2+1)*dy]==0) { k2+=2; break; } k2++; if(temp==color2) break; if(temp==color1) num++; } k=k1+k2; if(k>4) { int m,n,back; unsigned swap=0,swap1; for(m=0; m<5; m++) swap=swap|(qz[x-(k1-m)*dx][y-(k1-m)*dy]<<(m<<1)); swap1=swap; switch(num) { case 3: if(k>5) { for(n=m; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<10); back=compare(swap1,6,color1); if(back>=0) { pl->p[i]=back; pl->l[i]=3; pl->d[i]=k1-(n-m); break; } swap1=swap1>>2; } } if(pl->p[i]>=0) continue; break; case 4: for(n=m-1; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<8); back=compare(swap1,5,color1); if(back>=0) { pl->p[i]=back; pl->l[i]=4; pl->d[i]=k1-(n-m)-1; break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; break; case 5: for(n=m-1; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<8); if(swap1==condition[color1-1][10]) { pl->p[i]=10; pl->l[i]=5; pl->d[i]=k1-(n-m)-1; break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; break; case 7: case 8: case 9: case 6: for(n=m; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<10); if(swap1==condition[color1-1][4]) { pl->p[i]=4; pl->l[i]=6; pl->d[i]=k1-(n-m); break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; swap1=swap; for(n=m-1; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<8); if(swap1==condition[color1-1][10]) { pl->p[i]=10; pl->l[i]=5; pl->d[i]=k1-(n-m)-1; break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; for(n=m-1; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<8); back=compare(swap1,5,color1); if(back>=0) { pl->p[i]=back; pl->l[i]=4; pl->d[i]=k1-(n-m)-1; break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; swap1=swap; for(n=m; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<10); back=compare(swap1,6,color1); if(back>=0) { pl->p[i]=back; pl->l[i]=3; pl->d[i]=k1-(n-m); break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; break; default: break; } } } } int compare(unsigned input,int len,char color) { int i; color--; switch(len) { case 5: for(i=5; i<10; i++) if(input==condition[color][i]) return i; return -1; case 6: for(i=0; i<4; i++) if(input==condition[color][i]) return i; return -1; default: printf("error len in compare\n"); break; } } ///////////////////////////////////////////////////////////// void OnMouseDown(int id,int btn,int state,int x,int y) { mx=x; my=y; printf("mouse down,x:%d,y:%d",mx,my); } void OnClose() { printf("need close..."); needclose=1; Wait(1); } void InitGraph() { HideLeftTools(); ClearVclControls(); //ShowVclWin(200); HideVclWin(200); //p=GetGuiWin(0); pfm=CreateComponentEx(0,"form","caption","五子棋","Width",430,"height",480,"BorderIcons","[]","position","poMainFormCenter","formstyle","fsstayontop","OnKeyDown",OnKeyDown,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] //CreateComponentEx(p,"timer","interval",40,"enabled",1,"ontimer",OnTimer,NULL);//创建按钮 CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",60,"height",20,"OnClick",OnClose,0); img=CreateComponentEx(pfm,"Image","left",10,"top",40,"width",400,"height",400,"OnMouseDown",OnMouseDown,0); //ms=CreateComponentEx(pfm,"label","caption","X","left", 0,"top", 0,"width",20,"height",20,0); SetProperty(pfm,"visible",1); RECT rect= {0,0,640,480}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0x0000); SelectObject(dc,brush); FillRect(dc,&rect,brush); DeleteObject(brush); } void main(void) { int i; char who,END=0; int result,temp; InitGraph(); while(!END) { SetProperty(pfm,"caption","五子棋"); if(needclose) { CloseForm(pfm); return; } who=1; reset(); printf("game init..............."); RECT rect= {0,0,640,480}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0x0000); SelectObject(dc,brush); FillRect(dc,&rect,brush); DeleteObject(brush); game_init(); Invalidate(img); if(MessageBox(GetFormHandle(pfm),"你想先手吗？","开始下棋",4)==6 ) player=2; else player=1; mx=0; my=0; computer=(player==1)?2:1; step=0; //drawcircle(7,7,1); SetProperty(pfm,"caption","五子棋-轮到您走棋"); temp=0; result=0; while(1) { set(who+1); if(who==player-1) { printf("player go"); SetProperty(pfm,"caption","五子棋-轮到您走棋"); temp=player_go(); } else { printf("computer go"); SetProperty(pfm,"caption","五子棋-轮到计算机走棋"); result=computer_go(temp); } if(needclose) { printf("exit go"); CloseForm(pfm); return; } printf("temp:%d,result:%d",temp,result); if(temp==1||result==-1) { set(0); MessageBox(GetFormHandle(pfm),"未知! ","本局结束",0); if(needclose) return; mx=0; my=0; break; } if(temp==-1) { set(0); MessageBox(GetFormHandle(pfm),"您赢了! ","本局结束",0); if(needclose) return; mx=0; my=0; break; } if(result==1) { printf("result==1"); set(0); MessageBox(GetFormHandle(pfm),"计算机赢了! ","本局结束",0); if(needclose) return; mx=0; my=0; break; } if(temp==0x10) { END=1; break; } if(temp==0x11) break; who^=1; } } }" /> 
  <Command cmdname="五子棋-页面显示" cmdType="P" cmd="[P]#include "windows.h" #include "stdio.h" #include "conio.h" #define SIZE 24 #define X0 30 #define Y0 30 #define Radius 16 #define TRUE 1 #include "stdio.h" #include "dos.h" #include "conio.h" #include "stdlib.h" #define LEFT 37 #define RIGHT 39 #define DOWN 40 /*此键为加速键*/ #define UP 38 /*此键为变形键*/ #define ESC 27 /*此键为退出键*/ #define ENTER 13 #define DEPTH 14 //递归深度，棋力 int player_x,player_y; int kx=7,ky=7; int old_x,old_y; char back[6]= {27,28,25,26,31,48}; int pfm; void graph_init(); void drawline(); char getkey(); void drawcircle(int ,int ,char); void drawcross(int,int); void setbit(int,int); int needclose=0; int KeyDown=0; HPEN pen=0; int img; HANDLE dc; int ms; int mx,my; void setcolor(int cl) { cl*=0xfffff; dc=(HANDLE)GetProperty(img,"dc",0,0,0); if(pen!=0) DeleteObject(pen); pen=CreatePen(PS_SOLID,1,cl); SelectObject(dc,pen); } int bioskey(int flat) { int tmp; if(flat==1) { if(KeyDown!=0) return 1; else return 0; } tmp=KeyDown; KeyDown=0; return tmp; } void putpixel(int x,int y,int cl) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); SetPixel(dc,x,y,cl*0xfffff); } void settextstyle(int a,int b,int c) { } void outtextxy(int x,int y,char *s) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); TextOutA(dc,x,y,s,strlen(s)); } void line(int x0,int y0,int x1,int y1) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); MoveToEx(dc,x0,y0,0); LineTo(dc,x1,y1); } void rectangle(int x0,int y0,int x1,int y1) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); MoveToEx(dc,x0,y0,0); LineTo(dc,x1,y0); LineTo(dc,x1,y1); LineTo(dc,x0,y1); LineTo(dc,x0,y0); } void circle(int x,int y,int r) { rectangle(x-r/2,y-r/2,x+r/2,y+r/2); } void setmousecoord(int x,int y) { RECT rect; x+=10; y+=40; rect.left=x-10; rect.top=y-10; rect.right=x+10; rect.bottom=y+10; InvalidateRect(GetFormHandle(pfm),&rect,0); UpdateWindow(GetFormHandle(pfm)); } void setfillstyle(int m1,int m2) { } void ellipse(int x0,int y0,int start,int end,int r0,int r1) { dc=(HANDLE)GetProperty(img,"dc",0,0,0); Ellipse(dc,x0-r0/2,y0-r1/2,x0+r0/2,y0+r1/2); } void OnKeyDown(int id,int *key,int state) { KeyDown=*key; } typedef struct struct1 { char p[4]; char l[4]; char d[4]; } QCL; QCL pos[15][15][2]; char all[15][15][2]; char keepgo(int,int,int,char,char,int,QCL); char goon(int,int,char,char,int); char ifgook(int,int,char,char); char computer_keep(int,int,int); void exit_game(); unsigned int step=0; unsigned keep[11]= { 0x0015, //011100 0x0062, //001110 0x0613, //010110 0x0614, //011010 0x0000, //111111 0x0001, //01111 0x0002, //10111 0x0003, //11011 0x0004, //11101 0x0005, //11110 0x0000 //11111 }; char judge; /*****************************/ /* return value */ /* -1 can not move */ /* 0 nothing */ /* 1 5,6 ready */ /* 2 3 ready */ /* 3 3,3 ready */ /* 4 4 ready */ /* 5 3,4 ready */ /* 6 4,4 ready */ /*****************************/ char computer_go(int) ; char many(int ,int); char power(int ,int ,char); /*****************************/ /* return value */ /* -1 lose the game */ /* 0 nothing happen */ /* 1 win the game */ /*****************************/ void active_init(void); void game_init(void); unsigned int left,top,right,down; unsigned char player,computer; QCL Glist; char active[15][15][2]; char qz[15][15]; #define LEN 252 #define COLOR 15 #define INTR 0X1C /* The clock tick interrupt */ #define X 98 #define Y 10 char num[11][9]= { {0x7e,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7e},//0 {0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},//1 {0x7e,0x01,0x01,0x01,0x7e,0x80,0x80,0x80,0x7e},//2 {0x7e,0x01,0x01,0x01,0x7e,0x01,0x01,0x01,0x7e},//3 {0x81,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x01},//4 {0x7e,0x80,0x80,0x80,0x7e,0x01,0x01,0x01,0x7e},//5 {0x7e,0x80,0x80,0x80,0x7e,0x81,0x81,0x81,0x7e},//6 {0x7e,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},//7 {0x7e,0x81,0x81,0x81,0x7e,0x81,0x81,0x81,0x7e},//8 {0x7e,0x81,0x81,0x81,0x7e,0x01,0x01,0x01,0x7e},//9 {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}, }; #define COLOR 10 void text(int,int,char,int,char *); int count0=0,second0=0;/*computer's time*/ int count1=0,second1=0;/*player's time*/ int check; void set(int che) { if(che>2) return; check=che; } void reset() { count0=0; count1=0; second0=0; second1=0; check=0; } void init(); void attrib(int x,int y,QCL *pl,char color1,char color2); void qz_init(); void game_init(void) { init(); active_init(); qz_init(); left=right=top=down=7; } void active_init(void) { int i,j; for(i=0; i<15; i++) for(j=0; j<15; j++) active[i][j][0]=active[i][j][1]=0; } void qz_init(void) { int i,j; for(i=0; i<15; i++) for(j=0; j<15; j++) qz[i][j]=0; } char computer_go(int len) { register int i,j; char result,temp1,temp2,temp3; int max,large; char max_x,max_y; //ShowMessage("Computer go"); step++; for(i=left; i<=right; i++) for(j=top; j<=down; j++) { all[i][j][computer-1]=ifgook(i,j,computer,player); pos[i][j][computer-1]=Glist; all[i][j][player-1]=ifgook(i,j,player,computer); pos[i][j][player-1]=Glist; } for(i=left; i<=right; i++) for(j=top; j<=down; j++) if(all[i][j][computer-1]==1) { drawcircle(i,j,computer); return 1; } for(i=left; i<=right; i++) for(j=top; j<=down; j++) if(all[i][j][player-1]==1) { if(all[i][j][computer-1]!=-1) { drawcircle(i,j,computer); return 0; } else return -1; } large=-1; judge=4; if(len==3) { for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(active[i][j][computer-1]==1) { switch(all[i][j][computer-1]) { case -1: break; case 0: break; case 6: case 1: drawcircle(i,j,computer); return 1; case 2: case 3: break; case 5: qz[i][j]=computer; temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { drawcircle(i,j,computer); return 0; } break; case 4: temp3=power(i,j,computer); if(temp3<=large) break; qz[i][j]=computer; temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { large=temp3; max_x=i; max_y=j; } break; default: printf("error if computer_go()."); } } } if(large>=0) { drawcircle(max_x,max_y,computer); return 0; } result=computer_keep(player_x,player_y,3); if(result==1) return 0; } else { judge=4; large=-1; for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(active[i][j][computer-1]==1) { switch(all[i][j][computer-1]) { case -1: break; case 0: break; case 6: case 1: drawcircle(i,j,computer); return 1; case 2: case 3: break; case 5: qz[i][j]=computer; temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { drawcircle(i,j,computer); return 0; } break; case 4: temp3=power(i,j,computer); if(temp3<=large) break; qz[i][j]=computer; temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { large=temp3; max_x=i; max_y=j; } break; default: printf("error if computer_go()."); } } } if(large>=0) { drawcircle(max_x,max_y,computer); return 0; } } large=-1; judge=4; for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(active[i][j][player-1]==1) { temp1=all[i][j][computer-1]; switch(all[i][j][player-1]) { case -1: break; case 0: break; case 6: case 1: if(temp1!=-1) { drawcircle(i,j,computer); return 0; } break; case 2: case 3: break; case 5: if(temp1!=-1) { qz[i][j]=player; temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]); qz[i][j]=0; if(temp2==-1) { drawcircle(i,j,computer); return 0; } } break; case 4: if(temp1!=-1) { temp3=power(i,j,player); if(temp3<=large) break; qz[i][j]=player; temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]); qz[i][j]=0; if(temp2==-1) { large=temp3; max_x=i; max_y=j; } } break; default: printf("error if player_go()."); } } } if(large>=0) { drawcircle(max_x,max_y,computer); return 0; } judge=3; large=-1; for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(active[i][j][computer-1]==1) { switch(all[i][j][computer-1]) { case -1: break; case 0: break; case 6: case 5: drawcircle(i,j,computer); return 0; case 1: drawcircle(i,j,computer); return 1; case 2: case 3: temp3=power(i,j,computer); if(temp3<=large) break; qz[i][j]=computer; temp1=keepgo(i,j,3,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { large=temp3; max_x=i; max_y=j; } break; case 4: temp3=power(i,j,computer); if(temp3<=large) break; qz[i][j]=computer; temp1=keepgo(i,j,4,player,computer,0,pos[i][j][computer-1]); qz[i][j]=0; if(temp1==-1) { large=temp3; max_x=i; max_y=j; } break; default: printf("error if player_go()."); } } } if(large>=0) { drawcircle(max_x,max_y,computer); return 0; } large=-1; judge=3; for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(active[i][j][player-1]==1) { temp1=all[i][j][computer-1]; switch(all[i][j][player-1]) { case -1: break; case 0: break; case 6: case 5: case 1: if(temp1!=-1) { drawcircle(i,j,computer); return 0; } break; case 3: if(temp1!=-1) { qz[i][j]=player; temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]); qz[i][j]=0; if(temp2!=1) { drawcircle(i,j,computer); return 0; } } break; case 2: if(temp1!=-1) { temp3=power(i,j,player); if(temp3<=large) break; qz[i][j]=player; temp2=keepgo(i,j,3,computer,player,0,pos[i][j][player-1]); qz[i][j]=0; if(temp2!=1) { large=temp3; max_x=i; max_y=j; } } break; case 4: if(temp1!=-1) { temp3=power(i,j,player); if(temp3<=large) break; qz[i][j]=player; temp2=keepgo(i,j,4,computer,player,0,pos[i][j][player-1]); qz[i][j]=0; if(temp2==-1) { large=temp3; max_x=i; max_y=j; } } break; default: printf("error if player_go()."); } } } if(large>=0) { drawcircle(max_x,max_y,computer); return 0; } max=-1; max_x=6; max_y=7; if(computer==2&&step<=5) { for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(all[i][j][0]>0&&all[i][j][1]>0) { temp1=power(i,j,1); if(temp1>max) { max=temp1; max_x=i; max_y=j; } else if(temp1==max&&power(max_x,max_y,computer)<power(i,j,computer)) { max_x=i; max_y=j; } } } if(max>=0) { drawcircle(max_x,max_y,computer); return 0; } for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(all[i][j][computer-1]!=-1) { temp1=power(i,j,1); if(temp1>max) { max=temp1; max_x=i; max_y=j; } } } if(max>=0) { drawcircle(max_x,max_y,computer); return 0; } } if(computer==1&&step<=5) { for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(all[i][j][computer-1]!=-1&&active[i][j][computer-1]==1&&all[i][j][player-1]>0) { temp1=power(i,j,computer); if(temp1>max) { max=temp1; max_x=i; max_y=j; } else if(temp1==max&&power(max_x,max_y,player)<power(i,j,player)) { max_x=i; max_y=j; } } } if(max>=0) { drawcircle(max_x,max_y,computer); return 0; } } for(i=left; i<=right; i++) for(j=top; j<=down; j++) { if(qz[i][j]==0&&all[i][j][computer-1]!=-1) { temp1=many(i,j); if(temp1>max) { max=temp1; max_x=i; max_y=j; } } } drawcircle(max_x,max_y,computer); return 0; } char player_go() { char result; result=getkey(); if(needclose) { printf("exit player go"); return 0; } switch(result) { case 0: return 0; case -1: return -1; case 1: return 1; case 3: case 2: return 3; case 4: case 5: case 6: return 4; default: return result; } } char ifgook(int x,int y,char color1,char color2) { register int i; int k3=0,k4=0; if(qz[x][y]!=0) return -1; qz[x][y]=color1; attrib(x,y,&Glist,color1,color2); qz[x][y]=0; for(i=0; i<4; i++) { if(Glist.p[i]>=0&&Glist.p[i]<=3) k3++; else if(Glist.p[i]==10) return 1; /* there is five .*/ else if(Glist.p[i]<10&&Glist.p[i]>=5) k4++; if(Glist.p[i]==4&&color1==1) return -1; if(Glist.p[i]==4&&color1==2) return 1; } if(k4>1) { if(color1==1) return -1; else return 6; } if(k3>1&&color1==1) return -1; if(k3==1&&k4==1) return 5; /* case a 3 and a 4 */ if(k3>1) return 3; if(k4==1) return 4 ; /* case a 4 */ if(k3==1) return 2 ; /* case a 3 */ return 0; } char keepgo(int x,int y,int len,char color1,char color2,int depth,QCL list) { int dx,dy,x0,y0; int i,bx,by,mask,d,r0,r1,r2; char old_judge; if(depth>=DEPTH) return -1; else depth++; for(i=0; i<4; i++) { switch(i) { case 0: dx=0; dy=1; break; case 1: dx=1; dy=1; break; case 2: dx=1; dy=0; break; case 3: dx=1; dy=-1; break; } if(list.l[i]==len) { int j; j=list.p[i]; bx=x-dx*list.d[i]; by=y-dy*list.d[i]; mask=keep[j]; while(mask!=0) { d=(mask&0x000f)-1; x0=bx+d*dx; y0=by+d*dy; r1=ifgook(x0,y0,color1,color2); switch(r1) { case -1: break; case 0: if(judge==4||judge==5) { qz[x0][y0]=color1; r2=goon(x,y,color2,color1,depth); qz[x0][y0]=0; if(r2==1) break; else return 1; } if(judge==3) { judge=4; qz[x0][y0]=color1; r2=goon(x0,y0,color1,color2,depth); judge=3; if(r2==1) judge=4; r2=goon(x,y,color2,color1,depth); qz[x0][y0]=0; judge=3; if(r2==1) break; else return 1; } case 2: case 3: old_judge=judge; if(judge==3) judge=4; qz[x0][y0]=color1; r2=goon(x,y,color2,color1,depth); qz[x0][y0]=0; judge=old_judge; if(r2==1) break; else return 1; case 1: return 1; case 4: case 5: case 6: old_judge=judge; if(judge==3||judge==4) judge=5; qz[x0][y0]=color1; r2=goon(x,y,color2,color1,depth); qz[x0][y0]=0; judge=old_judge; if(r2==1) break; else return 1; default: printf("error in keepgo()"); break; } mask=mask>>4; } } } return -1; } char goon(int x,int y,char color1,char color2,int depth) { int i,dx,dy,k1,k2,rang1,rang2,temp; int nx,ny; char r1,r2; for(i=0; i<4; i++) { k1=1; k2=1; switch(i) { case 0: dx=0; dy=1; rang1=(y>4)?4:y; rang2=(14-y>4)?4:14-y; break; case 1: dx=1; dy=1; rang1=(x<y)?x:y; rang1=(rang1>4)?4:rang1; rang2=(x>y)?x:y; rang2=(14-rang2>4)?4:14-rang2; break; case 2: dx=1; dy=0; rang1=(x>4)?4:x; rang2=(14-x>4)?4:14-x; break; case 3: dx=1; dy=-1; rang1=(x<14-y)?x:14-y; rang1=(rang1>4)?4:rang1; rang2=(14-x<y)?14-x:y; rang2=(rang2>4)?4:rang2; break; } while(k1<=rang1) { nx=x-k1*dx; ny=y-k1*dy; temp=qz[nx][ny]; k1++; if(temp==0) { r1=ifgook(nx,ny,color1,color2); switch(r1) { case -1: case 0: break; case 1: return 1; case 2: case 3: if(judge!=3) break; qz[nx][ny]=color1; r2=keepgo(nx,ny,3,color2,color1,depth,Glist); qz[nx][ny]=0; if(r2==-1) return 1; break; case 6: case 5: case 4: if(judge==5) break; qz[nx][ny]=color1; r2=keepgo(nx,ny,4,color2,color1,depth,Glist); qz[nx][ny]=0; if(r2==-1) return 1; break; } } if(temp==color2) break; } while(k2<=rang2) { nx=x+k2*dx; ny=y+k2*dy; temp=qz[nx][ny]; k2++; if(temp==0) { r1=ifgook(nx,ny,color1,color2); switch(r1) { case -1: case 0: break; case 1: return 1; case 2: case 3: if(judge!=3) break; qz[nx][ny]=color1; r2=keepgo(nx,ny,3,color2,color1,depth,Glist); qz[nx][ny]=0; if(r2==-1) return 1; break; case 5: case 6: case 4: if(judge==5) break; qz[nx][ny]=color1; r2=keepgo(nx,ny,4,color2,color1,depth,Glist); qz[nx][ny]=0; if(r2==-1) return 1; break; } } if(temp==color2) break; } } return -1; } char computer_keep(int x,int y,int len) { int dx,dy,x0,y0; int i,j,bx,by,mask,d,r1,r2; int temp; char old_judge; int max=-1,max_x,max_y; QCL list; attrib(x,y,&list,player,computer); judge=3; for(i=0; i<4; i++) { switch(i) { case 0: dx=0; dy=1; break; case 1: dx=1; dy=1; break; case 2: dx=1; dy=0; break; case 3: dx=1; dy=-1; break; } if(list.l[i]==len) { j=list.p[i]; bx=x-dx*list.d[i]; by=y-dy*list.d[i]; mask=keep[j]; while(mask!=0) { d=(mask&0x000f)-1; x0=bx+d*dx; y0=by+d*dy; r1=ifgook(x0,y0,computer,player); switch(r1) { case -1: break; case 0: old_judge=judge; judge=4; qz[x0][y0]=computer; r2=goon(x0,y0,computer,player,0); if(r2==-1) judge=3; r2=goon(x,y,player,computer,0); qz[x0][y0]=0; judge=old_judge; if(r2==1) break; r2=power(x0,y0,1); if(max<r2) { max=r2; max_x=x0; max_y=y0; } break; case 1: drawcircle(x0,y0,computer); return 1; case 2: case 3: old_judge=judge; judge=4; qz[x0][y0]=computer; r2=goon(x,y,player,computer,0); qz[x0][y0]=0; judge=old_judge; if(r2==1) break; drawcircle(x0,y0,computer); return 1; case 4: case 5: case 6: drawcircle(x0,y0,computer); return 1; default: printf("error in keepgo()"); break; } mask=mask>>4; }//end while if(max>=0) { drawcircle(max_x,max_y,computer); return 1; } mask=keep[j]; while(mask!=0) { d=(mask&0x000f)-1; x0=bx+d*dx; y0=by+d*dy; r1=ifgook(x0,y0,computer,player); temp=power(x0,y0,player); if(temp>max&&r1!=-1) { max=temp; max_x=x0; max_y=y0; } mask=mask>>4; } if(max>=0) { drawcircle(max_x,max_y,computer); return 1; } } //end if } //end for return 0; } char many(int x,int y) { int l,t,r,d; int num=0,id=0; l=(x-2>0)?x-2:0; t=(y-2>0)?y-2:0; r=(x+2>14)?14:x+2; d=(y+2>14)?14:y+2; if(x-1>=l&&y-1>=t) { if(qz[x-1][y-1]==0) { num++; if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==0) ; else if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==computer) num++; else num--; } else if(qz[x-1][y-1]==computer) { id=1; num+=2; if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==0) num++; else if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(y-1>=t) { if(qz[x][y-1]==0) { num++; if(y-2>=t&&qz[x][y-2]==0) ; else if(y-2>=t&&qz[x][y-2]==computer) num++; else num--; } else if(qz[x][y-1]==computer) { id=1; num+=2; if(y-2>=t&&qz[x][y-2]==0) num++; else if(y-2>=t&&qz[x][y-2]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(x+1<=r&&y-1>=t) { if(qz[x+1][y-1]==0) { num++; if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==0) ; else if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==computer) num++; else num--; } else if(qz[x+1][y-1]==computer) { id=1; num+=2; if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==0) num++; else if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(x-1>=l) { if(qz[x-1][y]==0) { num++; if(x-2>=l&&qz[x-2][y]==0) ; else if(x-2>=l&&qz[x-2][y]==computer) num++; else num--; } else if(qz[x-1][y]==computer) { id=1; num+=2; if(x-2>=l&&qz[x-2][y]==0) num++; else if(x-2>=l&&qz[x-2][y]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(x-1>=l&&y+1<=d) { if(qz[x-1][y+1]==0) { num++; if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==0) ; else if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==computer) num++; else num--; } else if(qz[x-1][y+1]==computer) { id=1; num+=2; if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==0) num++; else if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(y+1<=d) { if(qz[x][y+1]==0) { num++; if(y+2<=d&&qz[x][y+2]==0) ; else if(y+2<=d&&qz[x][y+2]==0) num++; else num--; } else if(qz[x][y+1]==computer) { id=1; num+=2; if(y+2<=d&&qz[x][y+2]==0) num++; else if(y+2<=d&&qz[x][y+2]==0) num+=2; else num--; } else num-=2; } else num-=2; if(x+1<=r&&y+1<=d) { if(qz[x+1][y+1]==0) { num++; if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==0) ; else if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==computer) num++; else num--; } else if(qz[x+1][y+1]==computer) { id=1; num+=2; if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==0) num++; else if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==computer) num+=2; else num--; } else num-=2; } else num-=2; if(x+1<=r) { if(qz[x+1][y]==0) { num++; if(x+2<=r&&qz[x+2][y]==0) ; else if(x+2<=r&&qz[x+2][y]==computer) num++; else num--; } else if(qz[x+1][y]==computer) { id=1; num+=2; if(x+2<=r&&qz[x+2][y]==0) num++; else if(x+2<=r&&qz[x+2][y]==computer) num+=2; else num--; } else num-=2; } else num-=2; if (id==1) return num; else return -1; } char power(int x,int y,char color) { int l,t,r,d,num; l=(x-2>0)?x-2:0; t=(y-2>0)?y-2:0; r=(x+2>14)?14:x+2; d=(y+2>14)?14:y+2; num=0; if(x-1>=l&&y-1>=t) if(qz[x-1][y-1]==color) { num+=2; if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==color) num+=2; else if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==0) num++; else num--; } else if(qz[x-1][y-1]==0) { num++; if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==color) num++; else if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==0) ; else num--; } //else num--; if(y-1>=t) if(qz[x][y-1]==color) { num+=2; if(y-2>=t&&qz[x][y-2]==color) num+=2; else if(y-2>=t&&qz[x][y-2]==0) num++; else num--; } else if(qz[x][y-1]==0) { num++; if(y-2>=t&&qz[x][y-2]==color) num++; else if(y-2>=t&&qz[x][y-2]==0) ; else num--; } //else num--; if(x+1<=r&&y-1>=t) if(qz[x+1][y-1]==color) { num+=2; if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==color) num+=2; else if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==0) num++; else num--; } else if(qz[x+1][y-1]==0) { num++; if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==color) num++; else if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==0) ; else num--; } //else num--; if(x-1>=l) if(qz[x-1][y]==color) { num+=2; if(x-2>=l&&qz[x-2][y]==color) num+=2; else if(x-2>=l&&qz[x-2][y]==0) num++; else num--; } else if(qz[x-1][y]==0) { num++; if(x-2>=l&&qz[x-2][y]==color) num++; else if(x-2>=l&&qz[x-2][y]==0) ; else num--; } //else num--; if(x-1>=l&&y+1<=d) if(qz[x-1][y+1]==color) { num+=2; if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==color) num+=2; else if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==0) num++; else num--; } else if(qz[x-1][y+1]==0) { num++; if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==color) num++; else if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==0) ; else num--; } //else num--; if(y+1<=d) if(qz[x][y+1]==color) { num+=2; if(y+2<=d&&qz[x][y+2]==color) num+=2; else if(y+2<=d&&qz[x][y+2]==0) num++; else num--; } else if(qz[x][y+1]==0) { num++; if(y+2<=d&&qz[x][y+2]==color) num++; else if(y+2<=d&&qz[x][y+2]==0) ; else num--; } //else num--; if(x+1<=r&&y+1<=d) if(qz[x+1][y+1]==color) { num+=2; if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==color) num+=2; else if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==0) num++; else num--; } else if(qz[x+1][y+1]==0) { num++; if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==color) num++; else if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==0) ; else num--; } //else num--; if(x+1<=r) if(qz[x+1][y]==color) { num+=2; if(x+2<=r&&qz[x+2][y]==color) num+=2; else if(x+2<=r&&qz[x+2][y]==0) num++; else num--; } else if(qz[x+1][y]==0) { num++; if(x+2<=r&&qz[x+2][y]==color) num++; else if(x+2<=r&&qz[x+2][y]==0) ; else num--; } //else num--; return num; } ///////////////////////five.c//////////////////////////////////////// char lose[4]= {27,12,35,47}; char lose2[6]= {41,42,27,12,35,47}; char win[4]= {27,34,35,47}; char str1[6]= {27,28,32,33,31,48}; char gamego[8]= {27,28,37,43,44,45,31,48}; extern unsigned int step; void p(void) { int i,j; for(i=0; i<15; i++) { for(j=0; j<15; j++) printf("%d",qz[j][i]); } } void init(void) { drawline(); old_x=7; old_y=7; setbit(7,7); } void drawline() { int j; char str[2]; char string[3]; setfillstyle(1,14); setcolor(9); str[1]='\0'; string[2]='\0'; dc=(HANDLE)GetProperty(img,"dc",0,0,0); SetTextColor(dc,0xff00); SetBkColor(dc,0); for(j=0; j<15; j++) { line(X0+SIZE*(j),Y0,X0+SIZE*(j),Y0+SIZE*14); line(X0,Y0+SIZE*(j),X0+SIZE*14,Y0+SIZE*(j)); if(j>=9) { string[0]='1'; string[1]='0'+j-9; } else { string[0]='1'+j; string[1]='\0'; } outtextxy(X0-16,Y0+SIZE*j-7,string); str[0]='A'+j; outtextxy(X0+SIZE*j-3,Y0-15,str); } } char getkey() { int key,ok=0; int f,oldx,oldy; int can1,can2; while(1) { if(needclose) { printf("exit getkey"); return 0; } Wait(1); if(bioskey(1)==1) { key=bioskey(0); if(key!=ENTER) { switch(key) { case LEFT: printf("left0 kx:%d,ky:%d",kx,ky); kx=(kx==0)?0:--kx; printf("left1 kx:%d,ky:%d",kx,ky); setbit(kx,ky); break; /*left*/ case RIGHT: kx=(kx==14)?14:++kx; setbit(kx,ky); break; /*right*/ case UP: ky=(ky==0)?0:--ky; setbit(kx,ky); break; /*up*/ case DOWN: ky=(ky==14)?14:++ky; setbit(kx,ky);; break; /*down*/ case ESC: return 0x10; break; case 'r': case 'R': return 0x11; default: break; } } else ok=1; } if(oldx!=kx||oldy!=ky) { oldx=kx; oldy=ky; } /**/ if((mx>X0-SIZE/2)&&(my>Y0-SIZE/2)) if((mx<X0+SIZE*14.5)&&(my<Y0+SIZE*14.5)) { printf("check mouse down,x:%d,y:%d",mx,my); //readmouse(&f,&mx,&my); can1=(mx-X0)%SIZE; can2=(my-Y0)%SIZE; if(can1<=(SIZE/2)) kx=(mx-X0)/SIZE; else kx=(mx-X0)/SIZE+1; if(can2<=(SIZE/2)) ky=(my-Y0)/SIZE; else ky=(my-Y0)/SIZE+1; mx=0; my=0; f=1; } if(f==1) ok=1; if(ok==1) { char result; result=ifgook(kx,ky,player,computer); player_x=kx; player_y=ky; if(qz[kx][ky]==0) { drawcircle(kx,ky,player); return result; } if(qz[kx][ky]==0&&result==-1) return result; ok=0; } } } void drawcircle(int x,int y,char color) { int i; int l,r,d,t; qz[x][y]=color; color--; active[x][y][0]=0; active[x][y][1]=0; l=(x-2>0)?x-2:0; t=(y-2>0)?y-2:0; r=(x+2>14)?14:x+2; d=(y+2>14)?14:y+2; if(x-1>=l&&y-1>=t) if(qz[x-1][y-1]==0) { active[x-1][y-1][color]=1; if(x-2>=l&&y-2>=t&&qz[x-2][y-2]==0) active[x-2][y-2][color]=1; } if(y-1>=t) if(qz[x][y-1]==0) { active[x][y-1][color]=1; if(y-2>=t&&qz[x][y-2]==0) active[x][y-2][color]=1; } if(x+1<=r&&y-1>=t) if(qz[x+1][y-1]==0) { active[x+1][y-1][color]=1; if(x+2<=r&&y-2>=t&&qz[x+2][y-2]==0) active[x+2][y-2][color]=1; } if(x-1>=l) if(qz[x-1][y]==0) { active[x-1][y][color]=1; if(x-2>=l&&qz[x-2][y]==0) active[x-2][y][color]=1; } if(x-1>=l&&y+1<=d) if(qz[x-1][y+1]==0) { active[x-1][y+1][color]=1; if(x-2>=l&&y+2<=d&&qz[x-2][y+2]==0) active[x-2][y+2][color]=1; } if(y+1<=d) if(qz[x][y+1]==0) { active[x][y+1][color]=1; if(y+2<=d&&qz[x][y+2]==0) active[x][y+2][color]=1; } if(x+1<=r&&y+1<=d) if(qz[x+1][y+1]==0) { active[x+1][y+1][color]=1; if(x+2<=r&&y+2<=d&&qz[x+2][y+2]==0) active[x+2][y+2][color]=1; } if(x+1<=r) if(qz[x+1][y]==0) { active[x+1][y][color]=1; if(x+2<=r&&qz[x+2][y]==0) active[x+2][y][color]=1; } if(y+1<=d) if(qz[x][y+1]==0) { active[x][y+1][color]=1; if(y+2<=d&&qz[x][y+2]==0) active[x][y+2][color]=1; } if(l<left) left=l; if(r>right) right=r; if(t<top) top=t; if(d>down) down=d; drawcross(old_x,old_y); color=(color==0)?0:15; setcolor(0); setfillstyle(1,color); circle(X0+SIZE*x,Y0+SIZE*y,Radius); setcolor(color^0xff); dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush; if(color==0) { setcolor(16); brush=CreateSolidBrush(0xffff); } else { setcolor(10); brush=CreateSolidBrush(0xffff00); } SelectObject(dc,brush); ellipse(X0+SIZE*x,Y0+SIZE*y,90+(1-color)*180,180+(1-color)*180,Radius-2,Radius-2); DeleteObject( brush); drawcross(x,y); old_x=x; old_y=y; setbit(x,y); } void drawcross(int x,int y) { setcolor(2); line(X0+SIZE*x-6,Y0+SIZE*y,X0+SIZE*x+6,Y0+SIZE*y); line(X0+SIZE*x,Y0+SIZE*y-6,X0+SIZE*x,Y0+SIZE*y+6); } void setbit(int x,int y) { int mx,my; mx=X0+SIZE*x; my=Y0+SIZE*y; printf("setbit,x:%d,y:%d",x,y); setmousecoord(mx,my); } unsigned condition[2][11]= { { 0x0054, 0x0150, 0x0144, 0x0114, 0x0555, 0x0154, 0x0151, 0x0145, 0x0115, 0x0055, 0x0155 }, { 0x00a8, 0x02a0, 0x0288, 0x0228, 0x0aaa, 0x02a8, 0x02a2, 0x028a, 0x022a, 0x00aa, 0x02aa } }; int compare(unsigned input,int len,char color); void attrib(int x,int y,QCL *pl,char color1,char color2) { int h,i,j,dx,dy,k1,k2,k,num,rang1,rang2; register int temp; pl->p[0]=-1; pl->p[1]=-1; pl->p[2]=-1; pl->p[3]=-1; pl->l[0]=0; pl->l[1]=0; pl->l[2]=0; pl->l[3]=0; for(i=0; i<4; i++) { k1=1; k2=1; num=1; switch(i) { case 0: dx=0; dy=1; rang1=(y>4)?4:y; rang2=(14-y>4)?4:14-y; break; case 1: dx=1; dy=1; rang1=(x<y)?x:y; rang1=(rang1>4)?4:rang1; rang2=(x>y)?x:y; rang2=(14-rang2>4)?4:14-rang2; break; case 2: dx=1; dy=0; rang1=(x>4)?4:x; rang2=(14-x>4)?4:14-x; break; case 3: dx=1; dy=-1; rang1=(x<14-y)?x:14-y; rang1=(rang1>4)?4:rang1; rang2=(14-x<y)?14-x:y; rang2=(rang2>4)?4:rang2; break; } while(k1<=rang1) { temp=qz[x-k1*dx][y-k1*dy]; if(temp==0&&k1+1<=rang1&&qz[x-(k1+1)*dx][y-(k1+1)*dy]==0) { k1+=2; break; } k1++; if(temp==color2) break; if(temp==color1) num++; } k1--; while(k2<=rang2) { temp=qz[x+k2*dx][y+k2*dy]; if(temp==0&&k2+1<=rang2&&qz[x+(k2+1)*dx][y+(k2+1)*dy]==0) { k2+=2; break; } k2++; if(temp==color2) break; if(temp==color1) num++; } k=k1+k2; if(k>4) { int m,n,back; unsigned swap=0,swap1; for(m=0; m<5; m++) swap=swap|(qz[x-(k1-m)*dx][y-(k1-m)*dy]<<(m<<1)); swap1=swap; switch(num) { case 3: if(k>5) { for(n=m; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<10); back=compare(swap1,6,color1); if(back>=0) { pl->p[i]=back; pl->l[i]=3; pl->d[i]=k1-(n-m); break; } swap1=swap1>>2; } } if(pl->p[i]>=0) continue; break; case 4: for(n=m-1; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<8); back=compare(swap1,5,color1); if(back>=0) { pl->p[i]=back; pl->l[i]=4; pl->d[i]=k1-(n-m)-1; break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; break; case 5: for(n=m-1; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<8); if(swap1==condition[color1-1][10]) { pl->p[i]=10; pl->l[i]=5; pl->d[i]=k1-(n-m)-1; break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; break; case 7: case 8: case 9: case 6: for(n=m; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<10); if(swap1==condition[color1-1][4]) { pl->p[i]=4; pl->l[i]=6; pl->d[i]=k1-(n-m); break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; swap1=swap; for(n=m-1; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<8); if(swap1==condition[color1-1][10]) { pl->p[i]=10; pl->l[i]=5; pl->d[i]=k1-(n-m)-1; break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; for(n=m-1; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<8); back=compare(swap1,5,color1); if(back>=0) { pl->p[i]=back; pl->l[i]=4; pl->d[i]=k1-(n-m)-1; break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; swap1=swap; for(n=m; n<k; n++) { swap1=swap1|(qz[x-(k1-n)*dx][y-(k1-n)*dy]<<10); back=compare(swap1,6,color1); if(back>=0) { pl->p[i]=back; pl->l[i]=3; pl->d[i]=k1-(n-m); break; } swap1=swap1>>2; } if(pl->p[i]>=0) continue; break; default: break; } } } } int compare(unsigned input,int len,char color) { int i; color--; switch(len) { case 5: for(i=5; i<10; i++) if(input==condition[color][i]) return i; return -1; case 6: for(i=0; i<4; i++) if(input==condition[color][i]) return i; return -1; default: printf("error len in compare\n"); break; } } ///////////////////////////////////////////////////////////// void OnMouseDown(int id,int btn,int state,int x,int y) { mx=x; my=y; printf("mouse down,x:%d,y:%d",mx,my); } void OnClose() { printf("need close..."); needclose=1; Wait(1); HideVclWin(); CloseVclWin(); } void InitGraph() { HideLeftTools(); ClearVclControls(); ShowVclWin(180); //HideVclWin(200); pfm=GetGuiWin(1); //pfm=CreateComponentEx(0,"form","caption","五子棋","Width",430,"height",480,"BorderIcons","[]","position","poMainFormCenter","formstyle","fsstayontop","OnKeyDown",OnKeyDown,NULL);//创建form;borderIcons:[biSystemMenu,biMinimize,biMaximize] CreateComponentEx(pfm,"SpeedButton","caption","关闭","left",10,"top",5,"width",160,"height",20,"OnClick",OnClose,0); img=CreateComponentEx(pfm,"Image","left",10,"top",40,"width",400,"height",380,"OnMouseDown",OnMouseDown,0); SetProperty(pfm,"visible",1); RECT rect= {0,0,640,480}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0x0000); SelectObject(dc,brush); FillRect(dc,&rect,brush); DeleteObject(brush); } void main(void) { int i; char who,END=0; int result,temp; InitGraph(); while(!END) { SetProperty(pfm,"caption","五子棋"); if(needclose) { //ClearVclControls();; return; } who=1; reset(); printf("game init..............."); RECT rect= {0,0,640,480}; dc=(HANDLE)GetProperty(img,"dc",0,0,0); HBRUSH brush=CreateSolidBrush(0x0000); SelectObject(dc,brush); FillRect(dc,&rect,brush); DeleteObject(brush); game_init(); Invalidate(img); if(MessageBox(GetFormHandle(pfm),"你想先手吗？","开始下棋",4)==6 ) player=2; else player=1; mx=0; my=0; computer=(player==1)?2:1; step=0; //drawcircle(7,7,1); SetProperty(pfm,"caption","五子棋-轮到您走棋"); temp=0; result=0; while(1) { set(who+1); if(who==player-1) { printf("player go"); SetProperty(pfm,"caption","五子棋-轮到您走棋"); temp=player_go(); } else { printf("computer go"); SetProperty(pfm,"caption","五子棋-轮到计算机走棋"); result=computer_go(temp); } if(needclose) { printf("exit go"); return; } printf("temp:%d,result:%d",temp,result); if(temp==1||result==-1) { set(0); MessageBox(GetFormHandle(pfm),"未知! ","本局结束",0); if(needclose) return; mx=0; my=0; break; } if(temp==-1) { set(0); MessageBox(GetFormHandle(pfm),"您赢了! ","本局结束",0); if(needclose) return; mx=0; my=0; break; } if(result==1) { printf("result==1"); set(0); MessageBox(GetFormHandle(pfm),"计算机赢了! ","本局结束",0); if(needclose) return; mx=0; my=0; break; } if(temp==0x10) { END=1; break; } if(temp==0x11) break; who^=1; } } }" /> 
  </Command>
- <Command cmdname="协议组态工具unuseful" cmdType="P" cmd="[P]new command">
- <Command cmdname="数据分析/构造器" cmdType="S" cmd="[S]数据分析器数据">
- <Command cmdname="起始符1-0x55" cmdType="S" cmd="[S]0x55">
  <Command cmdname="数据名称" cmdType="S" cmd="[S]Start_0" /> 
  <Command cmdname="存在方式" cmdType="S" cmd="[S]必选\可选\程序" /> 
  <Command cmdname="是否转义" cmdType="S" cmd="[S]是/否" /> 
  <Command cmdname="转义字符" cmdType="S" cmd="[S]/" /> 
- <Command cmdname="全局合法性" cmdType="S" cmd="[S]是/否">
  <Command cmdname="长度合法" cmdType="S" cmd="[S]是/否" /> 
  <Command cmdname="内容合法" cmdType="S" cmd="[S]是/否" /> 
  </Command>
- <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择">
  <Command cmdname="长度方式" cmdType="S" cmd="[S]固定\程序\止于结束符" /> 
  <Command cmdname="长度数值" cmdType="S" cmd="[S]1" /> 
  <Command cmdname="动态长度" cmdType="S" cmd="[S]GetLength("Start_0")" /> 
  <Command cmdname="结束符" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="是否包含结束符" cmdType="S" cmd="[S]是/否" /> 
  </Command>
- <Command cmdname="内容" cmdType="S" cmd="[S]0x55">
  <Command cmdname="内容方式" cmdType="S" cmd="[S]固定/程序/列表" /> 
  <Command cmdname="固定内容" cmdType="S" cmd="[S]0x55" /> 
  <Command cmdname="程序判断" cmdType="S" cmd="[S]new command" /> 
- <Command cmdname="列表匹配" cmdType="S" cmd="[S]new command">
  <Command cmdname="匹配表格名称" cmdType="S" cmd="[S]new command" /> 
- <Command cmdname="匹配方式" cmdType="S" cmd="[S]new command">
  <Command cmdname="(" cmdType="S" cmd="[S]左括号" /> 
  <Command cmdname="主键1" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="或" cmdType="S" cmd="[S]或关系" /> 
  <Command cmdname="主键2" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname=")" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="主键3" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="程序匹配" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="程序匹配" cmdType="S" cmd="[S]new command" /> 
  </Command>
  </Command>
  </Command>
- <Command cmdname="扩展项目" cmdType="S" cmd="[S]new command">
  <Command cmdname="数据扩展项0" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="数据扩展项1" cmdType="S" cmd="[S]new command" /> 
  </Command>
- <Command cmdname="生成方式" cmdType="S" cmd="[S]new command">
  <Command cmdname="自动加1" cmdType="S" cmd="[S]1 command" /> 
  <Command cmdname="自动减1" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="数据范围" cmdType="S" cmd="[S]1,2,3-9" /> 
- <Command cmdname="随机数" cmdType="S" cmd="[S]new command数">
  <Command cmdname="合法性判断" cmdType="S" cmd="[S]new command" /> 
  </Command>
  <Command cmdname="程序生成" cmdType="S" cmd="[S]new command" /> 
- <Command cmdname="表格选取" cmdType="S" cmd="[S]一new command">
  <Command cmdname="选取方式" cmdType="S" cmd="[S]new command" /> 
  </Command>
  </Command>
  </Command>
- <Command cmdname="起始符2-0xAA" cmdType="S" cmd="[S]new command">
  <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择" /> 
  <Command cmdname="内容" cmdType="S" cmd="[S]0xAA" /> 
  </Command>
- <Command cmdname="长度" cmdType="S" cmd="[S]new command">
  <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择" /> 
  <Command cmdname="全局合法性" cmdType="S" cmd="[S]new command" /> 
  </Command>
- <Command cmdname="长度(反)" cmdType="S" cmd="[S]new command">
  <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择" /> 
  <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command" /> 
  </Command>
- <Command cmdname="流水号" cmdType="S" cmd="[S]new command">
  <Command cmdname="长度" cmdType="S" cmd="[S]固定长度[1byte]- 变长[prg] 进行选择" /> 
  <Command cmdname="内容" cmdType="S" cmd="[S]0x55" /> 
  </Command>
- <Command cmdname="数据" cmdType="S" cmd="[S]new command">
- <Command cmdname="命令1" cmdType="S" cmd="[S]new command">
  <Command cmdname="主命令字" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="子命令字" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="命令参数" cmdType="S" cmd="[S]new command" /> 
- <Command cmdname="数据项属性" cmdType="S" cmd="[S]new command">
  <Command cmdname="重复匹配" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command" /> 
  </Command>
  </Command>
- <Command cmdname="命令2" cmdType="S" cmd="[S]new command">
  <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="命令字" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="命令参数" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="循环匹配" cmdType="S" cmd="[S]new command" /> 
  </Command>
  </Command>
- <Command cmdname="校验" cmdType="S" cmd="[S]new command">
  <Command cmdname="长度" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="内容" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command" /> 
  </Command>
- <Command cmdname="结束符" cmdType="S" cmd="[S]0x03">
  <Command cmdname="长度" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="内容" cmdType="S" cmd="[S]0x55" /> 
  <Command cmdname="包裹合法性" cmdType="S" cmd="[S]new command" /> 
  </Command>
- <Command cmdname="匹配表格" cmdType="S" cmd="[S]new command">
- <Command cmdname="表格一" cmdType="S" cmd="[S]new command">
- <Command cmdname="表格结构" cmdType="S" cmd="[S]new command">
- <Command cmdname="一级键值" cmdType="S" cmd="[S]new command">
  <Command cmdname="长度" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="类型" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="备注" cmdType="S" cmd="[S]new command" /> 
  </Command>
- <Command cmdname="键值内容" cmdType="S" cmd="[S]new command">
  <Command cmdname="名称" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="内容" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="键值4" cmdType="S" cmd="[S]new command" /> 
  </Command>
  </Command>
  <Command cmdname="表格内容" cmdType="S" cmd="[S]new command" /> 
  </Command>
  </Command>
  <Command cmdname="全局变量" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="全局函数" cmdType="S" cmd="[S]new command" /> 
  </Command>
- <Command cmdname="数据构造器" cmdType="S" cmd="[S]new command">
  <Command cmdname="构造器1" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="构造器2" cmdType="S" cmd="[S]new command" /> 
  </Command>
- <Command cmdname="数据解析器" cmdType="S" cmd="[S]new command">
  <Command cmdname="解析器1" cmdType="S" cmd="[S]new command" /> 
  <Command cmdname="解析器2" cmdType="S" cmd="[S]new command" /> 
  </Command>
- <Command cmdname="流程构造器" cmdType="S" cmd="[S]new command">
  <Command cmdname="主\从站方式" cmdType="S" cmd="[S]new command" /> 
  </Command>
  </Command>
  </Command>
- <Command cmdname="组帧发送处理【预处理后发送】" cmdType="P" cmd="[P]void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen) { //帧格式:帧同步字符0x55+0xAA(2字节),长度LEN(1字节),数据DATA,校验CS（1字节） int len,i; unsigned char cs; dstData[0]=0x55; //帧同步字符 dstData[1]=0xAA; //帧同步字符 dstData[2]=srcLen; memcpy(dstData+3,srcData,srcLen); cs=0; for(i=0; i<srcLen+3; i++) cs=cs^dstData[i]; dstData[srcLen+3]=cs; *dstLen=srcLen+4; //目标帧数据长度:55 aa len data cs } void main() { ShowMessage("数据预处理模板，对发送的数据自动套用该模板处理。\n处理格式为：帧同步字符(0x55+0xAA(2字节))，长度LEN(1字节)，数据DATA(n字节)，校验CS（1字节）"); }">
  <Command cmdname="发送前后处理" cmdType="P" cmd="[P]void main() { ShowMessage("在发送前后对发送内容可以进行预处理！"); } void BeforeSend() { PrintToCommWin("====================="); } void AfterSend() { PrintToCommWin("---------------------"); PrintToCommWin(""); }" /> 
  <Command cmdname="组帧模板" cmdType="R" cmd="[R]void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen) { //帧格式:帧同步字符0x55+0xAA(2字节),长度LEN(1字节),数据DATA,校验CS（1字节） int len,i; unsigned char cs; dstData[0]=0x55; //帧同步字符 dstData[1]=0xAA; //帧同步字符 dstData[2]=srcLen; memcpy(dstData+3,srcData,srcLen); cs=0; for(i=0; i<srcLen+3; i++) cs=cs^dstData[i]; dstData[srcLen+3]=cs; *dstLen=srcLen+4; //目标帧数据长度:55 aa len data cs } void main() { ShowMessage("数据预处理模板，对发送的数据自动套用该模板处理。\n处理格式为：帧同步字符(0x55+0xAA(2字节))，长度LEN(1字节)，数据DATA(n字节)，校验CS（1字节）"); }" /> 
- <Command cmdname="数据预处理[增加转义字符]" cmdType="R" cmd="[R]void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen) { //0x02 为转义字符 int len,i; len=0; for(i=0;i<srcLen;i++) { dstData[len++]=srcData[i]; if(srcData[i]==0x02) dstData[len++]=srcData[i]; } *dstLen=len ; }">
  <Command cmdname="1234" cmdType="H" cmd="[H]01 02 03 04" /> 
  </Command>
- <Command cmdname="数据预处理[进行帧封装]" cmdType="R" cmd="[R]#include "stdio.h" void PreProcess(unsigned char *srcData,int srcLen,unsigned char *dstData,int *dstLen) { //帧格式:帧同步字符0x55+0xAA(2字节),长度LEN(1字节),数据DATA,校验CS（1字节） int len,i; unsigned char cs; dstData[0]=0x55; //帧同步字符 dstData[1]=0xAA; //帧同步字符 dstData[2]=srcLen; memcpy(dstData+3,srcData,srcLen); cs=0; for(i=0;i<srcLen+3;i++) cs=cs^dstData[i]; dstData[srcLen+3]=cs; *dstLen=srcLen+4; //目标帧数据长度:55 aa len data cs printf("aaa"); }">
  <Command cmdname="1234" cmdType="H" cmd="[H]11 22 33 44" /> 
  <Command cmdname="字符串" cmdType="S" cmd="[S]12345" /> 
  </Command>
  </Command>
- <Command cmdname="网络通讯" cmdType="S" cmd="[S]=====数据发送区/C语言脚本编辑区===== 1.[F5]键发送/执行、[F4]键终止脚本运行。 2.[F8]键显示、隐藏输出栏。 3.[Ctrl+.]调出脚本接口函数列表、[Ctrl+/]提示函数参数信息、[Ctrl+P]列出代码模板。 4.[Ctrl+Enter]发送数据。 5.支持"预处理"功能，采用C语言脚本回调函数，对发送的数据进行预处理后发送。">
- <Command cmdname="以太网抓包" cmdType="S" cmd="[S]数据发送区/C语言脚本编辑区，[F5]键发送/执行。">
  <Command cmdname="UDP抓包分析" cmdType="P" cmd="[P]int cb1,cb2,cb3; int cb1chk=1,cb2chk=1,cb3chk=1; void cb1click(int control) { cb1chk=GetProperty(cb1,"checked",0,0); } void cb2click(int control) { cb2chk=GetProperty(cb2,"checked",0,0); } void cb3click(int control) { cb3chk=GetProperty(cb3,"checked",0,0); } void main() { ClearOutputWin(); //清除输出窗口内容 ClearVclControls(); ShowVclWin(160); ShowOutputWin(800); HideLeftTools(); SetCommType(10); int p=GetGuiWin(); int pnl = CreateComponentEx(p,"panel","caption","","left",2,"top",2,"width",620,"height",170,NULL); cb1= CreateComponentEx(pnl,"checkbox","caption","显示卡号","left",10,"top",40,"width",160,"checked",1,"onclick",cb1click,NULL); cb2= CreateComponentEx(pnl,"checkbox","caption","显示版本","left",10,"top",60,"width",160,"checked",1,"onclick",cb2click,NULL); cb3= CreateComponentEx(pnl,"checkbox","caption","显示读卡分站状态","left",10,"top",80,"width",160,"checked",1,"onclick",cb3click,NULL); }; typedef struct _TAG { int id; char name[20]; } TAG; TAG taglist[]= { { 935,"测试01"}, { 750,"测试02"}, { 288,"测试03"}, { 909,"测试04"}, { 737,"测试05"}, { 855,"测试06"}, { 552,"测试07"}, { 782,"测试08"}, { 296,"测试09"}, { 269,"测试10"}, {26896,"测试11"}, {18662,"测试12"}, {28725,"测试13"}, {21839,"测试14"}, {26890,"测试15"}, {28385,"测试16"}, {22119,"测试17"}, {25876,"测试18"}, {10955,"测试19"}, {23656,"测试20"}, {20793,"测试21"}, {21669,"测试22"}, {27235,"测试23"}, {26250,"测试24"}, {27378,"测试25"}, {27885,"测试26"}, {26269,"测试27"}, {28805,"测试28"}, {28872,"测试29"}, {25696,"测试30"}, }; void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; //for(i=0;i<count;i++)printf("%02x ",buf[i]&0xff); GetTimeStr(tm,62); sprintf(tmp,"%d.%d.%d.【%3d】",(srcIp>>0)&0xff,(srcIp>>8)&0xff,(srcIp>>16)&0xff,(srcIp>>24)&0xff); if(count>25) { if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x99)&&(buf[9]==0x04)&&(count>25))//&&(buf[2]==0x11) { sprintf(s,"%s %s.%1X %02d:%02d:%02d %02d,卡号：",tm,tmp,(buf[7]>>4)&0xff,buf[14],buf[15],buf[16],(count-24)/2); for(j=23; j<count-1; j+=2) { //printf("卡号:%05d",buf[j]*256+buf[j+1]); fd=0; if((buf[j]>>7)>0) printf("呼叫：%d",(buf[j]*256+buf[j+1])&0x7fff); for(k=0; k<sizeof(taglist); k++) if(buf[j]*256+buf[j+1]==taglist[k].id) { sprintf(tmp," VIP--%s,",taglist[k].name); fd=1; break; } if(fd==0) sprintf(tmp,"%05d,",buf[j]*256+buf[j+1]); strcat(s,tmp); } if(cb1chk) printf("%s",s); } } else if(count>=15) { if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x98)&&(buf[9]==0x1d)) { sprintf(s,"%s %s.%1X 上报版本号:%c%c%c%c",tm,tmp,(buf[7]>>4)&0xff,buf[10],buf[11],buf[12],buf[13]); if(cb2chk)printf(s); } } else if(count>=12) { if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x98)&&(buf[9]==0x1a)) { sprintf(s,"%s %s.%1X 上报读卡分站状态:%d",tm,tmp,(buf[7]>>4)&0xff,buf[10]&0xff); if(cb3chk)printf(s); } } else if(count>=11) { if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x07)) printf("%s %s.%1X 站点启动报告,代码：%d",tm,tmp,(buf[7]>>4)&0xff,buf[9]); } }" /> 
  <Command cmdname="HTTP抓包分析" cmdType="P" cmd="[P]int cb1,cb2,cb3; int cb1chk=1,cb2chk=1,cb3chk=1; void main() { ClearOutputWin(); //清除输出窗口内容 ClearVclControls(); ShowVclWin(160); ShowOutputWin(800); HideLeftTools(); SetCommType(10); int p=GetGuiWin(); int pnl = CreateComponentEx(p,"panel","caption","","left",2,"top",2,"width",620,"height",170,NULL); // cb1= CreateComponentEx(pnl,"checkbox","caption","显示卡号","left",10,"top",40,"width",160,"checked",1,"onclick",cb1click,NULL); // cb2= CreateComponentEx(pnl,"checkbox","caption","显示版本","left",10,"top",60,"width",160,"checked",1,"onclick",cb2click,NULL); // cb3= CreateComponentEx(pnl,"checkbox","caption","显示读卡分站状态","left",10,"top",80,"width",160,"checked",1,"onclick",cb3click,NULL); }; void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; printf("cap tcp data:%x,%d,%x,%d,%s",srcIp,srcPort,dstIp,dstPort,buf); if(dstPort!=80) return; if(strstr(buf,"passw")!=0) { char *p=strstr(buf,"passw"); printf("find:%s",p); } else { return; } }" /> 
  <Command cmdname="UDP抓包分析-协议树" cmdType="P" cmd="[P]#include "windows.h" int cb1,cb2,cb3; int cb1chk=1,cb2chk=1,cb3chk=1; int station[255]; void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count);//UDP抓包事件 void AnaProtocolData(unsigned char *buf,int count) { int node,node1; int i,j,k; char s[1024]; if(count<7)return; if(buf[0]!=0xff) return; if(buf[1]!=0xff) return; if(buf[3]>count-5) return; unsigned char cs=0; for(i=0; i<buf[3]+3; i++) cs+=buf[2+i]; if(cs!=0) { printf("check sum error!"); return; } AddPrtclDetailNode(NULL,"同步头",0,2); AddPrtclDetailNode(NULL,"目的地址",2,1); AddPrtclDetailNode(NULL,"数据长度",3,1); AddPrtclDetailNode(NULL,"源地址",4,1); AddPrtclDetailNode(NULL,"流水号",5,1); if(buf[3]-2>0) { AddPrtclDetailNode(NULL,"数据长度",6,1); node=AddPrtclDetailNode(NULL,"数据",7,buf[6]); AddPrtclDetailNode(node,"点号",7,1); AddPrtclDetailNode(node,"命令号",8,2); AddPrtclDetailNode(NULL,"校验",7+buf[6],1); } else { AddPrtclDetailNode(NULL,"校验",6,1); } if(count>25) { if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x99)&&(buf[9]==0x04)&&(count>25))//&&(buf[2]==0x11) { AddPrtclDetailNode(node,"日期",10,4); node1=AddPrtclDetailNode(node,"时间",14,3); sprintf(s,"%02d:%02d:%02d",buf[14]&0xff,buf[15]&0xff,buf[16]&0xff); AddPrtclDetailNode(node1,s,10,0); AddPrtclDetailNode(node,"查询流水号",17,1); AddPrtclDetailNode(node,"总包数",18,1); AddPrtclDetailNode(node,"包号",19,1); AddPrtclDetailNode(node,"节点号",20,1); AddPrtclDetailNode(node,"总团数",21,1); AddPrtclDetailNode(node,"团人数",22,1); node1=AddPrtclDetailNode(node,"卡号",23,buf[6]-16); for(i=0; i<buf[6]-16; i+=2) { sprintf(s,"卡%02d:%05d ",i+1,buf[23+i]*256+buf[23+i+1]); AddPrtclDetailNode(node1,s,23+i,2); } } } else if(count>=15) { if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x98)&&(buf[9]==0x1d)) { sprintf(s,"版本号:%c%c%c%c",buf[10],buf[11],buf[12],buf[13]); AddPrtclDetailNode(node,s,10,4); } } else if(count>=12) { if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x98)&&(buf[9]==0x1a)) { sprintf(s,"读卡分站状态:%d",buf[10]&0xff); AddPrtclDetailNode(node,s,10,1); } } else if(count>=11) { if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x07)) { sprintf(s,"启动报告代码：%d",buf[9]); AddPrtclDetailNode(node,s,9,1); } } } void cb1click(int control) { cb1chk=GetProperty(cb1,"checked",0,0); } void cb2click(int control) { cb2chk=GetProperty(cb2,"checked",0,0); } void cb3click(int control) { cb3chk=GetProperty(cb3,"checked",0,0); } void btnClick(int control) { unsigned char dat0[]= {0xFF,0xFF,0x11,0x19,0x13,0x09,0x16,0x10,0x99,0x04,0x07,0xDB,0x08,0x1A,0x0C,0x2A,0x18,0x56,0x01,0x01,0x10,0x01,0x03,0x5A,0xAF,0x69,0x4B,0x68,0x2A,0xEA}; unsigned char dat1[]= {0xFF,0xFF,0x11,0x0A,0x13,0x05,0x07,0xC0,0x98,0x1D,0x31,0x2E,0x30,0x32,0x90}; CapUdpData(0,0,0,0,dat0,sizeof(dat0));//UDP抓包模拟 CapUdpData(0,0,0,0,dat1,sizeof(dat1));//UDP抓包模拟 } void main() { int i; ClearOutputWin(); //清除输出窗口内容 ClearVclControls(); ShowVclWin(160); ShowOutputWin(800); //HideLeftTools(); ShowProtocolWin(); ClearProtocolTree(); SetCommType(10); int p=GetGuiWin(); int pnl = CreateComponentEx(p,"panel","caption","","left",2,"top",2,"width",620,"height",170,NULL); cb1= CreateComponentEx(pnl,"checkbox","caption","显示卡号","left",10,"top",40,"width",160,"checked",1,"onclick",cb1click,NULL); cb2= CreateComponentEx(pnl,"checkbox","caption","显示版本","left",10,"top",60,"width",160,"checked",1,"onclick",cb2click,NULL); cb3= CreateComponentEx(pnl,"checkbox","caption","显示读卡分站状态","left",10,"top",80,"width",160,"checked",1,"onclick",cb3click,NULL); CreateComponentEx(pnl,"button","caption","测试数据","left",10,"top",100,"width",100,"onclick",btnClick,NULL); for(i=0; i<255; i++)station[i]=0; //btnClick(0); }; typedef struct _TAG { int id; char name[20]; } TAG; TAG taglist[]= { { 935,"测试01"}, { 750,"测试02"}, { 288,"测试03"}, { 909,"测试04"}, { 737,"测试05"}, { 855,"测试06"}, { 552,"测试07"}, { 782,"测试08"}, { 296,"测试09"}, { 269,"测试10"}, {26896,"测试11"}, {18662,"测试12"}, {28725,"测试13"}, {21839,"测试14"}, {26890,"测试15"}, {28385,"测试16"}, {22119,"测试17"}, {25876,"测试18"}, {10955,"测试19"}, {23656,"测试20"}, {20793,"测试21"}, {21669,"测试22"}, {27235,"测试23"}, {26250,"测试24"}, {27378,"测试25"}, {27885,"测试26"}, {26269,"测试27"}, {28805,"测试28"}, {28872,"测试29"}, {25696,"测试30"}, }; void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; //for(i=0;i<count;i++)printf("%02x ",buf[i]&0xff); GetTimeStr(tm,62); sprintf(tmp,"%d.%d.%d.【%3d】",(srcIp>>0)&0xff,(srcIp>>8)&0xff,(srcIp>>16)&0xff,(srcIp>>24)&0xff); if(count<7)return; if(buf[0]!=0xff) return; if(buf[1]!=0xff) return; if(buf[3]>count-5) return; unsigned char cs=0; unsigned char src,dst; int node; for(i=0; i<buf[3]+3; i++) cs+=buf[2+i]; if(cs!=0) { printf("check sum error!"); return; } src=buf[4]; dst=buf[2]; if(src==17) { if(station[dst]==0) { sprintf(s,"分站-%d",dst); station[dst]=AddPrtclDataNode(NULL,s,0,0,0); } node=station[dst]; } else { if(station[src]==0) { sprintf(s,"分站-%d",src); station[dst]=AddPrtclDataNode(NULL,s,0,0,0); } node=station[src]; } if(buf[3]==0x02) { sprintf(s,"循访空包:%d->%d,sn:%d",buf[4],buf[2],buf[5]); src=buf[4]; dst=buf[2]; AddPrtclDataNode(node,s,buf,count,0); return; } if(count>25) { sprintf(s,"上报卡号:%d->%d,sn:%d",buf[4],buf[2],buf[5]); AddPrtclDataNode(node,s,buf,count,0); if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x99)&&(buf[9]==0x04)&&(count>25))//&&(buf[2]==0x11) { sprintf(s,"%s %s.%1X %02d:%02d:%02d %02d,卡号：",tm,tmp,(buf[7]>>4)&0xff,buf[14],buf[15],buf[16],(count-24)/2); for(j=23; j<count-1; j+=2) { //printf("卡号:%05d",buf[j]*256+buf[j+1]); fd=0; if((buf[j]>>7)>0) printf("呼叫：%d",(buf[j]*256+buf[j+1])&0x7fff); for(k=0; k<sizeof(taglist); k++) if(buf[j]*256+buf[j+1]==taglist[k].id) { sprintf(tmp," VIP--%s,",taglist[k].name); fd=1; break; } if(fd==0) sprintf(tmp,"%05d,",buf[j]*256+buf[j+1]); strcat(s,tmp); } if(cb1chk) printf("%s",s); } } else if(count>=15) { if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x98)&&(buf[9]==0x1d)) { sprintf(s,"上报版本号:%d->%d,sn:%d",buf[4],buf[2],buf[5]); AddPrtclDataNode(node,s,buf,count,0); sprintf(s,"%s %s.%1X 上报版本号:%c%c%c%c",tm,tmp,(buf[7]>>4)&0xff,buf[10],buf[11],buf[12],buf[13]); if(cb2chk)printf(s); } } else if(count>=12) { if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x98)&&(buf[9]==0x1a)) { sprintf(s,"上报读卡分站状态:%d->%d,sn:%d",buf[4],buf[2],buf[5]); AddPrtclDataNode(node,s,buf,count,0); sprintf(s,"%s %s.%1X 上报读卡分站状态:%d",tm,tmp,(buf[7]>>4)&0xff,buf[10]&0xff); if(cb3chk)printf(s); } } else if(count>=11) { if((buf[0]==0xff)&&(buf[1]==0xff)&&(buf[8]==0x07)) { sprintf(s,"站点启动报告:%d->%d,sn:%d",buf[4],buf[2],buf[5]); AddPrtclDataNode(node,s,buf,count,0); printf("%s %s.%1X 站点启动报告,代码：%d",tm,tmp,(buf[7]>>4)&0xff,buf[9]); } } }" /> 
  </Command>
- <Command cmdname="C脚本通讯协议分析-数据树形显示" cmdType="P" cmd="[P]#include "windows.h" //////////////// 接收队列处理 /////////////////////////////////// #define MAXRXBUFLEN (1024*20) #define GetRxBufLen() ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN) #define IsRxBufEmpty() (RxBufHead==RxBufTail) #define IsRxBufFull() ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead) #define ClearRxBuf() RxBufHead=RxBufTail=0 BYTE RxBuf[MAXRXBUFLEN]; BYTE RxBufHead=0; BYTE RxBufTail=0; BYTE GetRxBufByte(void) { BYTE dat; dat=RxBuf[RxBufHead]; RxBufHead++; RxBufHead%=MAXRXBUFLEN; return dat; } void DiscardRxBufBytes(BYTE count) { RxBufHead+=count; RxBufHead%=MAXRXBUFLEN; } BYTE PeekRxBufByte(BYTE idx) { BYTE tmpHead=RxBufHead; tmpHead+=idx; tmpHead%=MAXRXBUFLEN; return RxBuf[tmpHead]; } void PutRxBufByte(BYTE dat) { RxBuf[RxBufTail]=dat; RxBufTail++; RxBufTail%=MAXRXBUFLEN; } ////////////////////////////////////////////////////////////////// //////////////// 队列处理 /////////////////////////////////// //#define MAXRXBUFLEN (1024*20) #define GetPrtclBufLen() ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN) #define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail) #define IsPrtclBufFull() ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead) #define ClearPrtclBuf() PrtclBufHead=PrtclBufTail=0 BYTE PrtclBuf[MAXRXBUFLEN]; BYTE PrtclBufHead=0; BYTE PrtclBufTail=0; BYTE GetPrtclBufByte(void) { BYTE dat; dat=PrtclBuf[PrtclBufHead]; PrtclBufHead++; PrtclBufHead%=MAXRXBUFLEN; return dat; } void DiscardPrtclBufBytes(BYTE count) { PrtclBufHead+=count; PrtclBufHead%=MAXRXBUFLEN; } BYTE PeekPrtclBufByte(BYTE idx) { BYTE tmpHead=PrtclBufHead; tmpHead+=idx; tmpHead%=MAXRXBUFLEN; return PrtclBuf[tmpHead]; } void PutPrtclBufByte(BYTE dat) { PrtclBuf[PrtclBufTail]=dat; PrtclBufTail++; PrtclBufTail%=MAXRXBUFLEN; } ////////////////////////////////////////////////////////////////// #define MAXCMDLEN 20 BYTE StationCmd[MAXCMDLEN]; BYTE StationCmdLen; BYTE RepBuf[140]; unsigned int newId,newInterval; void ConsolePutArray(BYTE buf[],BYTE len) { BYTE i; for(i=0;i<len;i++) ;// halPutch(buf[i]); } void ProgramData(void)// 查询单个团详细信息 { BYTE i,j; BYTE find; BYTE idx; BYTE cs; BYTE mbCount; if(StationCmdLen!=1+4) { // return; } newId=StationCmd[1]+StationCmd[2]*256; } void ProcessStationCmd(void) { if(StationCmdLen==0) return; switch(StationCmd[0]) { case 0x08: // 查询工作状态 =[H]55 AA 02 FD 07 07 03 ProgramData(); break; default: break; } } void EncodePrtclData(void)//包裹解码 { BYTE i,len; BYTE cs; len=PeekPrtclBufByte(2); if(len>MAXCMDLEN) { StationCmd[0]=PeekPrtclBufByte(4); for(i=0;i<=4+len;i++) GetPrtclBufByte();//丢弃一个字节; return ; } AddPrtclDetailNode(NULL,"同步头",PrtclBufHead,2); GetPrtclBufByte();//丢弃一个字节; 55 GetPrtclBufByte();//丢弃一个字节; aa AddPrtclDetailNode(NULL,"长度",PrtclBufHead,1); GetPrtclBufByte();//丢弃一个字节; len AddPrtclDetailNode(NULL,"~长度",PrtclBufHead,1); GetPrtclBufByte();//丢弃一个字节; ~len AddPrtclDetailNode(NULL,"data",PrtclBufHead,len); for(i=0;i<len;i++) StationCmd[i]=GetPrtclBufByte(); GetPrtclBufByte(); //0x03 cs=0; for(i=0;i<len-1;i++) cs^=StationCmd[i]; if(cs!=StationCmd[len-1]) { printf("check sum error!"); //return; } //ConsolePutROMString((rom char *)"接收到命令包:"); //ConsolePutInitData(0,StationCmd[0]); StationCmdLen=len-1; //不包含校验位 printf("Recv a command!"); ProcessStationCmd(); } //通讯处理 void ProcessRxComm(void) { BYTE len; while(GetRxBufLen()>=7) { if(PeekRxBufByte(0)!=0x55) { DiscardRxBufBytes(1); } else if(PeekRxBufByte(1)!=0xaa) { DiscardRxBufBytes(2); } else if(PeekRxBufByte(2)+PeekRxBufByte(3)!=0xff)//长度、长度取反 { DiscardRxBufBytes(4); } else { len=PeekRxBufByte(2); if(len>MAXCMDLEN) //命令过长 { DiscardRxBufBytes(4); } else if(GetRxBufLen()>len+4) { if(PeekRxBufByte(4+len)!=0x03)//结束字符 { DiscardRxBufBytes(1); } else { AddPrtclDataNode(NULL,"版本号查询",&RxBuf[RxBufHead],len+5,0); DiscardRxBufBytes(len+5); } } else { break; } } } //while } void ProcessPrtclData(void) { BYTE len; while(GetPrtclBufLen()>=7) { if(PeekPrtclBufByte(0)!=0x55) { DiscardPrtclBufBytes(1); } else if(PeekPrtclBufByte(1)!=0xaa) { DiscardPrtclBufBytes(2); } else if(PeekPrtclBufByte(2)+PeekPrtclBufByte(3)!=0xff)//长度、长度取反 { DiscardPrtclBufBytes(4); } else { len=PeekPrtclBufByte(2); if(len>MAXCMDLEN) //命令过长 { DiscardPrtclBufBytes(4); } else if(GetPrtclBufLen()>len+4) { if(PeekPrtclBufByte(4+len)!=0x03)//结束字符 { DiscardPrtclBufBytes(1); } else { EncodePrtclData(); } } else { break; } } } //while } ////////////////////////////////////////////////////////////////////// void RecvSerialData(char *buf,int count) { int i; for(i=0;i<count;i++) { PutRxBufByte(buf[i]); } printf("RecvSerialData,len(%d)",count); ProcessRxComm(); } void AnaProtocolData(char *buf,int count) { int node; int i; printf("AnaProtocolData,len(%d) ",count ); ClearPrtclBuf(); for(i=0;i<count;i++) PutPrtclBufByte(buf[i]); ProcessPrtclData(); } void click(int btn) { char s[20]; printf("clicked"); //SetProperty(btn,"enabled","false"); GetProperty(btn,"caption",s,20); printf("button caption is %s",s); MessageBox(0,s,"按钮标题",1); }; void main() { int i; int btn; int node; char s[100]; ShowProtocolWindow(); ClearVclControls(); ShowVclWin(150); ShowOutputWin(300); int p=GetGuiWindow(); for( i=0;i<1;i++) { sprintf(s,"按钮:%d",i); btn=CreateComponentEx(p,"button","caption",s,"left",10+i*70,"top",30,"width",65,"onclick",click,NULL);//创建按钮 } btn=CreateComponentEx(p,"combobox","text","按钮","left",12+i*70,"top",32,"width",80,"onclick",click,NULL);//创建按钮 //SetProperty(btn,"caption","最后一个按钮"); StringsAdd(btn,"111"); //s[0]=90;//printf("%s",s); sprintf(s+10,"按钮876587iuytiuyt87888777666555:%d",i); ClearProtocolTree(); //node=AddPrtclDataNode(NULL,"版本号查询",s,100,0); //sprintf(s+10,"reqtgfdsgfdsgft64ew2543w25435:%d",i); //node=AddPrtclDataNode(node,"版本号查询1",s,100,0); };">
  <Command cmdname="协议解析程序0" cmdType="P" cmd="[P]#include "windows.h" //////////////// 接收队列处理 /////////////////////////////////// #define MAXRXBUFLEN (1024*20) #define GetRxBufLen() ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN) #define IsRxBufEmpty() (RxBufHead==RxBufTail) #define IsRxBufFull() ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead) #define ClearRxBuf() RxBufHead=RxBufTail=0 BYTE RxBuf[MAXRXBUFLEN]; BYTE RxBufHead=0; BYTE RxBufTail=0; BYTE GetRxBufByte(void) { BYTE dat; dat=RxBuf[RxBufHead]; RxBufHead++; RxBufHead%=MAXRXBUFLEN; return dat; } void DiscardRxBufBytes(BYTE count) { RxBufHead+=count; RxBufHead%=MAXRXBUFLEN; } BYTE PeekRxBufByte(BYTE idx) { BYTE tmpHead=RxBufHead; tmpHead+=idx; tmpHead%=MAXRXBUFLEN; return RxBuf[tmpHead]; } void PutRxBufByte(BYTE dat) { RxBuf[RxBufTail]=dat; RxBufTail++; RxBufTail%=MAXRXBUFLEN; } ////////////////////////////////////////////////////////////////// //////////////// 队列处理 /////////////////////////////////// //#define MAXRXBUFLEN (1024*20) #define GetPrtclBufLen() ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN) #define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail) #define IsPrtclBufFull() ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead) #define ClearPrtclBuf() PrtclBufHead=PrtclBufTail=0 BYTE PrtclBuf[MAXRXBUFLEN]; BYTE PrtclBufHead=0; BYTE PrtclBufTail=0; BYTE GetPrtclBufByte(void) { BYTE dat; dat=PrtclBuf[PrtclBufHead]; PrtclBufHead++; PrtclBufHead%=MAXRXBUFLEN; return dat; } void DiscardPrtclBufBytes(BYTE count) { PrtclBufHead+=count; PrtclBufHead%=MAXRXBUFLEN; } BYTE PeekPrtclBufByte(BYTE idx) { BYTE tmpHead=PrtclBufHead; tmpHead+=idx; tmpHead%=MAXRXBUFLEN; return PrtclBuf[tmpHead]; } void PutPrtclBufByte(BYTE dat) { PrtclBuf[PrtclBufTail]=dat; PrtclBufTail++; PrtclBufTail%=MAXRXBUFLEN; } ////////////////////////////////////////////////////////////////// #define MAXCMDLEN 20 BYTE StationCmd[MAXCMDLEN]; BYTE StationCmdLen; BYTE RepBuf[140]; unsigned int newId,newInterval; void ConsolePutArray(BYTE buf[],BYTE len) { BYTE i; for(i=0; i<len; i++) ;// halPutch(buf[i]); } void ProgramData(void)// 查询单个团详细信息 { BYTE i,j; BYTE find; BYTE idx; BYTE cs; BYTE mbCount; if(StationCmdLen!=1+4) { // return; } newId=StationCmd[1]+StationCmd[2]*256; } void ProcessStationCmd(void) { if(StationCmdLen==0) return; switch(StationCmd[0]) { case 0x08: // 查询工作状态 =[H]55 AA 02 FD 07 07 03 ProgramData(); break; case 0x09: // 查询工作状态 =[H]55 AA 02 FD 07 07 03 ProgramData(); break; default: break; } } void EncodePrtclData(void)//包裹解码 { BYTE i,len; BYTE cs; len=PeekPrtclBufByte(2); if(len>MAXCMDLEN) { StationCmd[0]=PeekPrtclBufByte(4); for(i=0; i<=4+len; i++) GetPrtclBufByte();//丢弃一个字节; return ; } AddPrtclDetailNode(NULL,"同步头",PrtclBufHead,2); GetPrtclBufByte();//丢弃一个字节; 55 GetPrtclBufByte();//丢弃一个字节; aa AddPrtclDetailNode(NULL,"长度",PrtclBufHead,1); GetPrtclBufByte();//丢弃一个字节; len AddPrtclDetailNode(NULL,"~长度",PrtclBufHead,1); GetPrtclBufByte();//丢弃一个字节; ~len AddPrtclDetailNode(NULL,"data",PrtclBufHead,len); for(i=0; i<len; i++) StationCmd[i]=GetPrtclBufByte(); GetPrtclBufByte(); //0x03 cs=0; for(i=0; i<len-1; i++) { printf("cs:%d,%02x",i,StationCmd[i]&0xff); cs+=StationCmd[i]; } if(cs!=StationCmd[len-1]) { printf("check sum error:0x%02x---0x%02x!",cs,StationCmd[len-1]&0xff); //return; } else printf("check sum success:%02x!",StationCmd[len-1]&0xff); //ConsolePutROMString((rom char *)"接收到命令包:"); //ConsolePutInitData(0,StationCmd[0]); StationCmdLen=len-1; //不包含校验位 printf("Recv a command!"); ProcessStationCmd(); } //通讯处理 void ProcessRxComm(void) { BYTE len; while(GetRxBufLen()>=7) { if(PeekRxBufByte(0)!=0x55) { DiscardRxBufBytes(1); } else if(PeekRxBufByte(1)!=0xaa) { DiscardRxBufBytes(2); } else if(PeekRxBufByte(2)+PeekRxBufByte(3)!=0xff)//长度、长度取反 { DiscardRxBufBytes(4); } else { len=PeekRxBufByte(2); if(len>MAXCMDLEN) //命令过长 { DiscardRxBufBytes(4); } else if(GetRxBufLen()>len+4) { if(PeekRxBufByte(4+len)!=0x03)//结束字符 { DiscardRxBufBytes(1); } else { if(RxBuf[RxBufHead+4]==0x01) AddPrtclDataNode(NULL,"版本号查询",&RxBuf[RxBufHead],len+5,0); else if(RxBuf[RxBufHead+4]==0x02) AddPrtclDataNode(NULL,"读序列号",&RxBuf[RxBufHead],len+5,0); else if(RxBuf[RxBufHead+4]==0x03) AddPrtclDataNode(NULL,"控制继电器",&RxBuf[RxBufHead],len+5,0); DiscardRxBufBytes(len+5); } } else { break; } } } //while } void ProcessPrtclData(void) { BYTE len; while(GetPrtclBufLen()>=7) { if(PeekPrtclBufByte(0)!=0x55) { DiscardPrtclBufBytes(1); } else if(PeekPrtclBufByte(1)!=0xaa) { DiscardPrtclBufBytes(2); } else if(PeekPrtclBufByte(2)+PeekPrtclBufByte(3)!=0xff)//长度、长度取反 { DiscardPrtclBufBytes(4); } else { len=PeekPrtclBufByte(2); if(len>MAXCMDLEN) //命令过长 { DiscardPrtclBufBytes(4); } else if(GetPrtclBufLen()>len+4) { if(PeekPrtclBufByte(4+len)!=0x03)//结束字符 { DiscardPrtclBufBytes(1); } else { EncodePrtclData(); } } else { break; } } } //while } ////////////////////////////////////////////////////////////////////// void RecvSerialData(char *buf,int count) { int i; for(i=0; i<count; i++) { PutRxBufByte(buf[i]); } printf("RecvSerialData,len(%d)",count); ProcessRxComm(); } void AnaProtocolData(char *buf,int count) { int node; int i; printf("AnaProtocolData,len(%d) ",count ); ClearPrtclBuf(); for(i=0; i<count; i++) PutPrtclBufByte(buf[i]); ProcessPrtclData(); } void click(int btn) { char s0[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x01 ,0x02 ,0x03 ,0x06 ,0x03}; char s1[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x02 ,0x02 ,0xf3 ,0xf7 ,0x03}; //SendHexString(s); RecvSerialData(s0,sizeof(s0)); RecvSerialData(s1,sizeof(s1)); }; void main() { int i; int btn; int node; char s[100]; ShowProtocolWin(); ClearVclControls(); //ShowOutputWin(300); ShowVclWin(150); int p=GetGuiWin(1); for( i=0; i<2; i++) { sprintf(s,"按钮:%d",i); btn=CreateComponentEx(p,"button","caption",s,"left",10+i*70,"top",30,"width",65,"onclick",click,NULL);//创建按钮 } ClearProtocolTree(); click(0); };" /> 
  <Command cmdname="协议解析程序1" cmdType="P" cmd="[P]#include "windows.h" //////////////// 接收队列处理 /////////////////////////////////// #define MAXRXBUFLEN (1024*20) #define GetRxBufLen() ((RxBufTail+MAXRXBUFLEN-RxBufHead) % MAXRXBUFLEN) #define IsRxBufEmpty() (RxBufHead==RxBufTail) #define IsRxBufFull() ((RxBufTail+1)%MAXRXBUFLEN==RxBufHead) #define ClearRxBuf() RxBufHead=RxBufTail=0 BYTE RxBuf[MAXRXBUFLEN]; BYTE RxBufHead=0; BYTE RxBufTail=0; BYTE GetRxBufByte(void) { BYTE dat; dat=RxBuf[RxBufHead]; RxBufHead++; RxBufHead%=MAXRXBUFLEN; return dat; } void DiscardRxBufBytes(BYTE count) { RxBufHead+=count; RxBufHead%=MAXRXBUFLEN; } BYTE PeekRxBufByte(BYTE idx) { BYTE tmpHead=RxBufHead; tmpHead+=idx; tmpHead%=MAXRXBUFLEN; return RxBuf[tmpHead]; } void PutRxBufByte(BYTE dat) { RxBuf[RxBufTail]=dat; RxBufTail++; RxBufTail%=MAXRXBUFLEN; } ////////////////////////////////////////////////////////////////// //////////////// 队列处理 /////////////////////////////////// //#define MAXRXBUFLEN (1024*20) #define GetPrtclBufLen() ((PrtclBufTail+MAXRXBUFLEN-PrtclBufHead) % MAXRXBUFLEN) #define IsPrtclBufEmpty() (PrtclBufHead==PrtclBufTail) #define IsPrtclBufFull() ((PrtclBufTail+1)%MAXRXBUFLEN==PrtclBufHead) #define ClearPrtclBuf() PrtclBufHead=PrtclBufTail=0 BYTE PrtclBuf[MAXRXBUFLEN]; BYTE PrtclBufHead=0; BYTE PrtclBufTail=0; BYTE GetPrtclBufByte(void) { BYTE dat; dat=PrtclBuf[PrtclBufHead]; PrtclBufHead++; PrtclBufHead%=MAXRXBUFLEN; return dat; } void DiscardPrtclBufBytes(BYTE count) { PrtclBufHead+=count; PrtclBufHead%=MAXRXBUFLEN; } BYTE PeekPrtclBufByte(BYTE idx) { BYTE tmpHead=PrtclBufHead; tmpHead+=idx; tmpHead%=MAXRXBUFLEN; return PrtclBuf[tmpHead]; } void PutPrtclBufByte(BYTE dat) { PrtclBuf[PrtclBufTail]=dat; PrtclBufTail++; PrtclBufTail%=MAXRXBUFLEN; } ////////////////////////////////////////////////////////////////// #define MAXCMDLEN 20 BYTE StationCmd[MAXCMDLEN]; BYTE StationCmdLen; BYTE RepBuf[140]; unsigned int newId,newInterval; void ConsolePutArray(BYTE buf[],BYTE len) { BYTE i; for(i=0; i<len; i++) ;// halPutch(buf[i]); } void ProgramData(void)// 查询单个团详细信息 { BYTE i,j; BYTE find; BYTE idx; BYTE cs; BYTE mbCount; if(StationCmdLen!=1+4) { // return; } newId=StationCmd[1]+StationCmd[2]*256; } void ProcessStationCmd(void) { if(StationCmdLen==0) return; switch(StationCmd[0]) { case 0x08: // 查询工作状态 =[H]55 AA 02 FD 07 07 03 ProgramData(); break; case 0x09: // 查询工作状态 =[H]55 AA 02 FD 07 07 03 ProgramData(); break; default: break; } } void EncodePrtclData(void)//包裹解码 { BYTE i,len; BYTE cs; len=PeekPrtclBufByte(2); if(len>MAXCMDLEN) { StationCmd[0]=PeekPrtclBufByte(4); for(i=0; i<=4+len; i++) GetPrtclBufByte();//丢弃一个字节; return ; } AddPrtclDetailNode(NULL,"同步头",PrtclBufHead,2); GetPrtclBufByte();//丢弃一个字节; 55 GetPrtclBufByte();//丢弃一个字节; aa AddPrtclDetailNode(NULL,"长度",PrtclBufHead,1); GetPrtclBufByte();//丢弃一个字节; len AddPrtclDetailNode(NULL,"~长度",PrtclBufHead,1); GetPrtclBufByte();//丢弃一个字节; ~len AddPrtclDetailNode(NULL,"data",PrtclBufHead,len); for(i=0; i<len; i++) StationCmd[i]=GetPrtclBufByte(); GetPrtclBufByte(); //0x03 cs=0; for(i=0; i<len-1; i++) { printf("cs:%d,%02x",i,StationCmd[i]&0xff); cs+=StationCmd[i]; } if(cs!=StationCmd[len-1]) { printf("check sum error:0x%02x---0x%02x!",cs,StationCmd[len-1]&0xff); //return; } else printf("check sum success:%02x!",StationCmd[len-1]&0xff); //ConsolePutROMString((rom char *)"接收到命令包:"); //ConsolePutInitData(0,StationCmd[0]); StationCmdLen=len-1; //不包含校验位 printf("Recv a command!"); ProcessStationCmd(); } //通讯处理 void ProcessRxComm(void) { BYTE len; while(GetRxBufLen()>=7) { if(PeekRxBufByte(0)!=0x55) { DiscardRxBufBytes(1); } else if(PeekRxBufByte(1)!=0xaa) { DiscardRxBufBytes(2); } else if(PeekRxBufByte(2)+PeekRxBufByte(3)!=0xff)//长度、长度取反 { DiscardRxBufBytes(4); } else { len=PeekRxBufByte(2); if(len>MAXCMDLEN) //命令过长 { DiscardRxBufBytes(4); } else if(GetRxBufLen()>len+4) { if(PeekRxBufByte(4+len)!=0x03)//结束字符 { DiscardRxBufBytes(1); } else { if(RxBuf[RxBufHead+4]==0x01) AddPrtclDataNode(NULL,"版本号查询",&RxBuf[RxBufHead],len+5,0); else if(RxBuf[RxBufHead+4]==0x02) AddPrtclDataNode(NULL,"读序列号",&RxBuf[RxBufHead],len+5,0); else if(RxBuf[RxBufHead+4]==0x03) AddPrtclDataNode(NULL,"控制继电器",&RxBuf[RxBufHead],len+5,0); DiscardRxBufBytes(len+5); } } else { break; } } } //while } void ProcessPrtclData(void) { BYTE len; while(GetPrtclBufLen()>=7) { if(PeekPrtclBufByte(0)!=0x55) { DiscardPrtclBufBytes(1); } else if(PeekPrtclBufByte(1)!=0xaa) { DiscardPrtclBufBytes(2); } else if(PeekPrtclBufByte(2)+PeekPrtclBufByte(3)!=0xff)//长度、长度取反 { DiscardPrtclBufBytes(4); } else { len=PeekPrtclBufByte(2); if(len>MAXCMDLEN) //命令过长 { DiscardPrtclBufBytes(4); } else if(GetPrtclBufLen()>len+4) { if(PeekPrtclBufByte(4+len)!=0x03)//结束字符 { DiscardPrtclBufBytes(1); } else { EncodePrtclData(); } } else { break; } } } //while } ////////////////////////////////////////////////////////////////////// void RecvSerialData(char *buf,int count) { int i; for(i=0; i<count; i++) { PutRxBufByte(buf[i]); } printf("RecvSerialData,len(%d)",count); ProcessRxComm(); } void AnaProtocolData(char *buf,int count) { int node; int i; printf("AnaProtocolData,len(%d) ",count ); ClearPrtclBuf(); for(i=0; i<count; i++) PutPrtclBufByte(buf[i]); ProcessPrtclData(); } void click(int btn) { char s0[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x01 ,0x02 ,0x03 ,0x06 ,0x03}; char s1[]= {0x55 ,0xAA ,0x04 ,0xFb ,0x02 ,0x02 ,0xf3 ,0xf7 ,0x03}; //SendHexString(s); RecvSerialData(s0,sizeof(s0)); RecvSerialData(s1,sizeof(s1)); }; void main() { int i; int btn; int node; char s[100]; ShowProtocolWin(); ClearVclControls(); //ShowOutputWin(300); ShowVclWin(150); int p=GetGuiWin(1); for( i=0; i<2; i++) { sprintf(s,"按钮:%d",i); btn=CreateComponentEx(p,"button","caption",s,"left",10+i*70,"top",30,"width",65,"onclick",click,NULL);//创建按钮 } ClearProtocolTree(); click(0); };" /> 
  <Command cmdname="协议测试命令(通过串口回环模式)" cmdType="H" cmd="[H]55 AA 04 Fb 01 02 03 07 03" /> 
  </Command>
- <Command cmdname="通讯数据分析" cmdType="S" cmd="[S]new command">
  <Command cmdname="以太网数据分析" cmdType="P" cmd="[P] void main() { ClearOutputWin(); //清除输出窗口内容 ClearVclControls(); ShowVclWin(160); ShowOutputWin(-1); HideLeftTools(); }; void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; printf("cap tcp data:%x,%d,%x,%d,%s",srcIp,srcPort,dstIp,dstPort,buf); if(dstPort!=80) return; if(strstr(buf,"passw")!=0) { char *p=strstr(buf,"passw"); printf("find:%s",p); } else { return; } } void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; printf("cap udp data:%x,%d,%x,%d,%s",srcIp,srcPort,dstIp,dstPort,buf); if(dstPort!=80) return; if(strstr(buf,"passw")!=0) { char *p=strstr(buf,"passw"); printf("find:%s",p); } else { return; } } void RecvTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; printf("recv tcp data:%x,%d,%x,%d,%s",srcIp,srcPort,dstIp,dstPort,buf); if(dstPort!=80) return; if(strstr(buf,"passw")!=0) { char *p=strstr(buf,"passw"); printf("find:%s",p); } else { return; } } void RecvUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; printf("recv udp data:%x,%d,%x,%d,%s",srcIp,srcPort,dstIp,dstPort,buf); if(dstPort!=80) return; if(strstr(buf,"passw")!=0) { char *p=strstr(buf,"passw"); printf("find:%s",p); } else { return; } }" /> 
  <Command cmdname="通讯数据分析" cmdType="P" cmd="[P] void main() { ClearOutputWin(); //清除输出窗口内容 ClearVclControls(); ShowVclWin(160); ShowOutputWin(-1); HideLeftTools(); }; void CapSerialData(unsigned int ComNum,int RdWt,unsigned char *buf,int count)//串口捕获数据事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; printf("cap serial data:COM%d,RdWt:%d,%s",ComNum,RdWt,buf); } void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; printf("cap udp data:%x,%d,%x,%d,%s",srcIp,srcPort,dstIp,dstPort,buf); } void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; printf("cap tcp data:%x,%d,%x,%d,%s",srcIp,srcPort,dstIp,dstPort,buf); } void RecvTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; printf("recv tcp data:%x,%d,%x,%d,%s",srcIp,srcPort,dstIp,dstPort,buf); } void RecvUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓包事件 { int node; int i,j,k; char s[1024]; char tm[62],tmp[62]; int fd; printf("recv udp data:%x,%d,%x,%d,%s",srcIp,srcPort,dstIp,dstPort,buf); }" /> 
  <Command cmdname="通讯数据脚本分析" cmdType="P" cmd="[P] void main() { ClearOutputWin(); //清除输出窗口内容 ClearVclControls(); ShowVclWin(160); ShowOutputWin(-1); HideLeftTools(); }; void RecvSerialData(unsigned char *buf,int count)//串口接收到数据 { printf("Recv serial data,len-%d;%s",count,buf); } void CapSerialData(unsigned int ComNum,int RdWt,unsigned char *buf,int count)//串口捕获数据事件 { printf("cap serial data:COM%d,RdWt:%d,len-%d;%s",ComNum,RdWt,count,buf); } void CapUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP抓取到数据包 { printf("cap udp data:%x,%d,%x,%d,len-%d;%s",srcIp,srcPort,dstIp,dstPort,count,buf); } void CapTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//TCP抓取到数据包 { printf("cap tcp data:%x,%d,%x,%d,len-%d;%s",srcIp,srcPort,dstIp,dstPort,count,buf); } void RecvTcpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//TCP接收到数据 { printf("recv tcp data:%x,%d,%x,%d,len-%d;%s",srcIp,srcPort,dstIp,dstPort,count,buf); } void RecvUdpData(unsigned int srcIp,int srcPort,int dstIp,int dstPort,unsigned char *buf,int count)//UDP接收到数据 { printf("recv udp data:%x,%d,%x,%d,len-%d;%s",srcIp,srcPort,dstIp,dstPort,count,buf); }" /> 
  </Command>
  </Command>
  <Command cmdname="逐行发送" cmdType="P" cmd="[P]#include "windows.h" int edt1; int cbHex; int cbx1,cbx2; int tmr1; int btn0,btn1,btn2; int curLineIdx=0; void OnClose(int *sender) { HideVclWin(); CloseVclWin(); } void OnStart(void *sender) { char s[200]; curLineIdx=0; GetProperty(cbx1,"text",s,20); int inv=atoi(s); printf("%d",inv); SetProperty(tmr1,"interval",inv); SetProperty(tmr1,"enabled",1); SetProperty(btn1,"enabled",0); SetProperty(btn2,"enabled",1); } void OnStop() { SetProperty(tmr1,"enabled",0); SetProperty(btn1,"enabled",1); SetProperty(btn2,"enabled",0); } int GetLineStr(char *buf,int size,int idx) { int count; int i; count=GetInputWinLineCount(); if(idx>=count) return -1; GetInputWinLineStr(buf,size,idx); } void OnTimer() { char s[200],s1[202]; int ck; int cr; ck=GetProperty(cbHex,"checked",s,4); if(GetLineStr(s,200,curLineIdx)<0) { OnStop(); return; } SetProperty(edt1,"text",s); printf("Send:%s",s); curLineIdx++; if(ck==1) { SendHexString(s); } else { cr=GetProperty(cbx2,"itemindex",0,0); if(cr==0) sprintf(s1,"%s",s); else if(cr==1) sprintf(s1,"%s\r",s); else if(cr==2) sprintf(s1,"%s\n",s); else if(cr==3) sprintf(s1,"%s\r\n",s); else if(cr==4) sprintf(s1,"%s\n\r",s); SendString(s1); } } void main() { ClearOutputWin(); //清除输出窗口内容 ClearCommWin(); //CloseInputWin(); CloseCodeWin();// HideLeftTools(); HideRightTools(); HideOutputWin(); ClearVclControls(); int p=GetGuiWin(0); btn0=CreateComponentEx(p,"button","caption","关闭", "left",230,"top",70,"width",100,"height",30,"onclick",OnClose,NULL);//创建按钮 btn1=CreateComponentEx(p,"button","caption","开始发送", "left",10,"top",70,"width",100,"height",30,"onclick",OnStart,NULL);//创建按钮 btn2=CreateComponentEx(p,"button","caption","停止发送", "left",120,"top",70,"width",100,"height",30,"onclick",OnStop,NULL);//创建按钮 int lbl1=CreateComponentEx(p,"label", "caption","发送内容:","left",10,"top",8,"width",90,"height",20,NULL);//创建按钮 edt1=CreateComponentEx(p,"edit", "text", "...", "left",70,"top",5,"width",360,"height",20,"enabled",0,NULL);//创建按钮 cbHex=CreateComponentEx(p,"checkbox","caption","十六进制发送","left",10,"top",35,"width",100,"height",20,NULL);//创建按钮 int lbl2=CreateComponentEx(p,"label", "caption","发送间隔:","left",145,"top",37,"width",70,"height",20,NULL);//创建按钮 cbx1=CreateComponentEx(p,"combobox","text","200","left",203,"top",35,"width",60,"height",20,NULL);//创建按钮 int lbl3=CreateComponentEx(p,"label", "caption","毫秒","left",270,"top",37,"width",70,"height",20,NULL);//创建按钮 CreateComponentEx(p,"label", "caption","换行:","left",330,"top",37,"width",80,"height",20,NULL);//创建按钮 cbx2=CreateComponentEx(p,"combobox","left",360,"top",35,"width",70,"height",20,"style","csdropdownlist","itemindex",2,NULL);//创建按钮 tmr1=CreateComponentEx(p,"timer","interval",500,"enabled",0,"ontimer",OnTimer,NULL);//创建按钮 StringsAdd(cbx1,"1"); StringsAdd(cbx1,"100"); StringsAdd(cbx1,"200"); StringsAdd(cbx1,"500"); StringsAdd(cbx1,"1000"); StringsAdd(cbx2,"无"); StringsAdd(cbx2,"回车"); StringsAdd(cbx2,"换行"); StringsAdd(cbx2,"回车换行"); StringsAdd(cbx2,"换行回车"); SetProperty(cbx2,"itemindex",3); AutoSetVclWinSize(); }" /> 
  <Command cmdname="常用数据校验算法工具" cmdType="P" cmd="[P] #define UINT32 unsigned int #define UINT unsigned int #define UCHAR unsigned char #define UINT16 unsigned short #define USHORT unsigned short #define BOOL unsigned char #define FALSE 0 #define TRUE 1 #define ULONG unsigned long //====================================================================================== // 校验和 //====================================================================================== /****************************************************** *函数名称:CheckSum8 *输 入:buf 要校验的数据 len 校验数据的长 *输 出:校验和 *功 能:校验和-8 *******************************************************/ UCHAR CheckSum8(UCHAR *buf,UINT len) { UINT i=0; UCHAR Sum=0; for (i=0; i<len; i++) { Sum+=*buf++; } return Sum; } /****************************************************** *函数名称:CheckSumSum16 *输 入:buf 要校验的数据 len 校验数据的长 *输 出:校验和 *功 能:校验和-16 *******************************************************/ UINT16 CheckSum16(UCHAR *buf,UINT len) { UINT i=0; UINT16 Sum=0; for (i=0; i<len; i++) { Sum+=*buf++; } return Sum; } /****************************************************** *函数名称:CheckSum32 *输 入:buf 要校验的数据 len 校验数据的长 *输 出:校验和 *功 能:校验和-32 *******************************************************/ UINT32 CheckSum32(UCHAR *buf,UINT len) { UINT i=0; UINT32 Sum=0; for (i=0; i<len; i++) { Sum+=*buf++; } return Sum; } /****************************************************** *函数名称:IntelHexCheckSum *输 入:buf 要校验的数据 len 校验数据的长 *输 出:校验和 *功 能:校验和-Intel Hex *******************************************************/ UCHAR IntelHexCheckSum(UCHAR *buf,UINT len) { UCHAR Sum; Sum=CheckSum8(buf,len); Sum=0x01+(UCHAR)(~Sum); return Sum; } /****************************************************** *函数名称:NetCheckSum *输 入:buf 要校验的数据 len 校验数据的长 *输 出:校验和 *功 能:校验和-TCP/IP *******************************************************/ USHORT NetCheckSum(UCHAR *buf, UINT len) { UINT Sum=0; while(len--) { Sum+=*buf++; } Sum= (Sum>> 16) + (Sum& 0xffff); Sum+= (Sum>> 16); return (USHORT)(~Sum); } /****************************************************** *函数名称:BCCVerify *输 入:buf 要校验的数据 len 校验数据的长 *输 出:校验值 *功 能:异或校验 *******************************************************/ UCHAR BCCVerify(UCHAR *buf,UINT len) { UCHAR s=0; UINT i; for ( i=0; i<len; i++) { s = s^(*(buf+i)); } return s; } //====================================================================================== // 奇偶校验 //====================================================================================== /****************************************************** *函数名称:OddParity *输 入:buf 要校验的数据; len 校验数据的长 *输 出:校验和 *功 能:奇校验 *******************************************************/ BOOL OddParity(UCHAR *buf, UINT len) { UINT i=0,j=0; UCHAR d=0; BOOL bParity=FALSE; bParity = 1; for(j = 0; j < len; j++) { d = *(buf + j); for(i = 0; i < 8; i++) { if((d & 0x01) == 0x01) { bParity ^= 1; } d = d >> 1; } } return bParity; } /****************************************************** *函数名称:EvenParity *输 入:buf 要校验的数据; len 校验数据的长 *输 出:校验和 *功 能:偶校验 *******************************************************/ BOOL EvenParity(UCHAR *buf, UINT len) { return (!OddParity(buf,len)); } //====================================================================================== // 循环冗余校验 //====================================================================================== /****************************************************************** * CRC8 码表 ******************************************************************/ //生成多项式：X8+X5+X4+1=0x31 ，CRC8TAB[1]=生成多项式 const UCHAR CRC8TAB[256]= { //0 0x00, 0x31, 0x62, 0x53, 0xC4, 0xF5, 0xA6, 0x97, 0xB9, 0x88, 0xDB, 0xEA, 0x7D, 0x4C, 0x1F, 0x2E, //1 0x43, 0x72, 0x21, 0x10, 0x87, 0xB6, 0xE5, 0xD4, 0xFA, 0xCB, 0x98, 0xA9, 0x3E, 0x0F, 0x5C, 0x6D, //2 0x86, 0xB7, 0xE4, 0xD5, 0x42, 0x73, 0x20, 0x11, 0x3F, 0x0E, 0x5D, 0x6C, 0xFB, 0xCA, 0x99, 0xA8, //3 0xC5, 0xF4, 0xA7, 0x96, 0x01, 0x30, 0x63, 0x52, 0x7C, 0x4D, 0x1E, 0x2F, 0xB8, 0x89, 0xDA, 0xEB, //4 0x3D, 0x0C, 0x5F, 0x6E, 0xF9, 0xC8, 0x9B, 0xAA, 0x84, 0xB5, 0xE6, 0xD7, 0x40, 0x71, 0x22, 0x13, //5 0x7E, 0x4F, 0x1C, 0x2D, 0xBA, 0x8B, 0xD8, 0xE9, 0xC7, 0xF6, 0xA5, 0x94, 0x03, 0x32, 0x61, 0x50, //6 0xBB, 0x8A, 0xD9, 0xE8, 0x7F, 0x4E, 0x1D, 0x2C, 0x02, 0x33, 0x60, 0x51, 0xC6, 0xF7, 0xA4, 0x95, //7 0xF8, 0xC9, 0x9A, 0xAB, 0x3C, 0x0D, 0x5E, 0x6F, 0x41, 0x70, 0x23, 0x12, 0x85, 0xB4, 0xE7, 0xD6, //8 0x7A, 0x4B, 0x18, 0x29, 0xBE, 0x8F, 0xDC, 0xED, 0xC3, 0xF2, 0xA1, 0x90, 0x07, 0x36, 0x65, 0x54, //9 0x39, 0x08, 0x5B, 0x6A, 0xFD, 0xCC, 0x9F, 0xAE, 0x80, 0xB1, 0xE2, 0xD3, 0x44, 0x75, 0x26, 0x17, //A 0xFC, 0xCD, 0x9E, 0xAF, 0x38, 0x09, 0x5A, 0x6B, 0x45, 0x74, 0x27, 0x16, 0x81, 0xB0, 0xE3, 0xD2, //B 0xBF, 0x8E, 0xDD, 0xEC, 0x7B, 0x4A, 0x19, 0x28, 0x06, 0x37, 0x64, 0x55, 0xC2, 0xF3, 0xA0, 0x91, //C 0x47, 0x76, 0x25, 0x14, 0x83, 0xB2, 0xE1, 0xD0, 0xFE, 0xCF, 0x9C, 0xAD, 0x3A, 0x0B, 0x58, 0x69, //D 0x04, 0x35, 0x66, 0x57, 0xC0, 0xF1, 0xA2, 0x93, 0xBD, 0x8C, 0xDF, 0xFE, 0x79, 0x48, 0x1B, 0x2A, //E 0xC1, 0xF0, 0xA3, 0x92, 0x05, 0x34, 0x67, 0x56, 0x78, 0x49, 0x1A, 0x2B, 0xBC, 0x8D, 0xDE, 0xEF, //F 0x82, 0xB3, 0xE0, 0xD1, 0x46, 0x77, 0x24, 0x15, 0x3B, 0x0A, 0x59, 0x68, 0xFF, 0xCE, 0x9D, 0xAC }; /****************************************************** *函数名称:CRC8 *输 入:buf 要校验的数据; len 校验数据的长 *输 出:校验值 *功 能:循环冗余校验-8 *******************************************************/ UCHAR CRC8( UCHAR *buf, UINT len) { UCHAR crc=0; while ( len-- ) { crc = CRC8TAB[crc^*buf]; buf++; } return crc; } /****************************************************** *函数名称:CRC16Default *输 入:pszBuf 要校验的数据 unLength 校验数据的长 *输 出:校验值 *功 能:循环冗余校验-16 （美国标准-0x8005） *******************************************************/ UINT16 CRC16Default(UCHAR * pszBuf, UINT unLength) { UINT32 i, j; UINT16 CrcReg = 0xFFFF; UINT16 CurVal; for (i = 0; i < unLength; i++) { CurVal = pszBuf[i] << 8; for (j = 0; j < 8; j++) { if ((short)(CrcReg ^ CurVal) < 0) CrcReg = (CrcReg << 1) ^ 0x8005; else CrcReg <<= 1; CurVal <<= 1; } } return CrcReg; } /****************************************************** *函数名称:CRC16CCITT *输 入:pszBuf 要校验的数据 unLength 校验数据的长 *输 出:校验值 *功 能:循环冗余校验-16 （CCITT标准-0x1021） *******************************************************/ UINT16 CRC16CCITT(UCHAR * pszBuf, UINT unLength) { UINT32 i, j; UINT16 CrcReg = 0xFFFF; UINT16 CurVal; for (i = 0; i < unLength; i++) { CurVal = pszBuf[i] << 8; for (j = 0; j < 8; j++) { if ((short)(CrcReg ^ CurVal) < 0) CrcReg = (CrcReg << 1) ^ 0x1021; else CrcReg <<= 1; CurVal <<= 1; } } return CrcReg; } /****************************************************** *函数名称:CRC16RTU *输 入:pszBuf 要校验的数据 unLength 校验数据的长 *输 出:校验值 *功 能:循环冗余校验-16 （RTU标准-0xA001） *******************************************************/ UINT16 CRC16RTU( UCHAR * pszBuf, UINT unLength) { UINT16 CRC=0XFFFF; UINT32 CRC_count; for(CRC_count=0; CRC_count<unLength; CRC_count++) { int i; CRC=CRC^*(pszBuf+CRC_count); for(i=0; i<8; i++) { if(CRC&1) { CRC>>=1; CRC^=0xA001; } else { CRC>>=1; } } } return CRC; } static unsigned long Reflect(unsigned long ref, char ch) { unsigned long value = 0; int i; for( i = 1; i < (ch + 1); i++) { if (ref & 1) value |= 1 << (ch - i); ref >>= 1; } return value; } /****************************************************** *函数名称:CRC32Default *输 入:pszBuf 要校验的数据 unLength 校验数据的长 *输 出:校验值 *功 能:循环冗余校验-32 （美国标准-0x04C11DB7） *******************************************************/ ULONG CRC32Default(UCHAR *pszBuf,UINT ulLength) { unsigned long Result = 0xFFFFFFFF; unsigned long m_Table[256]; unsigned long ulPolynomial = 0x04C11DB7; int i,j; for ( i = 0; i <= 0xFF; i++) { m_Table[i] = Reflect(i, 8) << 24; for ( j = 0; j < 8; j++) m_Table[i] = (m_Table[i] << 1) ^ (m_Table[i] & (1 << 31) ? ulPolynomial : 0); m_Table[i] = Reflect(m_Table[i], 32); } while (ulLength--) Result = (Result >> 8) ^ m_Table[(Result & 0xFF) ^ *pszBuf++]; Result ^= 0xFFFFFFFF; return Result; } unsigned long Reflect1(unsigned long ref, char ch) { unsigned long value = 0; int i; for( i = 1; i < (ch + 1); i++) { if (ref & 1) value |= 1 << (ch - i); ref >>= 1; } return value; } //====================================================================================== // 循环冗余校验 //====================================================================================== /****************************************************************** * CRC8 码表 ******************************************************************/ //生??y?????X5+X4+1=0x31 ，CRC8TAB[1]=生成多项式 const UCHAR CRC8TAB[256]= { //0 0x00, 0x31, 0x62, 0x53, 0xC4, 0xF5, 0xA6, 0x97, 0xB9, 0x88, 0xDB, 0xEA, 0x7D, 0x4C, 0x1F, 0x2E, //1 0x43, 0x72, 0x21, 0x10, 0x87, 0xB6, 0xE5, 0xD4, 0xFA, 0xCB, 0x98, 0xA9, 0x3E, 0x0F, 0x5C, 0x6D, //2 0x86, 0xB7, 0xE4, 0xD5, 0x42, 0x73, 0x20, 0x11, 0x3F, 0x0E, 0x5D, 0x6C, 0xFB, 0xCA, 0x99, 0xA8, //3 0xC5, 0xF4, 0xA7, 0x96, 0x01, 0x30, 0x63, 0x52, 0x7C, 0x4D, 0x1E, 0x2F, 0xB8, 0x89, 0xDA, 0xEB, //4 0x3D, 0x0C, 0x5F, 0x6E, 0xF9, 0xC8, 0x9B, 0xAA, 0x84, 0xB5, 0xE6, 0xD7, 0x40, 0x71, 0x22, 0x13, //5 0x7E, 0x4F, 0x1C, 0x2D, 0xBA, 0x8B, 0xD8, 0xE9, 0xC7, 0xF6, 0xA5, 0x94, 0x03, 0x32, 0x61, 0x50, //6 0xBB, 0x8A, 0xD9, 0xE8, 0x7F, 0x4E, 0x1D, 0x2C, 0x02, 0x33, 0x60, 0x51, 0xC6, 0xF7, 0xA4, 0x95, //7 0xF8, 0xC9, 0x9A, 0xAB, 0x3C, 0x0D, 0x5E, 0x6F, 0x41, 0x70, 0x23, 0x12, 0x85, 0xB4, 0xE7, 0xD6, //8 0x7A, 0x4B, 0x18, 0x29, 0xBE, 0x8F, 0xDC, 0xED, 0xC3, 0xF2, 0xA1, 0x90, 0x07, 0x36, 0x65, 0x54, //9 0x39, 0x08, 0x5B, 0x6A, 0xFD, 0xCC, 0x9F, 0xAE, 0x80, 0xB1, 0xE2, 0xD3, 0x44, 0x75, 0x26, 0x17, //A 0xFC, 0xCD, 0x9E, 0xAF, 0x38, 0x09, 0x5A, 0x6B, 0x45, 0x74, 0x27, 0x16, 0x81, 0xB0, 0xE3, 0xD2, //B 0xBF, 0x8E, 0xDD, 0xEC, 0x7B, 0x4A, 0x19, 0x28, 0x06, 0x37, 0x64, 0x55, 0xC2, 0xF3, 0xA0, 0x91, //C 0x47, 0x76, 0x25, 0x14, 0x83, 0xB2, 0xE1, 0xD0, 0xFE, 0xCF, 0x9C, 0xAD, 0x3A, 0x0B, 0x58, 0x69, //D 0x04, 0x35, 0x66, 0x57, 0xC0, 0xF1, 0xA2, 0x93, 0xBD, 0x8C, 0xDF, 0xFE, 0x79, 0x48, 0x1B, 0x2A, //E 0xC1, 0xF0, 0xA3, 0x92, 0x05, 0x34, 0x67, 0x56, 0x78, 0x49, 0x1A, 0x2B, 0xBC, 0x8D, 0xDE, 0xEF, //F 0x82, 0xB3, 0xE0, 0xD1, 0x46, 0x77, 0x24, 0x15, 0x3B, 0x0A, 0x59, 0x68, 0xFF, 0xCE, 0x9D, 0xAC }; /****************************************************** *函数名称:CRC8 *输 入:buf 要校验的数据; len 校验数据的长 *输 出:校验值 *功 能:循环冗余校验-8 *******************************************************/ UCHAR CRC81( UCHAR *buf, UINT len) { UCHAR crc=0; while ( len-- ) { crc = CRC8TAB[crc^*buf]; buf++; } return crc; } /****************************************************** *函数名称:CRC16Default *输 入:pszBuf 要校验的数据 unLength 校验数据的长 *输 出:校验值 *功 能:循环冗余校验-16 （美国标准-0x8005） *******************************************************/ UINT16 CRC16Default1(UCHAR * pszBuf, UINT unLength) { UINT32 i, j; UINT16 CrcReg = 0xFFFF; UINT16 CurVal; for (i = 0; i < unLength; i++) { CurVal = pszBuf[i] << 8; for (j = 0; j < 8; j++) { if ((short)(CrcReg ^ CurVal) < 0) CrcReg = (CrcReg << 1) ^ 0x8005; else CrcReg <<= 1; CurVal <<= 1; } } return CrcReg; } /****************************************************** *函数名称:CRC16CCITT *输 入:pszBuf 要校验的数据 unLength 校验数据的长 *输 出:校验值 *功 能:循环冗余校验-16 （CCITT标准-0x1021） *******************************************************/ UINT16 CRC16CCITT1(UCHAR * pszBuf, UINT unLength) { UINT32 i, j; UINT16 CrcReg = 0xFFFF; UINT16 CurVal; for (i = 0; i < unLength; i++) { CurVal = pszBuf[i] << 8; for (j = 0; j < 8; j++) { if ((short)(CrcReg ^ CurVal) < 0) CrcReg = (CrcReg << 1) ^ 0x1021; else CrcReg <<= 1; CurVal <<= 1; } } return CrcReg; } /****************************************************** *函数名称:CRC16RTU *输 入:pszBuf 要校验的数据 unLength 校验数据的长 *输 出:校验值 *功 能:循环冗余校验-16 （RTU标准-0xA001） *******************************************************/ UINT16 CRC16RTU1( UCHAR * pszBuf, UINT unLength) { UINT16 CRC=0XFFFF; UINT32 CRC_count; for(CRC_count=0; CRC_count<unLength; CRC_count++) { int i; CRC=CRC^*(pszBuf+CRC_count); for(i=0; i<8; i++) { if(CRC&1) { CRC>>=1; CRC^=0xA001; } else { CRC>>=1; } } } return CRC; } static unsigned long Reflect2(unsigned long ref, char ch) { unsigned long value = 0; int i; for( i = 1; i < (ch + 1); i++) { if (ref & 1) value |= 1 << (ch - i); ref >>= 1; } return value; } /****************************************************** *函数名称:CRC32Default *输 入:pszBuf 要校验的数据 unLength 校验数据的长 *输 出:校验值 *功 能:循环冗余校验-32 （美国标准-0x04C11DB7） *******************************************************/ ULONG CRC32Default1(UCHAR *pszBuf,ULONG ulLength) { unsigned long Result = 0xFFFFFFFF; unsigned long m_Table[256]; unsigned long ulPolynomial = 0x04C11DB7; int i,j; for ( i = 0; i <= 0xFF; i++) { m_Table[i] = Reflect(i, 8) << 24; for ( j = 0; j < 8; j++) m_Table[i] = (m_Table[i] << 1) ^ (m_Table[i] & (1 << 31) ? ulPolynomial : 0); m_Table[i] = Reflect(m_Table[i], 32); } while (ulLength--) Result = (Result >> 8) ^ m_Table[(Result & 0xFF) ^ *pszBuf++]; Result ^= 0xFFFFFFFF; return Result; } unsigned long Reflect3(unsigned long ref, char ch) { unsigned long value = 0; int i; for( i = 1; i < (ch + 1); i++) { if (ref & 1) value |= 1 << (ch - i); ref >>= 1; } return value; } ///////////////////////////// 人机界面部分 //////////////////////////////////////////// typedef struct { char *name; int *pFunc; int resultLen; } CHECKLIST; CHECKLIST checkList[]= { {"校验和-8", (int *)(&CheckSum8),8}, {"校验和-16", (int *)(&CheckSum16),16}, {"校验和-32", (int *)(&CheckSum32),32}, {"校验和-Intel Hex",(int *)(&IntelHexCheckSum),8}, {"校验和-TCP/IP", (int *)(&NetCheckSum),8}, {"异或校验", (int *)(&BCCVerify),8}, {"奇校验",(int *)(&OddParity),8}, {"偶校验",(int *)(&EvenParity),8}, {"循环冗余校验-8",(int *)(&CRC8),8}, {"循环冗余校验-16 （CCITT标准-0x1021）",(int *)(&CRC16CCITT),16}, {"循环冗余校验-16 （美国标准-0x8005）",(int *)(&CRC16Default),16}, {"循环冗余校验-16 （RTU标准-0xA001）",(int *)(&CRC16RTU),16}, {"循环冗余校验-32 （美国标准-0x04C11DB7）",(int *)(&CRC32Default),32}, {""}, }; char (*pCheckFunc8)(char *buf,int len); short (*pCheckFunc16)(char *buf,int len); int (*pCheckFunc32)(char *buf,int len); void OnGetSelDat(); void OnGetAllDat(); void OnCalcCheckVal(); void OnClose() { HideVclWin(); // printf("hided"); CloseVclWin(); } int edtSdTxt; int edtSumTxt; int edtSumTxt1; int edtDatLen; int cbx1; void main() { int i; ClearOutputWin(); //清除输出窗口内容 ClearCommWin(); CloseCodeWin(); HideRightTools(); Update(); ClearVclControls(); int p=GetGuiWin(0); CreateComponentEx(p,"label","caption","校验数据:","left",10 ,"top",8,"width",170,"height",20,0); edtSdTxt=CreateComponentEx(p,"memo","text","12 D4 AA 8E","left",10,"top",25,"width",370,"height",130,"scrollbars","ssboth",0); int button0=CreateComponentEx(p,"button","caption","取发送区反选数据","left",80 ,"top",3,"width",140,"height",20,"OnClick",OnGetSelDat,0); int button1=CreateComponentEx(p,"button","caption","取发送区所有数据","left",240,"top",3,"width",140,"height",20,"OnClick",OnGetAllDat,0); CreateComponentEx(p,"label","caption","校验算法:","left",400 ,"top",8,"width",170,"height",20,0); cbx1=CreateComponentEx(p,"combobox","left",460,"top",3,"width",220,"height",20,"style","csdropdownlist","itemindex",2,NULL);//创建按钮 CreateComponentEx(p,"label","caption","十进制求和结果:","left",400,"top",38,"width",170,"height",20,0); edtSumTxt=CreateComponentEx(p,"edit","text","","left",100+400,"top",35,"width",180,"height",20,0); int lblDatLen=CreateComponentEx(p,"label","caption","数据长度:","left", 400,"top",93,"width",170,"height",20,0); edtDatLen=CreateComponentEx(p,"edit","text","","left",100+400,"top",90,"width",180,"height",20,0); int lblSumTxt1=CreateComponentEx(p,"label","caption","16进制结果(8bit):","left", 400,"top",68,"width",170,"height",20,0); edtSumTxt1=CreateComponentEx(p,"edit","text","","left",100+400,"top",65,"width",180,"height",20,0); int button2=CreateComponentEx(p,"button","caption","计算校验","left", 400,"top",125,"width",130,"height",30,"onclick",OnCalcCheckVal,0); int button1=CreateComponentEx(p,"button","caption","关闭","left", 550,"top",125,"width",130,"height",30,"onclick",OnClose,0); //ShowVclWin(150); //ShowOutputWin(200); for(i=0; i<100; i++) { if(checkList[i].name[0]==0)break; StringsAdd(cbx1,checkList[i].name); } SetProperty(cbx1,"itemindex",0); AutoSetVclWinSize(); } void OnGetSelDat() { char s[2000]; GetInputWinSelText(s,2000); if(strlen(s)==0) return; SetProperty(edtSdTxt,"text",s); OnCalcCheckVal(); } void OnGetAllDat() { char s[2000]; GetInputWinText(s,2000); if(strlen(s)==0) return; SetProperty(edtSdTxt,"text",s); OnCalcCheckVal(); } int GetVal(int val) { if((val>=48)&&(val<=57)) return val-48; else if((val>=97)&&(val<=102)) return val+10-97; else if((val>=65)&&(val<=70)) return val+10-65; return 0; } void isDigit(int val) { if((val>=48)&&(val<=57)) return 1; else if((val>=97)&&(val<=102)) return 1; else if((val>=65)&&(val<=70)) return 1; return 0; } void OnCalcCheckVal() { int val,val1,gotfirst; char s[2000]; char buf[2000]; GetProperty(edtSdTxt,"text",s,2000); //s=myForm.edtSdTxt.Text; int i=0; int sum=0; gotfirst=0; int len=0; int ls=strlen(s); while(i<ls) { i=i+1; if(gotfirst==0) { val=s[i-1]; if(isDigit(val)) gotfirst=1; } else { val1=s[i-1]; if(isDigit(val1)) { //sum=sum+GetVal(val)*16+GetVal(val1); buf[len]=GetVal(val)*16+GetVal(val1); len=len+1; gotfirst=0; } else { //sum=sum+GetVal(val); buf[len]=GetVal(val); len=len+1; gotfirst=0; } } } if(gotfirst==1) { sum=sum+GetVal(val); len=len+1; } /*sprintf(s,"%d",sum); SetProperty(edtSumTxt,"text",s); sprintf(s,"%x",sum); SetProperty(edtSumTxt1,"text",s); sprintf(s,"%d",len); SetProperty(edtDatLen,"text",s); */ int idx; idx=GetProperty(cbx1,"itemindex",0,0); if(checkList[idx].resultLen==8) { pCheckFunc8=checkList[idx].pFunc; sum=pCheckFunc8(buf,len); //printf("name:%s,val:%x",checkList[idx].name,sum); } else if(checkList[idx].resultLen==16) { pCheckFunc16=checkList[idx].pFunc; sum=pCheckFunc16(buf,len); //printf("name:%s,val:%x",checkList[idx].name,sum); } else if(checkList[idx].resultLen==32) { pCheckFunc32=checkList[idx].pFunc; sum=pCheckFunc32(buf,len); //printf("name:%s,val:%x",checkList[idx].name,sum); } sprintf(s,"%d",sum); SetProperty(edtSumTxt,"text",s); sprintf(s,"%02X",sum); SetProperty(edtSumTxt1,"text",s); sprintf(s,"%d",len); SetProperty(edtDatLen,"text",s); //for(i=0; i<len; i++) // printf("%x",buf[i]&0xff); }" /> 
  <Command cmdname="发送文件" cmdType="P" cmd="[P]#include "windows.h" #include <stdio.h> #include <string.h> #define BUF_LEN 1 #define LINE 15 int p; FILE *source,*dest; int edt1,edt2,edt3,lblSentCount,lblFileSize; int cbHex; int cbx1,cbx2; int tmr1; int btn0,btn1,btn2; unsigned char *fileDatBuf; int fsize=0; int sendIdx=0; int onePktLen; long int filesize( FILE *fp ) { long int save_pos, size_of_file; save_pos = ftell( fp ); fseek( fp, 0L, SEEK_END ); size_of_file = ftell( fp ); fseek( fp, save_pos, SEEK_SET ); return( size_of_file ); } void OpenFileClick(void *sender) { char s[200]; GetFileName(s,200,"*.*"); if(strlen(s)>0) { SetProperty(edt1,"text",s); } } void SendFileData() { char fname[255]; unsigned char s[100],ch[3]; int i,count,ck; unsigned char *tmpBuf; unsigned char buffer[1024] ; int c; if(fsize>0)free(fileDatBuf); fsize=0; GetProperty(edt1,"text",fname,200); ch[0]=0; ch[2]=0; SetProperty(lblSentCount,"caption","已发送: 0 字节"); SetProperty(lblFileSize,"caption","文件大小: 0 字节"); if( (source=fopen(fname, "rb" )) == NULL ) { sprintf(s,"文件[%s]不存在!",fname); ShowMessage(s); return; } sendIdx=0; if(fsize>0)free(fileDatBuf); fsize=filesize(source); sprintf(s,"文件大小: %d 字节",fsize); SetProperty(lblFileSize,"caption",s); //printf("File size:%d",fsize); ck=GetProperty(cbHex,"checked",s,4); if(ck) { tmpBuf=(unsigned char *)malloc(fsize); fileDatBuf=(unsigned char *)malloc(fsize ); count=fread(tmpBuf,1,fsize,source); //printf("file read:%d ",count ); fsize=0; i=0; while(i<count) { if(((tmpBuf[i]>='0')&& (tmpBuf[i]<='9'))|| ((tmpBuf[i]>='a')&& (tmpBuf[i]<='f'))|| ((tmpBuf[i]>='A')&& (tmpBuf[i]<='F'))) { if(ch[0]==0) ch[0]=tmpBuf[i]; else { ch[1]=tmpBuf[i]; fileDatBuf[fsize]=HexStrToInt(ch); fsize++; ch[0]=0; } } i++; } free(tmpBuf); } else { fileDatBuf=malloc(fsize); count=fread(fileDatBuf,1,fsize,source); //printf("file read:%d ",count ); } fclose(source); GetProperty(cbx2,"text",s,200); onePktLen=atoi(s); if(onePktLen<1)onePktLen=1; //printf("read OK!"); } void OnClose(int *sender) { HideVclWin(); CloseVclWin(); ////PrintToCommWin("over"); } void OnStart(void *sender) { char s[200]; GetProperty(cbx1,"text",s,20); int inv=atoi(s); //printf("%d",inv); SendFileData(); if(fsize>0) { SetProperty(tmr1,"interval",inv); SetProperty(tmr1,"enabled",1); SetProperty(btn1,"enabled",0); SetProperty(btn2,"enabled",1); } //myForm.btnStart.Enabled=false; //myForm.btnStop.Enabled=true; } void OnStop() { SetProperty(tmr1,"enabled",0); SetProperty(btn1,"enabled",1); SetProperty(btn2,"enabled",0); if(fsize>0)free(fileDatBuf); fsize=0; } void OnTimer() { char s[200]; int count; GetProperty(edt1,"text",s,200); if(sendIdx<fsize) { if(fsize-sendIdx>onePktLen) count=onePktLen; else count=fsize-sendIdx; SendBuffer(&fileDatBuf[sendIdx],count); //printf("fsize:%d,sendidx:%d",fsize,sendIdx); sendIdx+=count; sprintf(s,"已发送: %d 字节",sendIdx); SetProperty(lblSentCount,"caption",s); } if(sendIdx>=fsize) { if(fsize>0)free(fileDatBuf); fsize=0; OnStop(); ShowMessage("文件发送结束!"); } } void main() { ClearOutputWin(); //清除输出窗口内容 ClearCommWin(); //CloseInputWin(); CloseCodeWin();// HideLeftTools(); HideRightTools(); HideOutputWin(); ClearVclControls(); int p=GetGuiWin(0); btn0=CreateComponentEx(p,"button","caption","关 闭", "left",300,"top",90,"width",130,"height",30,"onclick",OnClose,NULL);//创建按钮 btn1=CreateComponentEx(p,"button","caption","开始发送", "left",10,"top",90,"width",130,"height",30,"onclick",OnStart,NULL);//创建按钮 btn2=CreateComponentEx(p,"button","caption","停止发送", "left",155,"top",90,"width",130,"height",30,"onclick",OnStop,NULL);//创建按钮 int lbl1=CreateComponentEx(p,"label", "caption","文件名称:","left",10,"top",8,"width",90,"height",20,NULL);//创建按钮 edt1=CreateComponentEx(p,"edit", "text", "c:\\tmp.txt", "left",70,"top",5,"width",330,"height",20,NULL);//创建按钮 //btn0= CreateComponentEx(p,"button","caption","...", "left",410,"top",5,"width",40,"height",22,"onclick",OpenFileClick,NULL);//创建按钮 cbHex=CreateComponentEx(p,"checkbox","caption","十六进制发送","left",10,"top",35,"width",100,"height",20,NULL);//创建按钮 int lbl2=CreateComponentEx(p,"label", "caption","发送间隔:","left",145,"top",37,"width",70,"height",20,NULL);//创建按钮 cbx1=CreateComponentEx(p,"combobox","text","200","left",203,"top",35,"width",60,"height",20,NULL);//创建按钮 int lbl3=CreateComponentEx(p,"label", "caption","毫秒","left",270,"top",37,"width",70,"height",20,NULL);//创建按钮 int lbl2=CreateComponentEx(p,"label", "caption","每包长度:","left",313,"top",37,"width",70,"height",20,NULL);//创建按钮 cbx2=CreateComponentEx(p,"combobox","text","128","left",370,"top",35,"width",50,"height",20,NULL);//创建按钮 int lbl3=CreateComponentEx(p,"label", "caption","字节","left",425,"top",37,"width",70,"height",20,NULL);//创建按钮 lblFileSize=CreateComponentEx(p,"label", "caption","文件大小: 0 字节","left",10,"top",67,"width",120,"height",20,NULL);//创建按钮 lblSentCount=CreateComponentEx(p,"label", "caption","已发送: 0 字节","left",310,"top",67,"width",120,"height",20,NULL);//创建按钮 tmr1=CreateComponentEx(p,"timer","interval",500,"enabled",0,"ontimer",OnTimer,NULL);//创建按钮 //int img=CreateComponentEx(p,"image","left",20,"top",170,"width",100,"height",130,NULL);//创建按钮 //int canvas=GetProperty(img,"canvas",0,0); //LineTo(canvas,100,100); StringsAdd(cbx1,"1"); StringsAdd(cbx1,"100"); StringsAdd(cbx1,"200"); StringsAdd(cbx1,"500"); StringsAdd(cbx1,"1000"); StringsAdd(cbx2,"1"); StringsAdd(cbx2,"16"); StringsAdd(cbx2,"32"); StringsAdd(cbx2,"64"); StringsAdd(cbx2,"128"); StringsAdd(cbx2,"512"); StringsAdd(cbx2,"1024"); StringsAdd(cbx2,"2048"); //ShowVclWin(120); AutoSetVclWinSize(); }" /> 
  </root>